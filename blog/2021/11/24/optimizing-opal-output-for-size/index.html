<!doctype html>
<html style="background-color: #f5f5f5; min-height: 100%;">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <title>Optimizing Opal output for size</title>

  <link href="/assets/application-915b7e3cafe6e192dee011fa09837b2af85b7e1de3dbb52fd1413d46dd2dca0e.css" rel="stylesheet" />
  <link href="//code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css" rel="stylesheet" />

  <script src="/assets/application-74994a7410818947c294a5f44b8f7916d5e1c773e93a5a2c83db9c06d516fd80.js" onload="Opal.loaded(typeof(OpalLoaded) === &quot;undefined&quot; ? [] : OpalLoaded);
Opal.require(&quot;application&quot;);;console.log('loaded application')"></script>

  <!-- Algolia -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
</head>
<body class="blog blog_2021 blog_2021_11 blog_2021_11_24 blog_2021_11_24_optimizing-opal-output-for-size blog_2021_11_24_optimizing-opal-output-for-size_index">
  <nav class='navbar navbar-default opal-nav' role='navigation'>
<div class='container'>
<div class='navbar-header'>
<a class='navbar-brand' href='/'>
<img height='22' src='https://secure.gravatar.com/avatar/88298620949a6534d403da2e356c9339?s=420&amp;d=https://a248.e.akamai.net/assets.github.com%2Fimages%2Fgravatars%2Fgravatar-org-420.png' style='margin-top:-10%;' width='22'>
Opal
</a>
<button class='navbar-toggle' data-target='#opal-navbar' data-toggle='collapse' type='button'>
<span class='icon-bar'></span>
<span class='icon-bar'></span>
<span class='icon-bar'></span>
</button>
</div>
<div class='navbar-collapse collapse' id='opal-navbar'>
<ul class='nav navbar-nav'>
<li>
<a href='/try'>
<i class='ion-ios-compose'></i>
Try
</a>
</li>
<li>
<a href='/blog'>
<i class='ion-ios-chatboxes'></i>
Blog
</a>
</li>
<li>
<a href='/docs'>
<i class='ion-ios-copy'></i>
Documentation
</a>
</li>
<li>
<a href='/libraries'>
<i class='ion-map'></i>
Libraries
</a>
</li>
<li>
<a href='https://github.com/opal/opal#readme'>
<i class='ion-social-github'></i>
GitHub
</a>
</li>
<li>
<a href='https://rubygems.org/gems/opal/versions/1.8.1' style='opacity: 0.5;'>
v1.8.1
</a>
</li>
</ul>
<ul class='nav navbar-right'>
<li class='search-bar'>
<form id='search-form'>
<input placeholder='Search docs &amp; guides' type='search'>
<button title='Clear the search query.' type='reset'>
&times;
</button>
</form>
</li>
</ul>
</div>
</div>
</nav>


  <div class="container">
      <div class="container col-sm-8">
    <div class='blog-title'>
<h1>
<a href='/blog'>The Opal Blog</a>
</h1>
</div>

    <article class='blog-post'>
<header>
<h2 class='blog-post-title'>
<a href=''>
Optimizing Opal output for size
</a>
</h2>
<div class='blog-post-meta'>
Posted by hmdne
<br>
November 24, 2021
</div>
</header>
<div class='blog-post-body'>
<p>Opal doesn&#39;t output the smallest code possible - that&#39;s not our goal. We want to output readable ES5 code and we have tools: JS minifiers&#x000A;(<a href="https://terser.org/">Terser</a> and <a href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a>), and tree shaking utilities&#x000A;(<a href="https://github.com/hmdne/opal-optimizer">opal-optimizer</a>) to bring the code size down.</p>&#x000A;&#x000A;<p>JavaScript and Ruby certainly have some different semantics. Some things work similarly (like open classes), but some others don&#39;t - and those that don&#39;t&#x000A;require some boilerplate code. That not only reduces performance, but also increases load times, both crucial for JavaScript code.</p>&#x000A;&#x000A;<p>In this article we will particularly focus on Terser, since it&#39;s the most widely used tool for Opal post-processing. Can Terser find every nook and&#x000A;cranny and optimize the resulting code to the minimal JavaScript version possible? Unfortunately not. It doesn&#39;t have a knowledge about which&#x000A;statements can produce side effects and which don&#39;t. And so it only does the transformations that are semantically equivalent. But while compiling,&#x000A;we may know something more.</p>&#x000A;&#x000A;<div id="continue-reading"></div>&#x000A;&#x000A;<p>So I attempted an exercise to reduce the size of the compiled JavaScript code. As a benchmark I took a real-world library, <a href="https://asciidoctor.org/">Asciidoctor</a>&#x000A;(available in its Opal-compiled version as Asciidoctor.js), which is the one we already use to test for performance changes in the Opal CI.</p>&#x000A;&#x000A;<p>I took a <a href="https://en.wikipedia.org/wiki/Code_golf">code golfing</a> approach, with the exception that I wanted to produce readable code (Terser will take&#x000A;care of uglifying it), setting myself up for generating the smallest JavaScript AsciiDoc output by improving Opal compiler.&#x000A;The main idea is to reduce the code size, not to increase performance, but as I will sum this up later, those increases will happen together, but to a&#x000A;lesser extent. This exercise took about 4 work days for me.</p>&#x000A;&#x000A;<p>Those improvements will most probably land in the Opal 1.4 release, to happen in late December, along with Ruby 3.1 support. But for now, let me take&#x000A;you for a long journey during which you may pick up a couple of JavaScript optimization tricks and learn a bit about how Opal compiles Ruby to JavaScript.</p>&#x000A;&#x000A;<h2 id="step-1-do-we-need-self">Step 1. Do we need <code>self</code>?</h2>&#x000A;&#x000A;<p>In Opal, we always alias <code>this</code> to <code>self</code> at the beginning of method definitions as <code>var self = this</code>.&#x000A;But, let&#39;s consider the following code, do we really need to define <code>self</code> in that case?</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">loop</span>&#x000A;  <span class="k">while</span> <span class="kp">true</span>&#x000A;    <span class="k">yield</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>&#x000A;</code></pre></div>&#x000A;<p>And so, if a function doesn&#39;t reference self in any way (a special case will be x-strings), let&#39;s not compile it in. So, what gains for AsciiDoctor&#x000A;do we get?</p>&#x000A;&#x000A;<p>Let&#39;s run <code>bin/rake performance</code> and find out:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.239 -&gt; 6.123 (change: -1.86%)&#x000A;                      Run time: 0.285 -&gt; 0.284 (change: -0.10%)&#x000A;                   Bundle size: 5257437 -&gt; 5236087 (change: -0.41%)&#x000A;          Minified bundle size: 1264503 -&gt; 1254455 (change: -0.79%)&#x000A;</code></pre></div>&#x000A;<p>Not much, but at least it&#39;s something. Take note - we can&#39;t reliably compare the first two performance metrics. And also gains for different softwares will be&#x000A;different. The minified bundle size is the created with <code>terser -c</code>. Do also note that all the following outputs of this kind will refer to entire&#x000A;patchset, as compared to Opal v1.3.2.</p>&#x000A;&#x000A;<h2 id="step-2-optimize-methods-that-accept-blocks">Step 2. Optimize methods that accept blocks</h2>&#x000A;&#x000A;<p>Ok, now for a very simple function:</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>&#x000A;<span class="k">end</span>&#x000A;</code></pre></div>&#x000A;<p>You may wonder, what does this function compile to?</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">return</span> <span class="p">(</span><span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$a$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">$iter</span> <span class="o">=</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span><span class="p">,</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$iter</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">,</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">$iter</span><span class="p">)</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>&#x000A;&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">$iter</span><span class="p">)</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>&#x000A;</code></pre></div>&#x000A;<p><em>You can see <code>$a$1</code>, which is a reference to the method body, on which the block is attached as <code>$$p</code> when the method is called.</em></p>&#x000A;&#x000A;<p>Hm, not so good. One statement is duplicated, too many variable declarations. We will focus quite a lot on this method, optimizing it step-by-step in&#x000A;the following passes.</p>&#x000A;&#x000A;<p>So, after some tinkering, this is the result:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">return</span> <span class="p">(</span><span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$a$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">block</span><span class="p">)</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>&#x000A;</code></pre></div>&#x000A;<p>Much better, right? How about the numbers?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.225 -&gt; 6.074 (change: -2.43%)&#x000A;                      Run time: 0.285 -&gt; 0.283 (change: -0.68%)&#x000A;                   Bundle size: 5257437 -&gt; 5220199 (change: -0.71%)&#x000A;          Minified bundle size: 1264503 -&gt; 1244281 (change: -1.60%)&#x000A;</code></pre></div>&#x000A;<p>Okay! That&#39;s not bad!</p>&#x000A;&#x000A;<h2 id="step-3-nil-a">Step 3. <code>nil &amp;&amp; &#39;a&#39;</code>?</h2>&#x000A;&#x000A;<p>The previous versions of Ruby tended to return <code>nil</code> for method definition, but later changed to return <code>Symbol</code>s (i.e. <code>Strings</code> in Opal). So why we&#x000A;actually need this <code>nil</code>? Let&#39;s reduce it:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">return</span> <span class="p">(</span><span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$a$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">block</span><span class="p">)</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span>&#x000A;</code></pre></div>&#x000A;<p>And the numbers:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.221 -&gt; 6.097 (change: -1.98%)&#x000A;                      Run time: 0.284 -&gt; 0.283 (change: -0.21%)&#x000A;                   Bundle size: 5257437 -&gt; 5218997 (change: -0.73%)&#x000A;          Minified bundle size: 1264503 -&gt; 1243880 (change: -1.63%)&#x000A;</code></pre></div>&#x000A;<p>That&#39;s not much. Even though Opal has a lot of method definitions. But let&#39;s go ahead.</p>&#x000A;&#x000A;<h2 id="step-4-helperize-opal-def-and-opal-defs">Step 4. Helperize <code>Opal.def</code> and <code>Opal.defs</code></h2>&#x000A;&#x000A;<p>What does &quot;helperize&quot; mean? Well - in Opal compiler we may make a statement <code>helper :def</code> to generate a per-file top-level statement that does&#x000A;<code>var $def = Opal.def</code>. That&#39;s kinda like more code, right? But most files have more than one use of <code>Opal.def</code>, often even a lot of them. And Terser&#x000A;can&#39;t reliably rename <code>Opal.def</code> to something shorter, but <code>$def</code> can safely become <code>S</code> or whatever it decides. So, our method (now with a broader&#x000A;context) will produce this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="kd">var</span> <span class="nx">$a$1</span><span class="p">,</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$def</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$a$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">block</span><span class="p">)</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span>&#x000A;</code></pre></div>&#x000A;<p>Is that much? Numbers:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.232 -&gt; 6.103 (change: -2.08%)&#x000A;                      Run time: 0.283 -&gt; 0.283 (change: -0.19%)&#x000A;                   Bundle size: 5257437 -&gt; 5214022 (change: -0.83%)&#x000A;          Minified bundle size: 1264503 -&gt; 1238407 (change: -2.06%)&#x000A;</code></pre></div>&#x000A;<p>Yes. It&#39;s quite a lot.</p>&#x000A;&#x000A;<h2 id="step-5-optimize-slice-and-splice-calls">Step 5. Optimize <code>slice</code> and <code>splice</code> calls.</h2>&#x000A;&#x000A;<p>We use those calls a lot for extracting Ruby rest arguments from the <code>arguments</code> array-like object in JavaScript, in methods&#x000A;like <code>def a(arg, *restargs)</code>. <code>Opal.slice</code> is short for <code>Array.prototype.slice</code>.</p>&#x000A;&#x000A;<p>Before this step, we used to output this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>    <span class="nx">$post_args</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>&#x000A;</code></pre></div>&#x000A;<p>Now we output this, which is equivalent:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>    <span class="nx">$post_args</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span>&#x000A;</code></pre></div>&#x000A;<p>Numbers:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code> Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.213 -&gt; 6.107 (change: -1.71%)&#x000A;                      Run time: 0.285 -&gt; 0.282 (change: -0.81%)&#x000A;                   Bundle size: 5257437 -&gt; 5209571 (change: -0.91%)&#x000A;          Minified bundle size: 1264503 -&gt; 1234386 (change: -2.38%)&#x000A;</code></pre></div>&#x000A;<p>So, we are accelerating.</p>&#x000A;&#x000A;<h2 id="step-6-optimize-arity-and-function-variables">Step 6. Optimize <code>$$arity</code> and function variables.</h2>&#x000A;&#x000A;<p>Back to our <code>def a(&amp;block)</code> empty method. Can we optimize this part even further?</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="p">},</span> <span class="nx">$a$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span>&#x000A;</code></pre></div>&#x000A;<p>Also, why do we need this, isn&#39;t it wasteful? (do note that we also need to do <code>var $a$1</code>)</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">return</span> <span class="p">(</span><span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$a$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;</code></pre></div>&#x000A;<p>Let&#39;s optimize those things out:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.1 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$def</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">if</span> <span class="p">(</span><span class="nx">block</span><span class="p">)</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="mi">0</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>Note the <code>0</code> argument. This is a shorthand for <code>{$$arity: 0}</code>. We can&#39;t do this optimization for a minority of methods that need additional properties set.&#x000A;So, what are our gains now?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.249 -&gt; 6.058 (change: -3.05%)&#x000A;                      Run time: 0.286 -&gt; 0.279 (change: -2.17%)&#x000A;                   Bundle size: 5257437 -&gt; 5036072 (change: -4.21%)&#x000A;          Minified bundle size: 1264503 -&gt; 1089609 (change: -13.83%)&#x000A;</code></pre></div>&#x000A;<p>That&#39;s a serious optimization now, isn&#39;t it? Almost 14% lesser files? But let&#39;s not finish here, but go ahead, maybe we can get even smaller files!</p>&#x000A;&#x000A;<h2 id="step-7-delete-p">Step 7. Delete <code>$$p</code></h2>&#x000A;&#x000A;<p>Why do we use things like <code>$$a.$$p</code>? Well - you may not know, if you aren&#39;t too familiar with Opal. This is how we pass a block argument, by setting a&#x000A;<code>$$p</code> property on a called function. After a call, we unset it. But this statement: <code>if (block) $$a.$$p = null;</code>... why can&#39;t we just <code>delete $$a.$$p;</code>?&#x000A;Do we lose some performance then? Perhaps - but not noticeably. And we gain a lot of space. So, our <code>def a(&amp;block)</code> method compiled now looks like this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.1 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$def</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">delete</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="mi">0</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>And the numbers aren&#39;t much better, but cumulatively they are better:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code> Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.239 -&gt; 6.057 (change: -2.92%)&#x000A;                      Run time: 0.286 -&gt; 0.280 (change: -2.03%)&#x000A;                   Bundle size: 5257437 -&gt; 5032881 (change: -4.27%)&#x000A;          Minified bundle size: 1264503 -&gt; 1087119 (change: -14.03%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-8-lets-torture-our-method-a-little-bit-more">Step 8. Let&#39;s torture our method a little bit more</h2>&#x000A;&#x000A;<p>But why can&#39;t <code>Opal.def</code> itself return &#39;a&#39;? If it does, we would be able to get to this form:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.1 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$def</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$a</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">$$a</span><span class="p">()</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nx">block</span> <span class="o">=</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span> <span class="o">||</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">delete</span> <span class="nx">$$a</span><span class="p">.</span><span class="nx">$$p</span><span class="p">;</span>&#x000A;&#x000A;    <span class="p">;</span>&#x000A;    <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span>&#x000A;  <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>We are getting much closer to plain JavaScript now.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.253 -&gt; 6.145 (change: -1.73%)&#x000A;                      Run time: 0.285 -&gt; 0.280 (change: -1.61%)&#x000A;                   Bundle size: 5257437 -&gt; 5028381 (change: -4.36%)&#x000A;          Minified bundle size: 1264503 -&gt; 1086206 (change: -14.10%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-9-nesting-opal-coerce_to-self-a-self-b-self-c-what">Step 9. <code>$$($nesting, &#39;Opal&#39;)[&#39;$coerce_to!&#39;](self.$a(), self.$b(), self.$c())</code> what?</h2>&#x000A;&#x000A;<p>Oh, of course. It&#39;s our representation of:</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="no">Opal</span><span class="p">.</span><span class="nf">coerce_to!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>&#x000A;</code></pre></div>&#x000A;<p>Can we make it into:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">$Opal</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">Opal</span><span class="p">;</span>&#x000A;<span class="nx">$Opal</span><span class="p">[</span><span class="dl">'</span><span class="s1">$coerce_to!</span><span class="dl">'</span><span class="p">](</span><span class="nb">self</span><span class="p">.</span><span class="nx">$a</span><span class="p">(),</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$b</span><span class="p">(),</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$c</span><span class="p">())</span>&#x000A;</code></pre></div>&#x000A;<p>Those calls happen a lot in our corelib (let&#39;s say - a corelib is those parts of Ruby we don&#39;t have to require. stdlib is those libraries that is provided with&#x000A;Ruby but we have to require, like &#39;json&#39;. We will now focus a lot on our corelib). What&#39;s a result then?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.258 -&gt; 6.068 (change: -3.04%)&#x000A;                      Run time: 0.287 -&gt; 0.280 (change: -2.47%)&#x000A;                   Bundle size: 5257437 -&gt; 5041275 (change: -4.11%)&#x000A;          Minified bundle size: 1264503 -&gt; 1083267 (change: -14.33%)&#x000A;</code></pre></div>&#x000A;<p>We also similarly optimized an access to a few more constants like <code>Kernel</code>, <code>Object</code>, <code>BasicObject</code>.</p>&#x000A;&#x000A;<p>_Also in this step we renamed <code>Opal.defineProperty</code> to just <code>Opal.prop</code>. Not much improvement on its own though.`</p>&#x000A;&#x000A;<h2 id="step-10-top-level-constant-access-optimization">Step 10. Top-level constant access optimization</h2>&#x000A;&#x000A;<p>What does <code>::String</code> compile into? Of course into <code>$$$(&quot;::&quot;, &quot;String&quot;)</code>. Why? <code>&quot;::&quot;</code> is a special value here. If we would do something like <code>::A::B</code>, we would&#x000A;get <code>$$$($$$(&quot;::&quot;, &quot;A&quot;), &quot;B&quot;)</code>.</p>&#x000A;&#x000A;<p>But why can&#39;t it become just... <code>$$$(&quot;String&quot;)</code>? It can. And our numbers now are:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.269 -&gt; 6.195 (change: -1.18%)&#x000A;                      Run time: 0.287 -&gt; 0.279 (change: -2.75%)&#x000A;                   Bundle size: 5257437 -&gt; 5020671 (change: -4.50%)&#x000A;          Minified bundle size: 1264503 -&gt; 1077085 (change: -14.82%)&#x000A;</code></pre></div>&#x000A;<p>Not too much, but... we also needed to replace a lot of calls in the corelib from <code>String</code> to <code>::String</code>. This will follow in the next steps.</p>&#x000A;&#x000A;<h2 id="step-11-empty-classes-and-modules">Step 11. Empty classes and modules.</h2>&#x000A;&#x000A;<p>Do empty classes happen a lot? Well - they do. Mostly when you define exceptions. Like we do:</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">StandardError</span>     <span class="o">&lt;</span> <span class="o">::</span><span class="no">Exception</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">EncodingError</span>       <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">ZeroDivisionError</span>   <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">NameError</span>           <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">NoMethodError</span>         <span class="o">&lt;</span> <span class="o">::</span><span class="no">NameError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">RuntimeError</span>        <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">FrozenError</span>           <span class="o">&lt;</span> <span class="o">::</span><span class="no">RuntimeError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">LocalJumpError</span>      <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">TypeError</span>           <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">ArgumentError</span>       <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">UncaughtThrowError</span>    <span class="o">&lt;</span> <span class="o">::</span><span class="no">ArgumentError</span><span class="p">;</span> <span class="k">end</span>&#x000A;<span class="k">class</span> <span class="nc">IndexError</span>          <span class="o">&lt;</span> <span class="o">::</span><span class="no">StandardError</span><span class="p">;</span> <span class="k">end</span>&#x000A;</code></pre></div>&#x000A;<p><em>The indentation denotes a hierarchy :)</em></p>&#x000A;&#x000A;<p>This used to compile to this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.1 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$klass</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">klass</span><span class="p">;</span>&#x000A;&#x000A;&#x000A;  <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="nx">$parent_nesting</span><span class="p">)</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">$klass</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">);</span>&#x000A;&#x000A;    <span class="kd">var</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">$parent_nesting</span><span class="p">);</span>&#x000A;&#x000A;    <span class="k">return</span> <span class="nx">nil</span>&#x000A;  <span class="p">})(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">::</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Exception</span><span class="dl">'</span><span class="p">),</span> <span class="nx">$nesting</span><span class="p">);</span>&#x000A;  <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="nx">$parent_nesting</span><span class="p">)</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">$klass</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="dl">'</span><span class="s1">EncodingError</span><span class="dl">'</span><span class="p">);</span>&#x000A;&#x000A;    <span class="kd">var</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">$parent_nesting</span><span class="p">);</span>&#x000A;&#x000A;    <span class="k">return</span> <span class="nx">nil</span>&#x000A;  <span class="p">})(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">::</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="nx">$nesting</span><span class="p">);</span>&#x000A;  <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="nx">$parent_nesting</span><span class="p">)</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">$klass</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="dl">'</span><span class="s1">ZeroDivisionError</span><span class="dl">'</span><span class="p">);</span>&#x000A;&#x000A;    <span class="kd">var</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">$parent_nesting</span><span class="p">);</span>&#x000A;&#x000A;    <span class="k">return</span> <span class="nx">nil</span>&#x000A;  <span class="p">})(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">::</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="nx">$nesting</span><span class="p">);</span>&#x000A;<span class="p">(...</span><span class="nx">yeah</span> <span class="nx">and</span> <span class="nx">it</span> <span class="nx">goes</span> <span class="nx">like</span> <span class="k">this</span><span class="p">...)</span>&#x000A;</code></pre></div>&#x000A;<p>The closure is kind of... unneeded, isn&#39;t it? Let&#39;s make it disappear for this particular special situation:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.1 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$klass</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">klass</span><span class="p">;</span>&#x000A;&#x000A;&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">Exception</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">EncodingError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">ZeroDivisionError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">NameError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">NameError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">NoMethodError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">RuntimeError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">RuntimeError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">FrozenError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">LocalJumpError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">TypeError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">ArgumentError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">ArgumentError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">UncaughtThrowError</span><span class="dl">'</span><span class="p">);</span>&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="nx">$klass</span><span class="p">(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">$$$</span><span class="p">(</span><span class="dl">'</span><span class="s1">StandardError</span><span class="dl">'</span><span class="p">),</span> <span class="dl">'</span><span class="s1">IndexError</span><span class="dl">'</span><span class="p">),</span> <span class="nx">nil</span><span class="p">);</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>Much better! And numbers?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.202 -&gt; 6.022 (change: -2.90%)&#x000A;                      Run time: 0.285 -&gt; 0.276 (change: -3.02%)&#x000A;                   Bundle size: 5257437 -&gt; 5011915 (change: -4.67%)&#x000A;          Minified bundle size: 1264503 -&gt; 1072799 (change: -15.16%)&#x000A;</code></pre></div>&#x000A;<p>Yay! 15%!</p>&#x000A;&#x000A;<h2 id="step-12-unless-becoming-else">Step 12. <code>unless</code> becoming <code>else</code>?</h2>&#x000A;&#x000A;<p>Ok - let&#39;s take this expression:</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="kp">true</span> <span class="k">unless</span> <span class="kp">false</span>&#x000A;</code></pre></div>&#x000A;<p>What will it compile to?</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="p">{</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="kc">true</span>&#x000A;  <span class="p">};</span>&#x000A;</code></pre></div>&#x000A;<p>Well - makes some sense. Oh, you may ask do we need this $truthy call here? Well - in this particular example - we don&#39;t - but in general, JavaScript has different&#x000A;truthiness semantics. <code>&quot;&quot;</code> is falsy, <code>0</code> is falsy, <code>nil</code> is truthy (yeah - our <code>nil</code> is not JS <code>null</code>). But why an <code>if</code> and <code>else</code> branch. Let&#39;s do it better:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">$truthy</span><span class="p">(</span><span class="kc">false</span><span class="p">))</span> <span class="p">{</span>&#x000A;    <span class="kc">true</span>&#x000A;  <span class="p">};</span>&#x000A;</code></pre></div>&#x000A;<p>And the numbers are:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.164 -&gt; 6.048 (change: -1.87%)&#x000A;                      Run time: 0.284 -&gt; 0.277 (change: -2.62%)&#x000A;                   Bundle size: 5257437 -&gt; 4994938 (change: -4.99%)&#x000A;          Minified bundle size: 1264503 -&gt; 1072746 (change: -15.16%)&#x000A;</code></pre></div>&#x000A;<p>Not much better in the minified bundle size - Terser did a good job here. But in the following it didn&#39;t...</p>&#x000A;&#x000A;<h2 id="step-13-lets-get-out-of-the-closure-hell">Step 13. Let&#39;s get out of the closure hell</h2>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="n">a</span> <span class="o">||</span> <span class="n">b</span> <span class="o">||</span> <span class="n">c</span> <span class="o">||</span> <span class="n">d</span> <span class="o">||</span> <span class="n">e</span>&#x000A;</code></pre></div>&#x000A;<p>Seems simple, right? Can we compile it to the same thing in JS? Oh well, we can&#39;t... we have different truthy semantics as mentioned above. And also, if there&#39;s&#x000A;a <code>next</code> call... you know <code>a || continue</code> is an invalid JavaScript? So... this code compiles to the following monster:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_1</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_2</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_3</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_4</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$a</span><span class="p">())))</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nx">$ret_or_4</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$b</span><span class="p">()</span>&#x000A;  <span class="p">};</span> <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span> <span class="p">})())))</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nx">$ret_or_3</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$c</span><span class="p">()</span>&#x000A;  <span class="p">};</span> <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span> <span class="p">})())))</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nx">$ret_or_2</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$d</span><span class="p">()</span>&#x000A;  <span class="p">};</span> <span class="k">return</span> <span class="nx">nil</span><span class="p">;</span> <span class="p">})())))</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nx">$ret_or_1</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$e</span><span class="p">()</span>&#x000A;  <span class="p">}</span>&#x000A;</code></pre></div>&#x000A;<p>Well. That&#39;s a lot of functions. And expressions like <code>next</code> don&#39;t happen here. Can&#39;t we at least use a ternary operator where we can:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code>  <span class="k">if</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_3</span> <span class="o">=</span> <span class="p">(</span><span class="nx">$truthy</span><span class="p">((</span><span class="nx">$ret_or_4</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$a</span><span class="p">()))</span> <span class="p">?</span> <span class="p">(</span><span class="nx">$ret_or_4</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">$b</span><span class="p">()))))</span> <span class="p">?</span> <span class="p">(</span><span class="nx">$ret_or_3</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">$c</span><span class="p">()))))</span> <span class="p">?</span> <span class="p">(</span><span class="nx">$ret_or_2</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">$d</span><span class="p">())))))</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nx">$ret_or_1</span>&#x000A;  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>&#x000A;    <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$e</span><span class="p">()</span>&#x000A;  <span class="p">}</span>&#x000A;</code></pre></div>&#x000A;<p>This is still ugly. But we don&#39;t abuse the functions. Numbers:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.269 -&gt; 6.198 (change: -1.13%)&#x000A;                      Run time: 0.286 -&gt; 0.273 (change: -4.44%)&#x000A;                   Bundle size: 5257437 -&gt; 4868356 (change: -7.40%)&#x000A;          Minified bundle size: 1264503 -&gt; 1069576 (change: -15.42%)&#x000A;</code></pre></div>&#x000A;<p>We improved the performance quite a bit. And the un-Tersered code size - but Terser also gained a bit. We lost a bit of compiler performance though.</p>&#x000A;&#x000A;<h2 id="step-14-various-small-optimizations">Step 14. Various small optimizations</h2>&#x000A;&#x000A;<p>Opal doesn&#39;t support mutable strings (we have a plan to support them in the near future!) - and so we alert the developer if he tries to access them. But it&#39;s&#x000A;a lot of method definitions. Let&#39;s compress them with a <code>define_method</code> loop.</p>&#x000A;&#x000A;<p>We also sometimes compile empty files - called stubbing - so we can for example make <code>require &quot;yaml&quot;</code> not fail - even though we don&#39;t use YAML, but some compiled-in&#x000A;method does. Let&#39;s make those compiled files smaller.</p>&#x000A;&#x000A;<p>Also, <code>eval</code> in JavaScript is considered harmful. Let&#39;s at least use a different facility to support Ruby <code>instance_eval</code>.</p>&#x000A;&#x000A;<p>Result:</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.071 -&gt; 5.965 (change: -1.76%)&#x000A;                      Run time: 0.285 -&gt; 0.271 (change: -4.75%)&#x000A;                   Bundle size: 5259054 -&gt; 4856724 (change: -7.65%)&#x000A;          Minified bundle size: 1264953 -&gt; 1067161 (change: -15.64%)&#x000A;</code></pre></div>&#x000A;<p>Not much, but it still gives us some headroom.</p>&#x000A;&#x000A;<h2 id="step-15-strikes-again">Step 15. <code>||</code> strikes again</h2>&#x000A;&#x000A;<p>Some libraries (like <code>parser</code>) happen to use <code>||</code> a lot. For each usage, we generate a new <code>$ret_or_X</code> where <code>X &gt; 0</code> variable. This is so we can save the&#x000A;left-hand-side expression and return it later, possibly. And we don&#39;t reuse them, so we get a very large <code>var $ret_or_1, $ret_or_2, $ret_or_3 ... $ret_or_42;</code>&#x000A;definition. Let&#39;s reuse those.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.110 -&gt; 5.972 (change: -2.25%)&#x000A;                      Run time: 0.286 -&gt; 0.271 (change: -5.20%)&#x000A;                   Bundle size: 5259054 -&gt; 4826837 (change: -8.22%)&#x000A;          Minified bundle size: 1264953 -&gt; 1058462 (change: -16.32%)&#x000A;</code></pre></div>&#x000A;<p>A nice improvement!</p>&#x000A;&#x000A;<h2 id="step-16-more-helperizing">Step 16. More helperizing</h2>&#x000A;&#x000A;<p>In compiled Asciidoctor I found a lot of dynamic regexps. And we define them by <code>Opal.regexp([a,b,c])</code>. Let&#39;s make it just <code>$regexp([a,b,c])</code> and let&#39;s shorten&#x000A;a lot of other definitions like this. At this point I noticed, that we don&#39;t run Terser with name mangling in effect. Let&#39;s change it just now. The numbers are&#x000A;compared to Opal 1.3.2.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.089 -&gt; 6.006 (change: -1.36%)&#x000A;                      Run time: 0.285 -&gt; 0.269 (change: -5.39%)&#x000A;                   Bundle size: 5259054 -&gt; 4824589 (change: -8.26%)&#x000A;          Minified bundle size: 1264953 -&gt; 1054974 (change: -16.60%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 732066 (change: -9.87%)&#x000A;</code></pre></div>&#x000A;<p>That&#39;s fair enough.</p>&#x000A;&#x000A;<h2 id="step-17-optimize-instance-variable-access">Step 17. Optimize instance variable access</h2>&#x000A;&#x000A;<p>For two reasons, we set <code>@variables</code> to <code>nil</code> by default if they are referenced. The first reason is obvious, <code>@variable</code> is compiled to <code>self.variable</code> and we&#x000A;don&#39;t want <code>undefined</code> values to creep in - they are not an object and in Ruby everything is an object - we want to keep that impression, so in Opal <code>undefined</code>&#x000A;doesn&#39;t exist (if you get <code>undefined</code> somewhere - you have hit a bug or accessed some low level interfaces). The second is to improve a shape for the JS engines&#x000A;to optimize the code better.</p>&#x000A;&#x000A;<p>The problem is, that the code looks like this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nb">self</span><span class="p">.</span><span class="nx">$$prototype</span><span class="p">.</span><span class="nx">variable1</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$$prototype</span><span class="p">.</span><span class="nx">variable2</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$$prototype</span><span class="p">.</span><span class="nx">variable3</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$$prototype</span><span class="p">.</span><span class="nx">variable4</span> <span class="o">=</span> <span class="nx">nil</span>&#x000A;</code></pre></div>&#x000A;<p>Why not make it:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="kd">var</span> <span class="nx">$proto</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nx">$$prototype</span><span class="p">;</span>&#x000A;<span class="nx">$proto</span><span class="p">.</span><span class="nx">variable1</span> <span class="o">=</span> <span class="nx">$proto</span><span class="p">.</span><span class="nx">variable2</span> <span class="o">=</span> <span class="nx">$proto</span><span class="p">.</span><span class="nx">variable3</span> <span class="o">=</span> <span class="nx">$proto</span><span class="p">.</span><span class="nx">variable4</span> <span class="o">=</span> <span class="nx">nil</span>&#x000A;</code></pre></div>&#x000A;<p>Remember - <code>$proto</code> can be safely renamed. <code>self.$$prototype</code> can&#39;t.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.086 -&gt; 6.014 (change: -1.19%)&#x000A;                      Run time: 0.284 -&gt; 0.269 (change: -5.28%)&#x000A;                   Bundle size: 5259054 -&gt; 4823880 (change: -8.27%)&#x000A;          Minified bundle size: 1264953 -&gt; 1053776 (change: -16.69%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 730112 (change: -10.12%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-18-method_missing-stubs-definition-optimization">Step 18. <code>#method_missing</code> stubs definition optimization</h2>&#x000A;&#x000A;<p>How does <code>#method_missing</code> work on Opal? In JavaScript there&#39;s no facility for that. Well - we define so-called stubs, which means that for every call you want&#x000A;to make, we define a method on <code>BasicObject</code> that basically calls <code>#method_missing</code>. This way no method is missing and all calls success. And if you use a call&#x000A;like <code>#send</code>... we have an easier job here, but we don&#39;t want to use <code>#send</code> everywhere for performance reasons.</p>&#x000A;&#x000A;<p>The stubs used to be defined this way, for every file:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">add_stubs</span><span class="p">([</span><span class="dl">"</span><span class="s2">$hello</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">$new</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">$&lt;</span><span class="dl">"</span><span class="p">]);</span>&#x000A;</code></pre></div>&#x000A;<p>Let&#39;s make it shorter:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">add_stubs</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello,new,&lt;</span><span class="dl">"</span><span class="p">);</span>&#x000A;</code></pre></div>&#x000A;<p>This also helps the JS parsers. This is how Google Closure Compiler optimizes large arrays of Strings.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code> Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.088 -&gt; 6.008 (change: -1.30%)&#x000A;                      Run time: 0.285 -&gt; 0.271 (change: -5.08%)&#x000A;                   Bundle size: 5259054 -&gt; 4812284 (change: -8.50%)&#x000A;          Minified bundle size: 1264953 -&gt; 1044964 (change: -17.39%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 721296 (change: -11.20%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-19-hiding-and">Step 19. Hiding <code>$$</code> and <code>$$$</code>.</h2>&#x000A;&#x000A;<p>What is <code>$$$</code> - I explained in one of the earlier parts. But what is <code>$$</code> - I haven&#39;t. This is a relative constant access function. This is a bit less performant,&#x000A;because we have to iterate thru every <code>class</code> and <code>module</code> we are in and their ancestors - and <code>Object</code> and its ancestors as well. We store a list of modules and&#x000A;classes in a <code>$nesting</code> variable. And then we can call <code>$$($nesting, &quot;String&quot;)</code> to find our <code>String</code> - because - maybe it is an <code>Array::String</code>? Well, we know it&#x000A;isn&#39;t, so we have to change our <code>corelib</code> furthermore a lot. And then - suddenly - some files don&#39;t need <code>$$</code>, so we don&#39;t need to helperize it.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.082 -&gt; 5.964 (change: -1.94%)&#x000A;                      Run time: 0.284 -&gt; 0.270 (change: -4.92%)&#x000A;                   Bundle size: 5259054 -&gt; 4811653 (change: -8.51%)&#x000A;          Minified bundle size: 1264953 -&gt; 1041721 (change: -17.65%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 720161 (change: -11.34%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-20-nesting-do-we-need-it">Step 20. <code>$nesting</code> - do we need it?</h2>&#x000A;&#x000A;<p>Sometimes though, we don&#39;t even need <code>$nesting</code> to be computed. If our class is small, doesn&#39;t have classes defined in its namespace and we don&#39;t reference&#x000A;constants relatively, we may skip computing <code>$nesting</code> altogether.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.090 -&gt; 5.952 (change: -2.27%)&#x000A;                      Run time: 0.284 -&gt; 0.269 (change: -5.26%)&#x000A;                   Bundle size: 5259054 -&gt; 4806185 (change: -8.61%)&#x000A;          Minified bundle size: 1264953 -&gt; 1036887 (change: -18.03%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 717787 (change: -11.63%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-21-curry">Step 21. Curry <code>$$</code></h2>&#x000A;&#x000A;<p>I came upon an idea, that the <code>$$</code> method can be curried. Of course, this moves its definition from the top level scope to the class/module scope so it means&#x000A;it may happen more often. So now we don&#39;t call <code>$$($nesting, &quot;String&quot;)</code>, but we can simply call <code>$$(&quot;String&quot;)</code> because <code>$$</code> is defined with <code>$nesting</code>. Do we&#x000A;get any optimization from that, then?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code> Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.097 -&gt; 5.976 (change: -1.99%)&#x000A;                      Run time: 0.285 -&gt; 0.270 (change: -5.41%)&#x000A;                   Bundle size: 5259054 -&gt; 4795627 (change: -8.81%)&#x000A;          Minified bundle size: 1264953 -&gt; 1027837 (change: -18.75%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 716231 (change: -11.82%)&#x000A;</code></pre></div>&#x000A;<p>Yes. And quite a big one if we don&#39;t mangle variable names.</p>&#x000A;&#x000A;<h2 id="step-22-interpolated-strings-optimization">Step 22. Interpolated strings optimization</h2>&#x000A;&#x000A;<p>What do we do with strings like <code>&quot;aaaa#{true}&quot;</code> (also called dstrs)? Of course, we compile them to:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="dl">""</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">aaaa</span><span class="dl">"</span> <span class="o">+</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span>&#x000A;</code></pre></div>&#x000A;<p>Why does it make sense? Also, how comes this thing can use the <code>+</code> operator? Well, let me explain. In JavaScript, <code>&quot;&quot; + obj</code> is actually equivalent to&#x000A;<code>&quot;&quot; + obj.toString()</code>. And <code>toString()</code> for Opal objects call <code>#to_s</code> - so this is exactly what <code>&quot;aaaa#{true}</code> does in Ruby.</p>&#x000A;&#x000A;<p>And you may say - ok, for strings like <code>&quot;#{5}&quot;</code> (being compiled to <code>&quot;&quot; + 5</code>) this makes sense. But if the first part of a dstr is a string, we don&#39;t need this&#x000A;<code>&quot;&quot;</code>. Yes - though, Terser applies this optimization, so there&#39;s 0 gain there.</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code> Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.087 -&gt; 5.959 (change: -2.10%)&#x000A;                      Run time: 0.284 -&gt; 0.269 (change: -5.45%)&#x000A;                   Bundle size: 5259054 -&gt; 4783491 (change: -9.04%)&#x000A;          Minified bundle size: 1264953 -&gt; 1027837 (change: -18.75%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 716231 (change: -11.82%)&#x000A;</code></pre></div>&#x000A;<h2 id="step-23-hide-parent_nesting-if-its-not-needed">Step 23. Hide <code>$parent_nesting</code> if it&#39;s not needed</h2>&#x000A;&#x000A;<p>This is a small one. But this is the last one in this patch series. Let&#39;s conclude it with compilation of this Ruby code:</p>&#x000A;<div class="highlight"><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">A</span>&#x000A;  <span class="k">def</span> <span class="nf">x</span>&#x000A;  <span class="k">end</span>&#x000A;<span class="k">end</span>&#x000A;</code></pre></div>&#x000A;<p>Opal 1.3.2 outputs this:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.2 */</span>&#x000A;  <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">top</span><span class="p">,</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$$</span><span class="p">,</span> <span class="nx">$$</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">$$</span><span class="p">,</span> <span class="nx">$klass</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">klass</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="nx">$parent_nesting</span><span class="p">)</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">$klass</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">);</span>&#x000A;&#x000A;    <span class="kd">var</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="nx">$parent_nesting</span><span class="p">),</span> <span class="nx">$A_x$1</span><span class="p">;</span>&#x000A;&#x000A;    <span class="k">return</span> <span class="p">(</span><span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$x</span><span class="dl">'</span><span class="p">,</span> <span class="nx">$A_x$1</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">$$x</span><span class="p">()</span> <span class="p">{</span>&#x000A;      <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>&#x000A;&#x000A;      <span class="k">return</span> <span class="nx">nil</span>&#x000A;    <span class="p">},</span> <span class="nx">$A_x$1</span><span class="p">.</span><span class="nx">$$arity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">nil</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span>&#x000A;  <span class="p">})(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">$nesting</span><span class="p">)</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>This patchset makes it output the following:</p>&#x000A;<div class="highlight"><pre class="highlight javascript"><code><span class="nx">Opal</span><span class="p">.</span><span class="nx">queue</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">Opal</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* Generated by Opal 1.3.2 */</span>&#x000A;  <span class="kd">var</span> <span class="nx">$nesting</span> <span class="o">=</span> <span class="p">[],</span> <span class="nx">nil</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">nil</span><span class="p">,</span> <span class="nx">$klass</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">klass</span><span class="p">,</span> <span class="nx">$def</span> <span class="o">=</span> <span class="nx">Opal</span><span class="p">.</span><span class="nx">def</span><span class="p">;</span>&#x000A;&#x000A;  <span class="k">return</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">)</span> <span class="p">{</span>&#x000A;    <span class="kd">var</span> <span class="nb">self</span> <span class="o">=</span> <span class="nx">$klass</span><span class="p">(</span><span class="nx">$base</span><span class="p">,</span> <span class="nx">$super</span><span class="p">,</span> <span class="dl">'</span><span class="s1">A</span><span class="dl">'</span><span class="p">);</span>&#x000A;&#x000A;&#x000A;    <span class="k">return</span> <span class="nx">$def</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="dl">'</span><span class="s1">$x</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">$$x</span><span class="p">()</span> <span class="p">{</span>&#x000A;&#x000A;      <span class="k">return</span> <span class="nx">nil</span>&#x000A;    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>&#x000A;  <span class="p">})(</span><span class="nx">$nesting</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">null</span><span class="p">)</span>&#x000A;<span class="p">});</span>&#x000A;</code></pre></div>&#x000A;<p>Therefore we skip one variable more. And while some JS minifiers may find this thing and optimize it out itself, some don&#39;t</p>&#x000A;&#x000A;<h2 id="conclusion">Conclusion</h2>&#x000A;&#x000A;<p>After this patchset is merged, Opal will produce much cleaner code with much lesser complexity that you can read much easier without knowledge of how Opal actually&#x000A;works under the hood. If you know Ruby, you are likely to know what <code>$super</code> means in this particular code (if you don&#39;t, it means a superclass, which <code>A</code> doesn&#39;t&#x000A;have set). So, to conclude. What are the total gains from this entire patchset?</p>&#x000A;<div class="highlight"><pre class="highlight plaintext"><code>Comparison of the Asciidoctor (a real-life Opal application) compile and run:&#x000A;                  Compile time: 6.073 -&gt; 5.956 (change: -1.92%)&#x000A;                      Run time: 0.284 -&gt; 0.269 (change: -5.46%)&#x000A;                   Bundle size: 5259054 -&gt; 4781496 (change: -9.08%)&#x000A;          Minified bundle size: 1264953 -&gt; 1026844 (change: -18.82%)&#x000A;            Mangled &amp; minified: 812275 -&gt; 715972 (change: -11.86%)&#x000A;</code></pre></div>&#x000A;<p>Of course - the numbers will depend on what you compile with Opal and how you minimize (or not). I tried compiling Opal-Parser and the size numbers reached about&#x000A;15%. And you will get about 5% better performance (note - the performance gains are computed on a non-minified bundle, so if you minify you may get even better&#x000A;performance gains).</p>&#x000A;&#x000A;<p>This doesn&#39;t end the optimization efforts we have - there are still some ideas that weren&#39;t realized in this patchset.</p>&#x000A;&#x000A;<p>This patchset is <a href="https://github.com/opal/opal/pull/2356">located here</a>. If you are interested in writing compilers, reading the source code of Opal compiler may&#x000A;prove useful - it&#39;s relatively lightweight, well organized and it&#39;s all Ruby! All despite the fact, that Ruby is one of the hardest to parse programming languages&#x000A;in existence (if not the hardest) - all lexing and parsing happens in a wonderful <a href="https://github.com/whitequark/parser">parser</a> library which is also used by&#x000A;<a href="https://rubocop.org/">RuboCop</a> and many other gems!</p>&#x000A;</div>
</article>

  </div>

  </div>

  <footer>
  <a href="/license"><i class="ion-unlocked"></i> License</a> ·
  <a href="https://github.com/opal/opal/graphs/contributors"><i class="ion-fork-repo"></i> Contributors</a>
</footer>


  <script>
    document.querySelector(`a[href="${location.pathname.replace(/\/$/,'')}"]`)?.parentElement.classList.add("active")
  </script>

  <!-- Algolia -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
  <script type="text/javascript">
    docsearch({
      apiKey: 'cf08db1eca77cb92ca34e24a86430bcb',
      indexName: 'opalrb',
      inputSelector: '#search-form input[type="search"]',
      debug: false // Set debug to true if you want to inspect the dropdown
    });
  </script>
</body>
</html>
