<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: RUNTIME
  
    &mdash; corelib (Opal v1.8.2)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "RUNTIME";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  <span class="title"><a href="/docs">Opal Docs</a></span>
  
    &raquo;
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: RUNTIME</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="runtime-js">runtime.js</h1>

<h2 id="part-597705">``</h2>

<p>@note
  A few conventions for the documentation of this file:</p>

<ol>
<li>Always use &quot;//&quot; (in contrast with &quot;/**/&quot;)</li>
<li>The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)</li>
<li><code>@param</code> and <code>@return</code> types should be preceded by <code>JS.</code> when referring to
 JavaScript constructors (e.g. <code>JS.Function</code>) otherwise Ruby is assumed.</li>
<li><code>nil</code> and <code>null</code> being unambiguous refer to the respective
 objects/values in Ruby and JavaScript</li>
<li>This is still WIP :) so please give feedback and suggestions on how
 to improve or for alternative solutions</li>
</ol>

<p>The way the code is digested before going through Yardoc is a secret kept
  in the docs repo (<a href="https://github.com/opal/docs/tree/master">https://github.com/opal/docs/tree/master</a>).</p>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="if-typeof-globalthis-undefined-global_object-globalthis"><code>if (typeof(globalThis) !== &#39;undefined&#39;) { global_object = globalThis; }</code></h2>

<p>Detect the global object</p>

<pre class="code js"><code class="js">if (typeof(globalThis) !== &#39;undefined&#39;) { global_object = globalThis; }
</code></pre>

<h2 id="if-global_object-console-null"><code>if (global_object.console == null)</code></h2>

<p>Setup a dummy console object if missing</p>

<pre class="code js"><code class="js">if (global_object.console == null) {
</code></pre>

<h2 id="basicobject"><code>BasicObject</code></h2>

<p>The actual class for BasicObject</p>

<pre class="code js"><code class="js">var BasicObject;
</code></pre>

<h2 id="_object"><code>_Object</code></h2>

<p>The actual Object class.
The leading underscore is to avoid confusion with window.Object()</p>

<pre class="code js"><code class="js">var _Object;
</code></pre>

<h2 id="module"><code>Module</code></h2>

<p>The actual Module class</p>

<pre class="code js"><code class="js">var Module;
</code></pre>

<h2 id="class"><code>Class</code></h2>

<p>The actual Class class</p>

<pre class="code js"><code class="js">var Class;
</code></pre>

<h2 id="_opal"><code>_Opal</code></h2>

<p>The Opal.Opal class (helpers etc.)</p>

<pre class="code js"><code class="js">var _Opal;
</code></pre>

<h2 id="kernel"><code>Kernel</code></h2>

<p>The Kernel module</p>

<pre class="code js"><code class="js">var Kernel;
</code></pre>

<h2 id="opal-global_object-opal"><code>Opal = global_object.Opal = {}</code></h2>

<p>The Opal object that is exposed globally</p>

<pre class="code js"><code class="js">var Opal = global_object.Opal = {};
</code></pre>

<h2 id="opal-global-global_object"><code>Opal.global = global_object</code></h2>

<p>This is a useful reference to global object inside ruby files</p>

<pre class="code js"><code class="js">Opal.global = global_object;
</code></pre>

<h2 id="opal-config"><code>Opal.config =</code></h2>

<p>Configure runtime behavior with regards to require and unsupported features</p>

<pre class="code js"><code class="js">Opal.config = {
</code></pre>

<h2 id="call-function-prototype-call"><code>$call      = Function.prototype.call</code></h2>

<p>Minify common function calls</p>

<pre class="code js"><code class="js">var $call      = Function.prototype.call;
</code></pre>

<h2 id="nil_id-4"><code>nil_id = 4</code></h2>

<p>Nil object id is always 4</p>

<pre class="code js"><code class="js">var nil_id = 4;
</code></pre>

<h2 id="unique_id-nil_id"><code>unique_id = nil_id</code></h2>

<p>Generates even sequential numbers greater than 4
(nil_id) to serve as unique ids for ruby objects</p>

<pre class="code js"><code class="js">var unique_id = nil_id;
</code></pre>

<h2 id="function-uid"><code>function $uid()</code></h2>

<p>Return next unique id</p>

<pre class="code js"><code class="js">function $uid() {
  unique_id += 2;
  return unique_id;
};
</code></pre>

<h2 id="opal-id-function-obj"><code>Opal.id = function(obj)</code></h2>

<p>Retrieve or assign the id of an object</p>

<pre class="code js"><code class="js">Opal.id = function(obj) {
  if (obj.$$is_number) return (obj * 2)+1;
  if (obj.$$id == null) {
    $prop(obj, &#39;$$id&#39;, $uid());
  }
  return obj.$$id;
};
</code></pre>

<h2 id="gvars-opal-gvars"><code>$gvars = Opal.gvars = {}</code></h2>

<p>Globals table</p>

<pre class="code js"><code class="js">var $gvars = Opal.gvars = {};
</code></pre>

<h2 id="opal-exit-function-status-if-gvars-debug-console-log-exited-with-status-status"><code>Opal.exit = function(status) { if ($gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); }</code></h2>

<p>Exit function, this should be replaced by platform specific implementation
(See nodejs and chrome for examples)</p>

<pre class="code js"><code class="js">Opal.exit = function(status) { if ($gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); };
</code></pre>

<h2 id="opal-exceptions"><code>Opal.exceptions = []</code></h2>

<p>keeps track of exceptions for $!</p>

<pre class="code js"><code class="js">Opal.exceptions = [];
</code></pre>

<h2 id="opal-pop_exception-function-rescued_exception"><code>Opal.pop_exception = function(rescued_exception)</code></h2>

<p>@private
Pops an exception from the stack and updates <code>$!</code>.</p>

<pre class="code js"><code class="js">Opal.pop_exception = function(rescued_exception) {
  var exception = Opal.exceptions.pop();
  if (exception === rescued_exception) {
    // Current $! is raised in the rescue block, so we don&#39;t update it
  }
  else if (exception) {
    $gvars[&quot;!&quot;] = exception;
  }
  else {
    $gvars[&quot;!&quot;] = nil;
  }
};
</code></pre>

<h2 id="function-raise-klass-message"><code>function $raise(klass, message)</code></h2>

<p>A helper function for raising things, that gracefully degrades if necessary
functionality is not yet loaded.</p>

<pre class="code js"><code class="js">function $raise(klass, message) {
  // Raise Exception, so we can know that something wrong is going on.
  if (!klass) klass = Opal.Exception || Error;

  if (Kernel &amp;&amp; Kernel.$raise) {
    if (arguments.length &gt; 2) {
      Kernel.$raise(klass.$new.apply(klass, $slice(arguments, 1)));
    }
    else {
      Kernel.$raise(klass, message);
    }
  }
  else if (!klass.$new) {
    throw new klass(message);
  }
  else {
    throw klass.$new(message);
  }
}
</code></pre>

<h2 id="prop_options"><code>prop_options =</code></h2>

<p>Reuse the same object for performance/memory sake</p>

<pre class="code js"><code class="js">var prop_options = {
</code></pre>

<h2 id="object-name-initialvalue"><code>object[name] = initialValue</code></h2>

<p>Special case for:
  s = &quot;string&quot;
  def s.m; end
String class is the only class that:</p>

<ul>
<li>compiles to JS primitive</li>
<li>allows method definition directly on instances
numbers, true, false and null do not support it.</li>
</ul>

<pre class="code js"><code class="js">object[name] = initialValue;
</code></pre>

<h2 id="opal-defineproperty-opal-prop"><code>Opal.defineProperty = Opal.prop</code></h2>

<p>@deprecated</p>

<pre class="code js"><code class="js">Opal.defineProperty = Opal.prop;
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="helpers">Helpers</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="if-object-respond_to-pristine-object-method_missing-pristine"><code>if (object[&#39;$respond_to?&#39;].$$pristine &amp;&amp; object.$method_missing.$$pristine)</code></h2>

<p>Fast path for the most common situation</p>

<pre class="code js"><code class="js">if (object[&#39;$respond_to?&#39;].$$pristine &amp;&amp; object.$method_missing.$$pristine) {
</code></pre>

<h2 id="opal-trace_class-false"><code>Opal.trace_class = false</code></h2>

<h2 id="tracepoint-support">TracePoint support</h2>

<p>Support for <code>TracePoint.trace(:class) do ... end</code></p>

<pre class="code js"><code class="js">Opal.trace_class = false;
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="constants">Constants</h2>

<p>For future reference:</p>

<ul>
<li>The Rails autoloading guide (<a href="http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html">http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html</a>)</li>
<li>@ConradIrwin&#39;s 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (<a href="http://cirw.in/blog/constant-lookup.html">http://cirw.in/blog/constant-lookup.html</a>)</li>
</ul>

<p>Legend of MRI concepts/names:</p>

<ul>
<li>constant reference (cref): the module/class that acts as a namespace</li>
<li>nesting: the namespaces wrapping the current scope, e.g. nesting inside
       <code>module A; module B::C; end; end</code> is <code>[B::C, A]</code></li>
</ul>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="function-const_get_name-cref-name"><code>function const_get_name(cref, name)</code></h2>

<p>Get the constant in the scope of the current cref</p>

<pre class="code js"><code class="js">function const_get_name(cref, name) {
  if (cref) {
    if (cref.$$const[name] != null) { return cref.$$const[name]; }
    if (cref.$$autoload &amp;&amp; cref.$$autoload[name]) {
      return handle_autoload(cref, name);
    }
  }
}
</code></pre>

<h2 id="function-const_lookup_nesting-nesting-name"><code>function const_lookup_nesting(nesting, name)</code></h2>

<p>Walk up the nesting array looking for the constant</p>

<pre class="code js"><code class="js">function const_lookup_nesting(nesting, name) {
  var i, ii, constant;

  if (nesting.length === 0) return;

  // If the nesting is not empty the constant is looked up in its elements
  // and in order. The ancestors of those elements are ignored.
  for (i = 0, ii = nesting.length; i &lt; ii; i++) {
    constant = nesting[i].$$const[name];
    if (constant != null) {
      return constant;
    } else if (nesting[i].$$autoload &amp;&amp; nesting[i].$$autoload[name]) {
      return handle_autoload(nesting[i], name);
    }
  }
}
</code></pre>

<h2 id="function-const_lookup_ancestors-cref-name"><code>function const_lookup_ancestors(cref, name)</code></h2>

<p>Walk up the ancestors chain looking for the constant</p>

<pre class="code js"><code class="js">function const_lookup_ancestors(cref, name) {
  var i, ii, ancestors;

  if (cref == null) return;

  ancestors = $ancestors(cref);

  for (i = 0, ii = ancestors.length; i &lt; ii; i++) {
    if (ancestors[i].$$const &amp;&amp; $has_own(ancestors[i].$$const, name)) {
      return ancestors[i].$$const[name];
    } else if (ancestors[i].$$autoload &amp;&amp; ancestors[i].$$autoload[name]) {
      return handle_autoload(ancestors[i], name);
    }
  }
}
</code></pre>

<h2 id="function-const_lookup_object-cref-name"><code>function const_lookup_Object(cref, name)</code></h2>

<p>Walk up Object&#39;s ancestors chain looking for the constant,
but only if cref is missing or a module.</p>

<pre class="code js"><code class="js">function const_lookup_Object(cref, name) {
  if (cref == null || cref.$$is_module) {
    return const_lookup_ancestors(_Object, name);
  }
}
</code></pre>

<h2 id="function-const_missing-cref-name"><code>function const_missing(cref, name)</code></h2>

<p>Call const_missing if nothing else worked</p>

<pre class="code js"><code class="js">function const_missing(cref, name) {
  return (cref || _Object).$const_missing(name);
}
</code></pre>

<h2 id="opal-const_get_local-function-cref-name-skip_missing"><code>Opal.const_get_local = function(cref, name, skip_missing)</code></h2>

<p>Look for the constant just in the current cref or call <code>#const_missing</code></p>

<pre class="code js"><code class="js">Opal.const_get_local = function(cref, name, skip_missing) {
  var result;

  if (cref == null) return;

  if (cref === &#39;::&#39;) cref = _Object;

  if (!cref.$$is_module &amp;&amp; !cref.$$is_class) {
    $raise(Opal.TypeError, cref.toString() + &quot; is not a class/module&quot;);
  }

  result = const_get_name(cref, name);
  return result != null || skip_missing ? result : const_missing(cref, name);
};
</code></pre>

<h2 id="opal-const_get_qualified-function-cref-name-skip_missing"><code>Opal.const_get_qualified = function(cref, name, skip_missing)</code></h2>

<p>Look for the constant relative to a cref or call <code>#const_missing</code> (when the
constant is prefixed by <code>::</code>).</p>

<pre class="code js"><code class="js">Opal.const_get_qualified = function(cref, name, skip_missing) {
  var result, cache, cached, current_version = Opal.const_cache_version;

  if (name == null) {
    // A shortpath for calls like ::String =&gt; $$$(&quot;String&quot;)
    result = const_get_name(_Object, cref);

    if (result != null) return result;
    return Opal.const_get_qualified(_Object, cref, skip_missing);
  }

  if (cref == null) return;

  if (cref === &#39;::&#39;) cref = _Object;

  if (!cref.$$is_module &amp;&amp; !cref.$$is_class) {
    $raise(Opal.TypeError, cref.toString() + &quot; is not a class/module&quot;);
  }

  if ((cache = cref.$$const_cache) == null) {
    $prop(cref, &#39;$$const_cache&#39;, Object.create(null));
    cache = cref.$$const_cache;
  }
  cached = cache[name];

  if (cached == null || cached[0] !== current_version) {
    ((result = const_get_name(cref, name))              != null) ||
    ((result = const_lookup_ancestors(cref, name))      != null);
    cache[name] = [current_version, result];
  } else {
    result = cached[1];
  }

  return result != null || skip_missing ? result : const_missing(cref, name);
};
</code></pre>

<h2 id="opal-const_cache_version-1"><code>Opal.const_cache_version = 1</code></h2>

<p>Initialize the top level constant cache generation counter</p>

<pre class="code js"><code class="js">Opal.const_cache_version = 1;
</code></pre>

<h2 id="opal-const_get_relative-function-nesting-name-skip_missing"><code>Opal.const_get_relative = function(nesting, name, skip_missing)</code></h2>

<p>Look for the constant in the open using the current nesting and the nearest
cref ancestors or call <code>#const_missing</code> (when the constant has no :: prefix).</p>

<pre class="code js"><code class="js">Opal.const_get_relative = function(nesting, name, skip_missing) {
  var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

  if ((cache = nesting.$$const_cache) == null) {
    $prop(nesting, &#39;$$const_cache&#39;, Object.create(null));
    cache = nesting.$$const_cache;
  }
  cached = cache[name];

  if (cached == null || cached[0] !== current_version) {
    ((result = const_get_name(cref, name))              != null) ||
    ((result = const_lookup_nesting(nesting, name))     != null) ||
    ((result = const_lookup_ancestors(cref, name))      != null) ||
    ((result = const_lookup_Object(cref, name))         != null);

    cache[name] = [current_version, result];
  } else {
    result = cached[1];
  }

  return result != null || skip_missing ? result : const_missing(cref, name);
};
</code></pre>

<h2 id="function-const_set-cref-name-value"><code>function $const_set(cref, name, value)</code></h2>

<p>Register the constant on a cref and opportunistically set the name of
unnamed classes/modules.</p>

<pre class="code js"><code class="js">function $const_set(cref, name, value) {
  var new_const = true;

  if (cref == null || cref === &#39;::&#39;) cref = _Object;

  if (value.$$is_a_module) {
    if (value.$$name == null || value.$$name === nil) value.$$name = name;
    if (value.$$base_module == null) value.$$base_module = cref;
  }

  cref.$$const = (cref.$$const || Object.create(null));

  if (name in cref.$$const || (&quot;$$autoload&quot; in cref &amp;&amp; name in cref.$$autoload)) {
    new_const = false;
  }

  cref.$$const[name] = value;

  // Add a short helper to navigate constants manually.
  // @example
  //   Opal.$$.Regexp.$$.IGNORECASE
  cref.$$ = cref.$$const;

  Opal.const_cache_version++;

  // Expose top level constants onto the Opal object
  if (cref === _Object) Opal[name] = value;

  // Name new class directly onto current scope (Opal.Foo.Baz = klass)
  $prop(cref, name, value);

  if (new_const &amp;&amp; cref.$const_added &amp;&amp; !cref.$const_added.$$pristine) {
    cref.$const_added(name);
  }

  return value;
};
</code></pre>

<h2 id="opal-constants-function-cref-inherit"><code>Opal.constants = function(cref, inherit)</code></h2>

<p>Get all the constants reachable from a given cref, by default will include
inherited constants.</p>

<pre class="code js"><code class="js">Opal.constants = function(cref, inherit) {
  if (inherit == null) inherit = true;

  var module, modules = [cref], i, ii, constants = {}, constant;

  if (inherit) modules = modules.concat($ancestors(cref));
  if (inherit &amp;&amp; cref.$$is_module) modules = modules.concat([Opal.Object]).concat($ancestors(Opal.Object));

  for (i = 0, ii = modules.length; i &lt; ii; i++) {
    module = modules[i];

    // Do not show Objects constants unless we&#39;re querying Object itself
    if (cref !== _Object &amp;&amp; module == _Object) break;

    for (constant in module.$$const) {
      constants[constant] = true;
    }
    if (module.$$autoload) {
      for (constant in module.$$autoload) {
        constants[constant] = true;
      }
    }
  }

  return Object.keys(constants);
};
</code></pre>

<h2 id="opal-const_remove-function-cref-name"><code>Opal.const_remove = function(cref, name)</code></h2>

<p>Remove a constant from a cref.</p>

<pre class="code js"><code class="js">Opal.const_remove = function(cref, name) {
  Opal.const_cache_version++;

  if (cref.$$const[name] != null) {
    var old = cref.$$const[name];
    delete cref.$$const[name];
    return old;
  }

  if (cref.$$autoload &amp;&amp; cref.$$autoload[name]) {
    delete cref.$$autoload[name];
    return nil;
  }

  $raise(Opal.NameError, &quot;constant &quot;+cref+&quot;::&quot;+cref.$name()+&quot; not defined&quot;);
};
</code></pre>

<h2 id="opal-const_get_relative_factory-function-nesting"><code>Opal.const_get_relative_factory = function(nesting)</code></h2>

<p>Generates a function that is a curried const_get_relative.</p>

<pre class="code js"><code class="js">Opal.const_get_relative_factory = function(nesting) {
  return function(name, skip_missing) {
    return Opal.$$(nesting, name, skip_missing);
  }
}
</code></pre>

<h2 id="opal-opal-const_get_relative"><code>Opal.$$ = Opal.const_get_relative</code></h2>

<p>Setup some shortcuts to reduce compiled size</p>

<pre class="code js"><code class="js">Opal.$$ = Opal.const_get_relative;
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="modules-classes">Modules &amp; Classes</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="function-allocate_class-name-superclass-singleton"><code>function $allocate_class(name, superclass, singleton)</code></h2>

<p>A <code>class Foo; end</code> expression in ruby is compiled to call this runtime
method which either returns an existing class of the given name, or creates
a new class in the given <code>base</code> scope.</p>

<p>If a constant with the given name exists, then we check to make sure that
it is a class and also that the superclasses match. If either of these
fail, then we raise a <code>TypeError</code>. Note, <code>superclass</code> may be null if one
was not specified in the ruby code.</p>

<p>We pass a constructor to this method of the form <code>function ClassName() {}</code>
simply so that classes show up with nicely formatted names inside debuggers
in the web browser (or node/sprockets).</p>

<p>The <code>scope</code> is the current <code>self</code> value where the class is being created
from. We use this to get the scope for where the class should be created.
If <code>scope</code> is an object (not a class/module), we simple get its class and
use that as the scope instead.</p>

<p>@param scope        [Object] where the class is being created
@param superclass   [Class,null] superclass of the new class (may be null)
@param singleton    [Boolean,null] a true value denotes we want to allocate
                                   a singleton</p>

<p>@return new [Class]  or existing ruby class</p>

<pre class="code js"><code class="js">function $allocate_class(name, superclass, singleton) {
  var klass, bridged_descendant;

  if (bridged_descendant = descends_from_bridged_class(superclass)) {
    // Inheritance from bridged classes requires
    // calling original JS constructors
    klass = function() {
      var self = new ($bind.apply(bridged_descendant.$$constructor, $prepend(null, arguments)))();

      // and replacing a __proto__ manually
      $set_proto(self, klass.$$prototype);
      return self;
    }
  } else {
    klass = function(){};
  }

  if (name &amp;&amp; name !== nil) {
    $prop(klass, &#39;displayName&#39;, &#39;::&#39;+name);
  }

  $prop(klass, &#39;$$name&#39;, name);
  $prop(klass, &#39;$$constructor&#39;, klass);
  $prop(klass, &#39;$$prototype&#39;, klass.prototype);
  $prop(klass, &#39;$$const&#39;, {});
  $prop(klass, &#39;$$is_class&#39;, true);
  $prop(klass, &#39;$$is_a_module&#39;, true);
  $prop(klass, &#39;$$super&#39;, superclass);
  $prop(klass, &#39;$$cvars&#39;, {});
  $prop(klass, &#39;$$own_included_modules&#39;, []);
  $prop(klass, &#39;$$own_prepended_modules&#39;, []);
  $prop(klass, &#39;$$ancestors&#39;, []);
  $prop(klass, &#39;$$ancestors_cache_version&#39;, null);
  $prop(klass, &#39;$$subclasses&#39;, []);
  $prop(klass, &#39;$$cloned_from&#39;, []);

  $prop(klass.$$prototype, &#39;$$class&#39;, klass);

  // By default if there are no singleton class methods
  // __proto__ is Class.prototype
  // Later singleton methods generate a singleton_class
  // and inject it into ancestors chain
  if (Opal.Class) {
    $set_proto(klass, Opal.Class.prototype);
  }

  if (superclass != null) {
    $set_proto(klass.$$prototype, superclass.$$prototype);

    if (singleton !== true) {
      // Let&#39;s not forbid GC from cleaning up our
      // subclasses.
      if (typeof WeakRef !== &#39;undefined&#39;) {
        // First, let&#39;s clean up our array from empty objects.
        var i, subclass, rebuilt_subclasses = [];
        for (i = 0; i &lt; superclass.$$subclasses.length; i++) {
          subclass = superclass.$$subclasses[i];
          if (subclass.deref() !== undefined) {
            rebuilt_subclasses.push(subclass);
          }
        }
        // Now, let&#39;s add our class.
        rebuilt_subclasses.push(new WeakRef(klass));
        superclass.$$subclasses = rebuilt_subclasses;
      }
      else {
        superclass.$$subclasses.push(klass);
      }
    }

    if (superclass.$$meta) {
      // If superclass has metaclass then we have explicitely inherit it.
      Opal.build_class_singleton_class(klass);
    }
  }

  return klass;
};
</code></pre>

<h2 id="klass-const_get_name-scope-name"><code>klass = const_get_name(scope, name)</code></h2>

<p>Try to find the class in the current scope</p>

<pre class="code js"><code class="js">var klass = const_get_name(scope, name);
</code></pre>

<h2 id="if-klass"><code>if (klass)</code></h2>

<p>If the class exists in the scope, then we must use that</p>

<pre class="code js"><code class="js">if (klass) {
</code></pre>

<h2 id="if-klass-is_class"><code>if (!klass.$$is_class)</code></h2>

<p>Make sure the existing constant is a class, or raise error</p>

<pre class="code js"><code class="js">if (!klass.$$is_class) {
</code></pre>

<h2 id="scope-_object"><code>scope = _Object</code></h2>

<p>Global scope</p>

<pre class="code js"><code class="js">scope = _Object;
</code></pre>

<h2 id="scope-scope-class"><code>scope = scope.$$class</code></h2>

<p>Scope is an object, use its class</p>

<pre class="code js"><code class="js">scope = scope.$$class;
</code></pre>

<h2 id="if"><code>if (</code></h2>

<p>If the superclass is not an Opal-generated class then we&#39;re bridging a native JS class</p>

<pre class="code js"><code class="js">if (
</code></pre>

<h2 id="ensuresuperclassmatch-klass-superclass"><code>ensureSuperclassMatch(klass, superclass)</code></h2>

<p>Make sure existing class has same superclass</p>

<pre class="code js"><code class="js">ensureSuperclassMatch(klass, superclass);
</code></pre>

<h2 id="part-597705">``</h2>

<p>Class doesn&#39;t exist, create a new one with given superclass...</p>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="if-superclass-null"><code>if (superclass == null)</code></h2>

<p>Not specifying a superclass means we can assume it to be Object</p>

<pre class="code js"><code class="js">if (superclass == null) {
</code></pre>

<h2 id="klass-allocate_class-name-superclass"><code>klass = $allocate_class(name, superclass)</code></h2>

<p>Create the class object (instance of Class)</p>

<pre class="code js"><code class="js">klass = $allocate_class(name, superclass);
</code></pre>

<h2 id="if-superclass-inherited"><code>if (superclass.$inherited)</code></h2>

<p>Call .inherited() hook with new class on the superclass</p>

<pre class="code js"><code class="js">if (superclass.$inherited) {
</code></pre>

<h2 id="function-allocate_module-name"><code>function $allocate_module(name)</code></h2>

<p>Define new module (or return existing module). The given <code>scope</code> is basically
the current <code>self</code> value the <code>module</code> statement was defined in. If this is
a ruby module or class, then it is used, otherwise if the scope is a ruby
object then that objects real ruby class is used (e.g. if the scope is the
main object, then the top level <code>Object</code> class is used as the scope).</p>

<p>If a module of the given name is already defined in the scope, then that
instance is just returned.</p>

<p>If there is a class of the given name in the scope, then an error is
generated instead (cannot have a class and module of same name in same scope).</p>

<p>Otherwise, a new module is created in the scope with the given name, and that
new instance is returned back (to be referenced at runtime).</p>

<p>@param  scope [Module, Class] class or module this definition is inside
@param  id   [String] the name of the new (or existing) module</p>

<p>@return [Module]</p>

<pre class="code js"><code class="js">function $allocate_module(name) {
  var constructor = function(){};
  var module = constructor;

  if (name)
    $prop(constructor, &#39;displayName&#39;, name+&#39;.constructor&#39;);

  $prop(module, &#39;$$name&#39;, name);
  $prop(module, &#39;$$prototype&#39;, constructor.prototype);
  $prop(module, &#39;$$const&#39;, {});
  $prop(module, &#39;$$is_module&#39;, true);
  $prop(module, &#39;$$is_a_module&#39;, true);
  $prop(module, &#39;$$cvars&#39;, {});
  $prop(module, &#39;$$iclasses&#39;, []);
  $prop(module, &#39;$$own_included_modules&#39;, []);
  $prop(module, &#39;$$own_prepended_modules&#39;, []);
  $prop(module, &#39;$$ancestors&#39;, [module]);
  $prop(module, &#39;$$ancestors_cache_version&#39;, null);
  $prop(module, &#39;$$cloned_from&#39;, []);

  $set_proto(module, Opal.Module.prototype);

  return module;
};
</code></pre>

<h2 id="scope-_object"><code>scope = _Object</code></h2>

<p>Global scope</p>

<pre class="code js"><code class="js">scope = _Object;
</code></pre>

<h2 id="scope-scope-class"><code>scope = scope.$$class</code></h2>

<p>Scope is an object, use its class</p>

<pre class="code js"><code class="js">scope = scope.$$class;
</code></pre>

<h2 id="module-allocate_module-name"><code>module = $allocate_module(name)</code></h2>

<p>Module doesnt exist, create a new one...</p>

<pre class="code js"><code class="js">module = $allocate_module(name);
</code></pre>

<h2 id="opal-get_singleton_class-function-object"><code>Opal.get_singleton_class = function(object)</code></h2>

<p>Return the singleton class for the passed object.</p>

<p>If the given object alredy has a singleton class, then it will be stored on
the object as the <code>$$meta</code> property. If this exists, then it is simply
returned back.</p>

<p>Otherwise, a new singleton object for the class or object is created, set on
the object at <code>$$meta</code> for future use, and then returned.</p>

<p>@param object [Object] the ruby object
@return [Class] the singleton class for object</p>

<pre class="code js"><code class="js">Opal.get_singleton_class = function(object) {
  if (object.$$is_number) {
    $raise(Opal.TypeError, &quot;can&#39;t define singleton&quot;);
  }
  if (object.$$meta) {
    return object.$$meta;
  }

  if (object.hasOwnProperty(&#39;$$is_class&#39;)) {
    return Opal.build_class_singleton_class(object);
  } else if (object.hasOwnProperty(&#39;$$is_module&#39;)) {
    return Opal.build_module_singleton_class(object);
  } else {
    return Opal.build_object_singleton_class(object);
  }
};
</code></pre>

<h2 id="function-set_meta-obj-meta"><code>function set_meta(obj, meta)</code></h2>

<p>helper to set $$meta on klass, module or instance</p>

<pre class="code js"><code class="js">function set_meta(obj, meta) {
  if (obj.hasOwnProperty(&#39;$$meta&#39;)) {
    obj.$$meta = meta;
  } else {
    $prop(obj, &#39;$$meta&#39;, meta);
  }
  if (obj.$$frozen) {
    // If a object is frozen (sealed), freeze $$meta too.
    // No need to inject $$meta.$$prototype in the prototype chain,
    // as $$meta cannot be modified anyway.
    obj.$$meta.$freeze();
  } else {
    $set_proto(obj, meta.$$prototype);
  }
};
</code></pre>

<h2 id="opal-build_class_singleton_class-function-klass"><code>Opal.build_class_singleton_class = function(klass)</code></h2>

<p>Build the singleton class for an existing class. Class object are built
with their singleton class already in the prototype chain and inheriting
from their superclass object (up to <code>Class</code> itself).</p>

<p>NOTE: Actually in MRI a class&#39; singleton class inherits from its
superclass&#39; singleton class which in turn inherits from Class.</p>

<p>@param klass [Class]
@return [Class]</p>

<pre class="code js"><code class="js">Opal.build_class_singleton_class = function(klass) {
  if (klass.$$meta) {
    return klass.$$meta;
  }

  // The singleton_class superclass is the singleton_class of its superclass;
  // but BasicObject has no superclass (its `$$super` is null), thus we
  // fallback on `Class`.
  var superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

  var meta = $allocate_class(null, superclass, true);

  $prop(meta, &#39;$$is_singleton&#39;, true);
  $prop(meta, &#39;$$singleton_of&#39;, klass);
  set_meta(klass, meta);
  // Restoring ClassName.class
  $prop(klass, &#39;$$class&#39;, Opal.Class);

  return meta;
};
</code></pre>

<h2 id="prop-mod-class-opal-module"><code>$prop(mod, &#39;$$class&#39;, Opal.Module)</code></h2>

<p>Restoring ModuleName.class</p>

<pre class="code js"><code class="js">$prop(mod, &#39;$$class&#39;, Opal.Module);
</code></pre>

<h2 id="opal-build_object_singleton_class-function-object"><code>Opal.build_object_singleton_class = function(object)</code></h2>

<p>Build the singleton class for a Ruby (non class) Object.</p>

<p>@param object [Object]
@return [Class]</p>

<pre class="code js"><code class="js">Opal.build_object_singleton_class = function(object) {
  var superclass = object.$$class,
      klass = $allocate_class(nil, superclass, true);

  $prop(klass, &#39;$$is_singleton&#39;, true);
  $prop(klass, &#39;$$singleton_of&#39;, object);

  delete klass.$$prototype.$$class;

  set_meta(object, klass);

  return klass;
};
</code></pre>

<h2 id="opal-class_variables-function-module"><code>Opal.class_variables = function(module)</code></h2>

<p>Returns an object containing all pairs of names/values
for all class variables defined in provided +module+
and its ancestors.</p>

<p>@param module [Module]
@return [Object]</p>

<pre class="code js"><code class="js">Opal.class_variables = function(module) {
  var ancestors = $ancestors(module),
      i, length = ancestors.length,
      result = {};

  for (i = length - 1; i &gt;= 0; i--) {
    var ancestor = ancestors[i];

    for (var cvar in ancestor.$$cvars) {
      result[cvar] = ancestor.$$cvars[cvar];
    }
  }

  return result;
};
</code></pre>

<h2 id="opal-class_variable_set-function-module-name-value"><code>Opal.class_variable_set = function(module, name, value)</code></h2>

<p>Sets class variable with specified +name+ to +value+
in provided +module+</p>

<p>@param module [Module]
@param name [String]
@param value [Object]</p>

<pre class="code js"><code class="js">Opal.class_variable_set = function(module, name, value) {
  var ancestors = $ancestors(module),
      i, length = ancestors.length;

  for (i = length - 2; i &gt;= 0; i--) {
    var ancestor = ancestors[i];

    if ($has_own(ancestor.$$cvars, name)) {
      ancestor.$$cvars[name] = value;
      return value;
    }
  }

  module.$$cvars[name] = value;

  return value;
};
</code></pre>

<h2 id="opal-class_variable_get-function-module-name-tolerant"><code>Opal.class_variable_get = function(module, name, tolerant)</code></h2>

<p>Gets class variable with specified +name+ from provided +module+</p>

<p>@param module [Module]
@param name [String]</p>

<pre class="code js"><code class="js">Opal.class_variable_get = function(module, name, tolerant) {
  if ($has_own(module.$$cvars, name))
    return module.$$cvars[name];

  var ancestors = $ancestors(module),
    i, length = ancestors.length;

  for (i = 0; i &lt; length; i++) {
    var ancestor = ancestors[i];

    if ($has_own(ancestor.$$cvars, name)) {
      return ancestor.$$cvars[name];
    }
  }

  if (!tolerant)
    $raise(Opal.NameError, &#39;uninitialized class variable &#39;+name+&#39; in &#39;+module.$name());

  return nil;
}
</code></pre>

<h2 id="break"><code>break</code></h2>

<p>superclass</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2 id="opal-append_features-function-module-includer"><code>Opal.append_features = function(module, includer)</code></h2>

<p>The actual inclusion of a module into a class.</p>

<h2 id="class-parent-and-iclass">Class <code>$$parent</code> and <code>iclass</code></h2>

<p>To handle <code>super</code> calls, every class has a <code>$$parent</code>. This parent is
used to resolve the next class for a super call. A normal class would
have this point to its superclass. However, if a class includes a module
then this would need to take into account the module. The module would
also have to then point its <code>$$parent</code> to the actual superclass. We
cannot modify modules like this, because it might be included in more
then one class. To fix this, we actually insert an <code>iclass</code> as the class&#39;
<code>$$parent</code> which can then point to the superclass. The <code>iclass</code> acts as
a proxy to the actual module, so the <code>super</code> chain can then search it for
the required method.</p>

<p>@param module [Module] the module to include
@param includer [Module] the target class to include module into
@return [null]</p>

<pre class="code js"><code class="js">Opal.append_features = function(module, includer) {
  var module_ancestors = $ancestors(module);
  var iclasses = [];

  if (module_ancestors.indexOf(includer) !== -1) {
    $raise(Opal.ArgumentError, &#39;cyclic include detected&#39;);
  }

  for (var i = 0, length = module_ancestors.length; i &lt; length; i++) {
    var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
    $prop(iclass, &#39;$$included&#39;, true);
    iclasses.push(iclass);
  }
  var includer_ancestors = $ancestors(includer),
      chain = chain_iclasses(iclasses),
      start_chain_after,
      end_chain_on;

  if (includer_ancestors.indexOf(module) === -1) {
    // first time include

    // includer -&gt; chain.first -&gt; ...chain... -&gt; chain.last -&gt; includer.parent
    start_chain_after = includer.$$prototype;
    end_chain_on = Object.getPrototypeOf(includer.$$prototype);
  } else {
    // The module has been already included,
    // we don&#39;t need to put it into the ancestors chain again,
    // but this module may have new included modules.
    // If it&#39;s true we need to copy them.
    //
    // The simplest way is to replace ancestors chain from
    //          parent
    //            |
    //   `module` iclass (has a $$root flag)
    //            |
    //   ...previos chain of module.included_modules ...
    //            |
    //  &quot;next ancestor&quot; (has a $$root flag or is a real class)
    //
    // to
    //          parent
    //            |
    //    `module` iclass (has a $$root flag)
    //            |
    //   ...regenerated chain of module.included_modules
    //            |
    //   &quot;next ancestor&quot; (has a $$root flag or is a real class)
    //
    // because there are no intermediate classes between `parent` and `next ancestor`.
    // It doesn&#39;t break any prototypes of other objects as we don&#39;t change class references.

    var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

    while (module_iclass != null) {
      if (module_iclass.$$module === module &amp;&amp; isRoot(module_iclass)) {
        break;
      }

      parent = module_iclass;
      module_iclass = Object.getPrototypeOf(module_iclass);
    }

    if (module_iclass) {
      // module has been directly included
      var next_ancestor = Object.getPrototypeOf(module_iclass);

      // skip non-root iclasses (that were recursively included)
      while (next_ancestor.hasOwnProperty(&#39;$$iclass&#39;) &amp;&amp; !isRoot(next_ancestor)) {
        next_ancestor = Object.getPrototypeOf(next_ancestor);
      }

      start_chain_after = parent;
      end_chain_on = next_ancestor;
    } else {
      // module has not been directly included but was in ancestor chain because it was included by another module
      // include it directly
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    }
  }

  $set_proto(start_chain_after, chain.first);
  $set_proto(chain.last, end_chain_on);

  // recalculate own_included_modules cache
  includer.$$own_included_modules = own_included_modules(includer);

  Opal.const_cache_version++;
};
</code></pre>

<h2 id="module_ancestors-ancestors-module"><code>module_ancestors = $ancestors(module)</code></h2>

<p>Here we change the ancestors chain from</p>

<p>prepender
     |
   parent</p>

<p>to:</p>

<p>dummy(prepender)
     |
 iclass(module)
     |
iclass(prepender)
     |
   parent</p>

<pre class="code js"><code class="js">var module_ancestors = $ancestors(module);
</code></pre>

<h2 id="prepender_iclass-dummy_prepender-define_methods_on"><code>prepender_iclass = dummy_prepender.$$define_methods_on</code></h2>

<p>The module already has some prepended modules
which means that we don&#39;t need to make it &quot;dummy&quot;</p>

<pre class="code js"><code class="js">prepender_iclass = dummy_prepender.$$define_methods_on;
</code></pre>

<h2 id="prepender_iclass-create_dummy_iclass-prepender"><code>prepender_iclass = create_dummy_iclass(prepender)</code></h2>

<p>Making the module &quot;dummy&quot;</p>

<pre class="code js"><code class="js">prepender_iclass = create_dummy_iclass(prepender);
</code></pre>

<h2 id="set_proto-dummy_prepender-prepender_iclass"><code>$set_proto(dummy_prepender, prepender_iclass)</code></h2>

<p>Converting
  dummy(prepender) -&gt; previous_parent
to
  dummy(prepender) -&gt; iclass(prepender) -&gt; previous_parent</p>

<pre class="code js"><code class="js">$set_proto(dummy_prepender, prepender_iclass);
</code></pre>

<h2 id="part-597705">``</h2>

<p>first time prepend</p>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="end_chain_on-object-getprototypeof-dummy_prepender"><code>end_chain_on = Object.getPrototypeOf(dummy_prepender)</code></h2>

<p>next $$root or prepender_iclass or non-$$iclass</p>

<pre class="code js"><code class="js">end_chain_on = Object.getPrototypeOf(dummy_prepender);
</code></pre>

<h2 id="prepender-own_prepended_modules-own_prepended_modules-prepender"><code>prepender.$$own_prepended_modules = own_prepended_modules(prepender)</code></h2>

<p>recalculate own_prepended_modules cache</p>

<pre class="code js"><code class="js">prepender.$$own_prepended_modules = own_prepended_modules(prepender);
</code></pre>

<h2 id="function-create_dummy_iclass-module"><code>function create_dummy_iclass(module)</code></h2>

<p>Dummy iclass doesn&#39;t receive updates when the module gets a new method.</p>

<pre class="code js"><code class="js">function create_dummy_iclass(module) {
  var iclass = {},
      proto = module.$$prototype;

  if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
    proto = proto.$$define_methods_on;
  }

  var props = Object.getOwnPropertyNames(proto),
      length = props.length, i;

  for (i = 0; i &lt; length; i++) {
    var prop = props[i];
    $prop(iclass, prop, proto[prop]);
  }

  $prop(iclass, &#39;$$iclass&#39;, true);
  $prop(iclass, &#39;$$module&#39;, module);

  return iclass;
}
</code></pre>

<h2 id="opal-bridge-function-native_klass-klass"><code>Opal.bridge = function(native_klass, klass)</code></h2>

<p>For performance, some core Ruby classes are toll-free bridged to their
native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).</p>

<p>This method is used to setup a native constructor (e.g. Array), to have
its prototype act like a normal Ruby class. Firstly, a new Ruby class is
created using the native constructor so that its prototype is set as the
target for the new class. Note: all bridged classes are set to inherit
from Object.</p>

<p>Example:</p>

<p>Opal.bridge(self, Function);</p>

<p>@param klass       [Class] the Ruby class to bridge
@param constructor [JS.Function] native JavaScript constructor to use
@return [Class] returns the passed Ruby class</p>

<pre class="code js"><code class="js">Opal.bridge = function(native_klass, klass) {
  if (native_klass.hasOwnProperty(&#39;$$bridge&#39;)) {
    $raise(Opal.ArgumentError, &quot;already bridged&quot;);
  }

  // constructor is a JS function with a prototype chain like:
  // - constructor
  //   - super
  //
  // What we need to do is to inject our class (with its prototype chain)
  // between constructor and super. For example, after injecting ::Object
  // into JS String we get:
  //
  // - constructor (window.String)
  //   - Opal.Object
  //     - Opal.Kernel
  //       - Opal.BasicObject
  //         - super (window.Object)
  //           - null
  //
  $prop(native_klass, &#39;$$bridge&#39;, klass);
  $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
  $prop(klass, &#39;$$prototype&#39;, native_klass.prototype);

  $prop(klass.$$prototype, &#39;$$class&#39;, klass);
  $prop(klass, &#39;$$constructor&#39;, native_klass);
  $prop(klass, &#39;$$bridge&#39;, true);
};
</code></pre>

<h2 id="function-ancestors-module"><code>function $ancestors(module)</code></h2>

<p>The Array of ancestors for a given module/class</p>

<pre class="code js"><code class="js">function $ancestors(module) {
  if (!module) { return []; }

  if (module.$$ancestors_cache_version === Opal.const_cache_version) {
    return module.$$ancestors;
  }

  var result = [], i, mods, length;

  for (i = 0, mods = own_ancestors(module), length = mods.length; i &lt; length; i++) {
    result.push(mods[i]);
  }

  if (module.$$super) {
    for (i = 0, mods = $ancestors(module.$$super), length = mods.length; i &lt; length; i++) {
      result.push(mods[i]);
    }
  }

  module.$$ancestors_cache_version = Opal.const_cache_version;
  module.$$ancestors = result;

  return result;
};
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="method-missing">Method Missing</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="opal-add_stubs-function-stubs"><code>Opal.add_stubs = function(stubs)</code></h2>

<p>Methods stubs are used to facilitate method_missing in opal. A stub is a
placeholder function which just calls <code>method_missing</code> on the receiver.
If no method with the given name is actually defined on an object, then it
is obvious to say that the stub will be called instead, and then in turn
method_missing will be called.</p>

<p>When a file in ruby gets compiled to javascript, it includes a call to
this function which adds stubs for every method name in the compiled file.
It should then be safe to assume that method_missing will work for any
method call detected.</p>

<p>Method stubs are added to the BasicObject prototype, which every other
ruby object inherits, so all objects should handle method missing. A stub
is only added if the given property name (method name) is not already
defined.</p>

<p>Note: all ruby methods have a <code>$</code> prefix in javascript, so all stubs will
have this prefix as well (to make this method more performant).</p>

<p>Opal.add_stubs(&quot;foo,bar,baz=&quot;);</p>

<p>All stub functions will have a private <code>$$stub</code> property set to true so
that other internal methods can detect if a method is just a stub or not.
<code>Kernel#respond_to?</code> uses this property to detect a methods presence.</p>

<p>@param stubs [Array] an array of method stubs to add
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.add_stubs = function(stubs) {
  var proto = Opal.BasicObject.$$prototype;
  var stub, existing_method;
  stubs = stubs.split(&#39;,&#39;);

  for (var i = 0, length = stubs.length; i &lt; length; i++) {
    stub = $jsid(stubs[i]), existing_method = proto[stub];

    if (existing_method == null || existing_method.$$stub) {
      Opal.add_stub_for(proto, stub);
    }
  }
};
</code></pre>

<h2 id="opal-add_stub_for-function-prototype-stub"><code>Opal.add_stub_for = function(prototype, stub)</code></h2>

<p>Add a method_missing stub function to the given prototype for the
given name.</p>

<p>@param prototype [Prototype] the target prototype
@param stub [String] stub name to add (e.g. &quot;$foo&quot;)
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.add_stub_for = function(prototype, stub) {
  // Opal.stub_for(stub) is the method_missing_stub
  $prop(prototype, stub, Opal.stub_for(stub));
};
</code></pre>

<h2 id="opal-stub_for-function-method_name"><code>Opal.stub_for = function(method_name)</code></h2>

<p>Generate the method_missing stub for a given method name.</p>

<p>@param method_name [String] The js-name of the method to stub (e.g. &quot;$foo&quot;)
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.stub_for = function(method_name) {
  function method_missing_stub() {
    // Copy any given block onto the method_missing dispatcher
    this.$method_missing.$$p = method_missing_stub.$$p;

    // Set block property to null ready for the next call (stop false-positives)
    method_missing_stub.$$p = null;

    // call method missing with correct args (remove &#39;$&#39; prefix on method name)
    return this.$method_missing.apply(this, $prepend(method_name.slice(1), arguments));
  };

  method_missing_stub.$$stub = true;

  return method_missing_stub;
};
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="methods">Methods</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="opal-ac-function-actual-expected-object-meth"><code>Opal.ac = function(actual, expected, object, meth)</code></h2>

<p>Arity count error dispatcher for methods</p>

<p>@param actual [Fixnum] number of arguments given to method
@param expected [Fixnum] expected number of arguments
@param object [Object] owner of the method +meth+
@param meth [String] method name that got wrong number of arguments
@raise [ArgumentError]</p>

<pre class="code js"><code class="js">Opal.ac = function(actual, expected, object, meth) {
  var inspect = &#39;&#39;;
  if (object.$$is_a_module) {
    inspect += object.$$name + &#39;.&#39;;
  }
  else {
    inspect += object.$$class.$$name + &#39;#&#39;;
  }
  inspect += meth;

  $raise(Opal.ArgumentError, &#39;[&#39; + inspect + &#39;] wrong number of arguments (given &#39; + actual + &#39;, expected &#39; + expected + &#39;)&#39;);
};
</code></pre>

<h2 id="opal-block_ac-function-actual-expected-context"><code>Opal.block_ac = function(actual, expected, context)</code></h2>

<p>Arity count error dispatcher for blocks</p>

<p>@param actual [Fixnum] number of arguments given to block
@param expected [Fixnum] expected number of arguments
@param context [Object] context of the block definition
@raise [ArgumentError]</p>

<pre class="code js"><code class="js">Opal.block_ac = function(actual, expected, context) {
  var inspect = &quot;`block in &quot; + context + &quot;&#39;&quot;;

  $raise(Opal.ArgumentError, inspect + &#39;: wrong number of arguments (given &#39; + actual + &#39;, expected &#39; + expected + &#39;)&#39;);
};
</code></pre>

<h2 id="opal-find_super-function-obj-mid-current_func-defcheck-allow_stubs"><code>Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs)</code></h2>

<p>Super dispatcher</p>

<pre class="code js"><code class="js">Opal.find_super = function(obj, mid, current_func, defcheck, allow_stubs) {
  var jsid = $jsid(mid), ancestors, ancestor, super_method, method_owner, current_index = -1, i;

  ancestors = get_ancestors(obj);
  method_owner = current_func.$$owner;

  for (i = 0; i &lt; ancestors.length; i++) {
    ancestor = ancestors[i];
    if (ancestor === method_owner || ancestor.$$cloned_from.indexOf(method_owner) !== -1) {
      current_index = i;
      break;
    }
  }

  for (i = current_index + 1; i &lt; ancestors.length; i++) {
    ancestor = ancestors[i];
    var proto = ancestor.$$prototype;

    if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
      proto = proto.$$define_methods_on;
    }

    if (proto.hasOwnProperty(jsid)) {
      super_method = proto[jsid];
      break;
    }
  }

  if (!defcheck &amp;&amp; super_method &amp;&amp; super_method.$$stub &amp;&amp; obj.$method_missing.$$pristine) {
    // method_missing hasn&#39;t been explicitly defined
    $raise(Opal.NoMethodError, &#39;super: no superclass method `&#39;+mid+&quot;&#39; for &quot;+obj, mid);
  }

  return (super_method.$$stub &amp;&amp; !allow_stubs) ? null : super_method;
};
</code></pre>

<h2 id="opal-find_block_super-function-obj-jsid-current_func-defcheck-implicit"><code>Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit)</code></h2>

<p>Iter dispatcher for super in a block</p>

<pre class="code js"><code class="js">Opal.find_block_super = function(obj, jsid, current_func, defcheck, implicit) {
  var call_jsid = jsid;

  if (!current_func) {
    $raise(Opal.RuntimeError, &quot;super called outside of method&quot;);
  }

  if (implicit &amp;&amp; current_func.$$define_meth) {
    $raise(Opal.RuntimeError,
      &quot;implicit argument passing of super from method defined by define_method() is not supported. &quot; +
      &quot;Specify all arguments explicitly&quot;
    );
  }

  if (current_func.$$def) {
    call_jsid = current_func.$$jsid;
  }

  return Opal.find_super(obj, call_jsid, current_func, defcheck);
};
</code></pre>

<h2 id="opal-find_super_dispatcher-opal-find_super"><code>Opal.find_super_dispatcher = Opal.find_super</code></h2>

<p>@deprecated</p>

<pre class="code js"><code class="js">Opal.find_super_dispatcher = Opal.find_super;
</code></pre>

<h2 id="opal-find_iter_super_dispatcher-opal-find_block_super"><code>Opal.find_iter_super_dispatcher = Opal.find_block_super</code></h2>

<p>@deprecated</p>

<pre class="code js"><code class="js">Opal.find_iter_super_dispatcher = Opal.find_block_super;
</code></pre>

<h2 id="opal-yield1-function-block-arg"><code>Opal.yield1 = function(block, arg)</code></h2>

<p>handles yield calls for 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yield1 = function(block, arg) {
  if (typeof(block) !== &quot;function&quot;) {
    $raise(Opal.LocalJumpError, &quot;no block given&quot;);
  }

  var has_mlhs = block.$$has_top_level_mlhs_arg,
      has_trailing_comma = block.$$has_trailing_comma_in_args,
      is_returning_lambda = block.$$is_lambda &amp;&amp; block.$$ret;

  if (block.length &gt; 1 || ((has_mlhs || has_trailing_comma) &amp;&amp; block.length === 1)) {
    arg = Opal.to_ary(arg);
  }

  if ((block.length &gt; 1 || (has_trailing_comma &amp;&amp; block.length === 1)) &amp;&amp; arg.$$is_array) {
    if (is_returning_lambda) {
      return call_lambda(block.apply.bind(block, null), arg, block.$$ret);
    }
    return block.apply(null, arg);
  }
  else {
    if (is_returning_lambda) {
      return call_lambda(block, arg, block.$$ret);
    }
    return block(arg);
  }
};
</code></pre>

<h2 id="opal-yieldx-function-block-args"><code>Opal.yieldX = function(block, args)</code></h2>

<p>handles yield for &gt; 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yieldX = function(block, args) {
  if (typeof(block) !== &quot;function&quot;) {
    $raise(Opal.LocalJumpError, &quot;no block given&quot;);
  }

  if (block.length &gt; 1 &amp;&amp; args.length === 1) {
    if (args[0].$$is_array) {
      args = args[0];
    }
  }

  if (block.$$is_lambda &amp;&amp; block.$$ret) {
    return call_lambda(block.apply.bind(block, null), args, block.$$ret);
  }
  return block.apply(null, args);
};
</code></pre>

<h2 id="opal-rescue-function-exception-candidates"><code>Opal.rescue = function(exception, candidates)</code></h2>

<p>Finds the corresponding exception match in candidates.  Each candidate can
be a value, or an array of values.  Returns null if not found.</p>

<pre class="code js"><code class="js">Opal.rescue = function(exception, candidates) {
  for (var i = 0; i &lt; candidates.length; i++) {
    var candidate = candidates[i];

    if (candidate.$$is_array) {
      var result = Opal.rescue(exception, candidate);

      if (result) {
        return result;
      }
    }
    else if (candidate === Opal.JS.Error || candidate[&#39;$===&#39;](exception)) {
      return candidate;
    }
  }

  return null;
};
</code></pre>

<h2 id="opal-to_hash-function-value"><code>Opal.to_hash = function(value)</code></h2>

<p>Helpers for extracting kwsplats
Used for: { **h }</p>

<pre class="code js"><code class="js">Opal.to_hash = function(value) {
  if (value.$$is_hash) {
    return value;
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_hash&#39;, true)) {
    var hash = value.$to_hash();
    if (hash.$$is_hash) {
      return hash;
    }
    else {
      $raise(Opal.TypeError, &quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Hash (&quot; + value.$$class + &quot;#to_hash gives &quot; + hash.$$class + &quot;)&quot;);
    }
  }
  else {
    $raise(Opal.TypeError, &quot;no implicit conversion of &quot; + value.$$class + &quot; into Hash&quot;);
  }
};
</code></pre>

<h2 id="part-597705">``</h2>

<p>Helpers for implementing multiple assignment
Our code for extracting the values and assigning them only works if the
return value is a JS array.
So if we get an Array subclass, extract the wrapped JS array from it</p>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="opal-to_ary-function-value"><code>Opal.to_ary = function(value)</code></h2>

<p>Used for: a, b = something (no splat)</p>

<pre class="code js"><code class="js">Opal.to_ary = function(value) {
  if (value.$$is_array) {
    return value;
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_ary&#39;, true)) {
    var ary = value.$to_ary();
    if (ary === nil) {
      return [value];
    }
    else if (ary.$$is_array) {
      return ary;
    }
    else {
      $raise(Opal.TypeError, &quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Array (&quot; + value.$$class + &quot;#to_ary gives &quot; + ary.$$class + &quot;)&quot;);
    }
  }
  else {
    return [value];
  }
};
</code></pre>

<h2 id="opal-to_a-function-value"><code>Opal.to_a = function(value)</code></h2>

<p>Used for: a, b = *something (with splat)</p>

<pre class="code js"><code class="js">Opal.to_a = function(value) {
  if (value.$$is_array) {
    // A splatted array must be copied
    return value.slice();
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_a&#39;, true)) {
    var ary = value.$to_a();
    if (ary === nil) {
      return [value];
    }
    else if (ary.$$is_array) {
      return ary;
    }
    else {
      $raise(Opal.TypeError, &quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Array (&quot; + value.$$class + &quot;#to_a gives &quot; + ary.$$class + &quot;)&quot;);
    }
  }
  else {
    return [value];
  }
};
</code></pre>

<h2 id="opal-extract_kwargs-function-parameters"><code>Opal.extract_kwargs = function(parameters)</code></h2>

<p>Used for extracting keyword arguments from arguments passed to
JS function.</p>

<p>@param parameters [Array]
@return [Hash] or undefined</p>

<pre class="code js"><code class="js">Opal.extract_kwargs = function(parameters) {
  var kwargs = parameters[parameters.length - 1];
  if (kwargs != null &amp;&amp; Opal.respond_to(kwargs, &#39;$to_hash&#39;, true)) {
    $splice(parameters, parameters.length - 1);
    return kwargs;
  }
};
</code></pre>

<h2 id="opal-kwrestargs-function-given_args-used_args"><code>Opal.kwrestargs = function(given_args, used_args)</code></h2>

<p>Used to get a list of rest keyword arguments. Method takes the given
keyword args, i.e. the hash literal passed to the method containing all
keyword arguments passed to method, as well as the used args which are
the names of required and optional arguments defined. This method then
just returns all key/value pairs which have not been used, in a new
hash literal.</p>

<p>@param given_args [Hash] all kwargs given to method
@param used_args [Object<String: true>] all keys used as named kwargs
@return [Hash]</p>

<pre class="code js"><code class="js">Opal.kwrestargs = function(given_args, used_args) {
  var map = new Map();

  Opal.hash_each(given_args, false, function(key, value) {
    if (!used_args[key]) {
      Opal.hash_put(map, key, value);
    }
    return [false, false];
  });

  return map;
};
</code></pre>

<h2 id="jsid_cache-new-map"><code>jsid_cache = new Map()</code></h2>

<p>Optimization for a costly operation of prepending &#39;$&#39; to method names</p>

<pre class="code js"><code class="js">var jsid_cache = new Map();
</code></pre>

<h2 id="opal-send-function-recv-method-args-block-blockopts"><code>Opal.send = function(recv, method, args, block, blockopts)</code></h2>

<p>Calls passed method on a ruby object with arguments and block:</p>

<p>Can take a method or a method name.</p>

<ol>
<li>When method name gets passed it invokes it by its name
and calls &#39;method_missing&#39; when object doesn&#39;t have this method.
Used internally by Opal to invoke method that takes a block or a splat.</li>
<li>When method (i.e. method body) gets passed, it doesn&#39;t trigger &#39;method_missing&#39;
because it doesn&#39;t know the name of the actual method.
Used internally by Opal to invoke &#39;super&#39;.</li>
</ol>

<p>@example
  var my_array = [1, 2, 3, 4]
  Opal.send(my_array, &#39;length&#39;)                    # =&gt; 4
  Opal.send(my_array, my_array.$length)            # =&gt; 4</p>

<p>Opal.send(my_array, &#39;reverse!&#39;)                  # =&gt; [4, 3, 2, 1]
  Opal.send(my_array, my_array[&#39;$reverse!&#39;]&#39;)      # =&gt; [4, 3, 2, 1]</p>

<p>@param recv [Object] ruby object
@param method [Function, String] method body or name of the method
@param args [Array] arguments that will be passed to the method call
@param block [Function] ruby block
@param blockopts [Object, Number] optional properties to set on the block
@return [Object] returning value of the method call</p>

<pre class="code js"><code class="js">Opal.send = function(recv, method, args, block, blockopts) {
  var body;

  if (typeof(method) === &#39;function&#39;) {
    body = method;
    method = null;
  } else if (typeof(method) === &#39;string&#39;) {
    body = recv[$jsid(method)];
  } else {
    $raise(Opal.NameError, &quot;Passed method should be a string or a function&quot;);
  }

  return Opal.send2(recv, body, method, args, block, blockopts);
};
</code></pre>

<h2 id="for-i-0-i-ancestors-length-i"><code>for (i = 0; i &lt; ancestors.length; i++)</code></h2>

<p>For all ancestors that there are, starting from the closest to the furthest...</p>

<pre class="code js"><code class="js">for (i = 0; i &lt; ancestors.length; i++) {
</code></pre>

<h2 id="for-j-0-j-refinement_groups-length-j"><code>for (j = 0; j &lt; refinement_groups.length; j++)</code></h2>

<p>For all refinement groups there are, starting from the closest scope to the furthest...</p>

<pre class="code js"><code class="js">for (j = 0; j &lt; refinement_groups.length; j++) {
</code></pre>

<h2 id="for-k-refinements-length-1-k-0-k"><code>for (k = refinements.length - 1; k &gt;= 0; k--)</code></h2>

<p>For all refinements there are, starting from the last <code>using</code> call to the furthest...</p>

<pre class="code js"><code class="js">for (k = refinements.length - 1; k &gt;= 0; k--) {
</code></pre>

<h2 id="refine_modules-refinement-refine_modules"><code>refine_modules = refinement.$$refine_modules</code></h2>

<p>A single module being given as an argument of the <code>using</code> call contains multiple
refinement modules</p>

<pre class="code js"><code class="js">refine_modules = refinement.$$refine_modules;
</code></pre>

<h2 id="if-typeof-refine_modules-ancestor-undefined-continue"><code>if (typeof refine_modules[ancestor] === &#39;undefined&#39;) continue</code></h2>

<p>Does this module refine a given call for a given ancestor module?</p>

<pre class="code js"><code class="js">if (typeof refine_modules[ancestor] === &#39;undefined&#39;) continue;
</code></pre>

<h2 id="if-typeof-refine_module-prototype-jsid-method-undefined"><code>if (typeof refine_module.$$prototype[$jsid(method)] !== &#39;undefined&#39;)</code></h2>

<p>Does this module define a method we want to call?</p>

<pre class="code js"><code class="js">if (typeof refine_module.$$prototype[$jsid(method)] !== &#39;undefined&#39;) {
</code></pre>

<h2 id="opal-def-function-obj-jsid-body-blockopts"><code>Opal.def = function(obj, jsid, body, blockopts)</code></h2>

<p>Used to define methods on an object. This is a helper method, used by the
compiled source to define methods on special case objects when the compiler
can not determine the destination object, or the object is a Module
instance. This can get called by <code>Module#define_method</code> as well.</p>

<h2 id="modules">Modules</h2>

<p>Any method defined on a module will come through this runtime helper.
The method is added to the module body, and the owner of the method is
set to be the module itself. This is used later when choosing which
method should show on a class if more than 1 included modules define
the same method. Finally, if the module is in <code>module_function</code> mode,
then the method is also defined onto the module itself.</p>

<h2 id="classes">Classes</h2>

<p>This helper will only be called for classes when a method is being
defined indirectly; either through <code>Module#define_method</code>, or by a
literal <code>def</code> method inside an <code>instance_eval</code> or <code>class_eval</code> body. In
either case, the method is simply added to the class&#39; prototype. A special
exception exists for <code>BasicObject</code> and <code>Object</code>. These two classes are
special because they are used in toll-free bridged classes. In each of
these two cases, extra work is required to define the methods on toll-free
bridged class&#39; prototypes as well.</p>

<h2 id="objects">Objects</h2>

<p>If a simple ruby object is the object, then the method is simply just
defined on the object as a singleton method. This would be the case when
a method is defined inside an <code>instance_eval</code> block.</p>

<p>@param obj  [Object, Class] the actual obj to define method for
@param jsid [String] the JavaScript friendly method name (e.g. &#39;$foo&#39;)
@param body [JS.Function] the literal JavaScript function used as method
@param blockopts [Object, Number] optional properties to set on the body
@return [null]</p>

<pre class="code js"><code class="js">Opal.def = function(obj, jsid, body, blockopts) {
  apply_blockopts(body, blockopts);

  // Special case for a method definition in the
  // top-level namespace
  if (obj === Opal.top) {
    return Opal.defn(Opal.Object, jsid, body);
  }
  // if instance_eval is invoked on a module/class, it sets inst_eval_mod
  else if (!obj.$$eval &amp;&amp; obj.$$is_a_module) {
    return Opal.defn(obj, jsid, body);
  }
  else {
    return Opal.defs(obj, jsid, body);
  }
};
</code></pre>

<h2 id="opal-defn-function-module-jsid-body"><code>Opal.defn = function(module, jsid, body)</code></h2>

<p>Define method on a module or class (see Opal.def).</p>

<pre class="code js"><code class="js">Opal.defn = function(module, jsid, body) {
  $deny_frozen_access(module);

  body.displayName = jsid;
  body.$$owner = module;

  var name = jsid.substr(1);

  var proto = module.$$prototype;
  if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
    proto = proto.$$define_methods_on;
  }
  $prop(proto, jsid, body);

  if (module.$$is_module) {
    if (module.$$module_function) {
      Opal.defs(module, jsid, body)
    }

    for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i &lt; length; i++) {
      var iclass = iclasses[i];
      $prop(iclass, jsid, body);
    }
  }

  var singleton_of = module.$$singleton_of;
  if (module.$method_added &amp;&amp; !module.$method_added.$$stub &amp;&amp; !singleton_of) {
    module.$method_added(name);
  }
  else if (singleton_of &amp;&amp; singleton_of.$singleton_method_added &amp;&amp; !singleton_of.$singleton_method_added.$$stub) {
    singleton_of.$singleton_method_added(name);
  }

  return name;
};
</code></pre>

<h2 id="opal-defs-function-obj-jsid-body-blockopts"><code>Opal.defs = function(obj, jsid, body, blockopts)</code></h2>

<p>Define a singleton method on the given object (see Opal.def).</p>

<pre class="code js"><code class="js">Opal.defs = function(obj, jsid, body, blockopts) {
  apply_blockopts(body, blockopts);

  if (obj.$$is_string || obj.$$is_number) {
    $raise(Opal.TypeError, &quot;can&#39;t define singleton&quot;);
  }
  return Opal.defn(Opal.get_singleton_class(obj), jsid, body);
};
</code></pre>

<h2 id="function-remove_method_from_iclasses-obj-jsid"><code>function remove_method_from_iclasses(obj, jsid)</code></h2>

<p>Since JavaScript has no concept of modules, we create proxy classes
called <code>iclasses</code> that store copies of methods loaded. We need to
update them if we remove a method.</p>

<pre class="code js"><code class="js">function remove_method_from_iclasses(obj, jsid) {
  if (obj.$$is_module) {
    for (var i = 0, iclasses = obj.$$iclasses, length = iclasses.length; i &lt; length; i++) {
      var iclass = iclasses[i];
      delete iclass[jsid];
    }
  }
}
</code></pre>

<h2 id="opal-rdef-function-obj-jsid"><code>Opal.rdef = function(obj, jsid)</code></h2>

<p>Called from #remove_method.</p>

<pre class="code js"><code class="js">Opal.rdef = function(obj, jsid) {
  if (!$has_own(obj.$$prototype, jsid)) {
    $raise(Opal.NameError, &quot;method &#39;&quot; + jsid.substr(1) + &quot;&#39; not defined in &quot; + obj.$name());
  }

  delete obj.$$prototype[jsid];

  remove_method_from_iclasses(obj, jsid);

  if (obj.$$is_singleton) {
    if (obj.$$prototype.$singleton_method_removed &amp;&amp; !obj.$$prototype.$singleton_method_removed.$$stub) {
      obj.$$prototype.$singleton_method_removed(jsid.substr(1));
    }
  }
  else {
    if (obj.$method_removed &amp;&amp; !obj.$method_removed.$$stub) {
      obj.$method_removed(jsid.substr(1));
    }
  }
};
</code></pre>

<h2 id="opal-udef-function-obj-jsid"><code>Opal.udef = function(obj, jsid)</code></h2>

<p>Called from #undef_method.</p>

<pre class="code js"><code class="js">Opal.udef = function(obj, jsid) {
  if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
    $raise(Opal.NameError, &quot;method &#39;&quot; + jsid.substr(1) + &quot;&#39; not defined in &quot; + obj.$name());
  }

  Opal.add_stub_for(obj.$$prototype, jsid);

  remove_method_from_iclasses(obj, jsid);

  if (obj.$$is_singleton) {
    if (obj.$$prototype.$singleton_method_undefined &amp;&amp; !obj.$$prototype.$singleton_method_undefined.$$stub) {
      obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
    }
  }
  else {
    if (obj.$method_undefined &amp;&amp; !obj.$method_undefined.$$stub) {
      obj.$method_undefined(jsid.substr(1));
    }
  }
};
</code></pre>

<h2 id="if-typeof-obj-prototype-undefined"><code>if (typeof obj.$$prototype === &#39;undefined&#39;)</code></h2>

<p>Aliasing on main means aliasing on Object...</p>

<pre class="code js"><code class="js">if (typeof obj.$$prototype === &#39;undefined&#39;) {
</code></pre>

<h2 id="if-obj-eval"><code>if (obj.$$eval)</code></h2>

<p>When running inside #instance_eval the alias refers to class methods.</p>

<pre class="code js"><code class="js">if (obj.$$eval) {
</code></pre>

<h2 id="body-opal-object-prototype-old_id"><code>body = Opal.Object.$$prototype[old_id]</code></h2>

<p>try to look into Object</p>

<pre class="code js"><code class="js">body = Opal.Object.$$prototype[old_id]
</code></pre>

<h2 id="if-body-alias_of-body-body-alias_of"><code>if (body.$$alias_of) body = body.$$alias_of</code></h2>

<p>If the body is itself an alias use the original body
to keep the max depth at 1.</p>

<pre class="code js"><code class="js">if (body.$$alias_of) body = body.$$alias_of;
</code></pre>

<h2 id="alias-opal-wrap_method_body-body"><code>alias = Opal.wrap_method_body(body)</code></h2>

<p>We need a wrapper because otherwise properties
would be overwritten on the original body.</p>

<pre class="code js"><code class="js">alias = Opal.wrap_method_body(body);
</code></pre>

<h2 id="alias-displayname-name"><code>alias.displayName  = name</code></h2>

<p>Try to make the browser pick the right name</p>

<pre class="code js"><code class="js">alias.displayName  = name;
</code></pre>

<h2 id="try"><code>try</code></h2>

<p>Assign the &#39;length&#39; value with defineProperty because
in strict mode the property is not writable.
It doesn&#39;t work in older browsers (like Chrome 38), where
an exception is thrown breaking Opal altogether.</p>

<pre class="code js"><code class="js">try {
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="hashes">Hashes</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="objects-splice-objects-indexof-object-1"><code>objects.splice(objects.indexOf(object), 1)</code></h2>

<p>got a duplicate, remove it</p>

<pre class="code js"><code class="js">objects.splice(objects.indexOf(object), 1);
</code></pre>

<h2 id="opal-hash2-function-keys-smap"><code>Opal.hash2 = function(keys, smap)</code></h2>

<p>A faster Hash creator for hashes that just use symbols and
strings as keys. The map and keys array can be constructed at
compile time, so they are just added here by the constructor
function.</p>

<pre class="code js"><code class="js">Opal.hash2 = function(keys, smap) {
  console.warn(&quot;DEPRECATION: `Opal.hash2` is deprecated and will be removed in Opal 2.0. Use `new Map()` with an array of key/value pairs instead.&quot;);

  var hash = new Map();
  for (var i = 0, max = keys.length; i &lt; max; i++) {
    hash.set(keys[i], smap[keys[i]]);
  }
  return hash;
};
</code></pre>

<h2 id="res"><code>res</code></h2>

<p>dres = default result, returned if hash is empty
fun is called as fun(key, value) and must return a array with [break, result]
if break is true, iteration stops and result is returned
if break is false, iteration continues and eventually the last result is returned</p>

<pre class="code js"><code class="js">var res;
</code></pre>

<h2 id="opal-range-function-first-last-exc"><code>Opal.range = function(first, last, exc)</code></h2>

<p>Create a new range instance with first and last values, and whether the
range excludes the last value.</p>

<pre class="code js"><code class="js">Opal.range = function(first, last, exc) {
  var range         = new Opal.Range();
      range.begin   = first;
      range.end     = last;
      range.excl    = exc;

  return range;
};
</code></pre>

<h2 id="constructor-displayname-__count__-__nosuchmethod__"><code>&quot;constructor&quot;, &quot;displayName&quot;, &quot;__count__&quot;, &quot;__noSuchMethod__&quot;,</code></h2>

<p>properties</p>

<pre class="code js"><code class="js">&quot;constructor&quot;, &quot;displayName&quot;, &quot;__count__&quot;, &quot;__noSuchMethod__&quot;,
</code></pre>

<h2 id="hasownproperty-valueof"><code>&quot;hasOwnProperty&quot;, &quot;valueOf&quot;</code></h2>

<p>methods</p>

<pre class="code js"><code class="js">&quot;hasOwnProperty&quot;, &quot;valueOf&quot;
</code></pre>

<h2 id="opal-ivar-function-name"><code>Opal.ivar = function(name)</code></h2>

<p>Get the ivar name for a given name.
Mostly adds a trailing $ to reserved names.</p>

<pre class="code js"><code class="js">Opal.ivar = function(name) {
  if (reserved_ivar_names.indexOf(name) !== -1) {
    name += &quot;$&quot;;
  }

  return name;
};
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="support-for-freeze">Support for #freeze</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="function-deny_frozen_access-obj"><code>function $deny_frozen_access(obj)</code></h2>

<p>helper that can be used from methods</p>

<pre class="code js"><code class="js">function $deny_frozen_access(obj) {
  if (obj.$$frozen) {
    $raise(Opal.FrozenError, &quot;can&#39;t modify frozen &quot; + (obj.$class()) + &quot;: &quot; + (obj), new Map([[&quot;receiver&quot;, obj]]));
  }
};
</code></pre>

<h2 id="opal-freeze-function-obj"><code>Opal.freeze = function(obj)</code></h2>

<p>common #freeze runtime support</p>

<pre class="code js"><code class="js">Opal.freeze = function(obj) {
  $prop(obj, &quot;$$frozen&quot;, true);

  // set $$id
  if (!obj.hasOwnProperty(&#39;$$id&#39;)) { $prop(obj, &#39;$$id&#39;, $uid()); }

  if (obj.hasOwnProperty(&#39;$$meta&#39;)) {
    // freeze $$meta if it has already been set
    obj.$$meta.$freeze();
  } else {
    // ensure $$meta can be set lazily, $$meta is frozen when set in runtime.js
    $prop(obj, &#39;$$meta&#39;, null);
  }

  // $$comparable is used internally and set multiple times
  // defining it before sealing ensures it can be modified later on
  if (!obj.hasOwnProperty(&#39;$$comparable&#39;)) { $prop(obj, &#39;$$comparable&#39;, null); }

  // seal the Object
  Object.seal(obj);

  return obj;
};
</code></pre>

<h2 id="function-each_ivar-obj-func"><code>function $each_ivar(obj, func)</code></h2>

<p>Iterate over every instance variable and call func for each one
giving name of the ivar and optionally the property descriptor.</p>

<pre class="code js"><code class="js">function $each_ivar(obj, func) {
  var own_props = Object.getOwnPropertyNames(obj), own_props_length = own_props.length, i, prop, desc;

  for(i = 0; i &lt; own_props_length; i++) {
    prop = own_props[i];

    if (prop[0] === &#39;$&#39;) continue;

    desc = Object.getOwnPropertyDescriptor(obj, prop);

    if (desc &amp;&amp; desc.enumerable) {
      func(prop, desc);
    }
  }
}
</code></pre>

<h2 id="opal-freeze_props-function-obj"><code>Opal.freeze_props = function(obj)</code></h2>

<p>freze props, make setters of instance variables throw FrozenError</p>

<pre class="code js"><code class="js">Opal.freeze_props = function(obj) {
  var dp_template = {
    get: null,
    set: function(_val) { $deny_frozen_access(obj); },
    enumerable: true
  };

  $each_ivar(obj, function(prop, desc) {
    if (!desc.writable) return;

    // Redefine a property with a setter that raises an error.
    dp_template.get = $return_val(desc.value);

    Object.defineProperty(obj, prop, dp_template);
  });
};
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="regexps">Regexps</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="opal-escape_regexp-function-str"><code>Opal.escape_regexp = function(str)</code></h2>

<p>Escape Regexp special chars letting the resulting string be used to build
a new Regexp.</p>

<pre class="code js"><code class="js">Opal.escape_regexp = function(str) {
  return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, &#39;\\$1&#39;)
            .replace(/[\n]/g, &#39;\\n&#39;)
            .replace(/[\r]/g, &#39;\\r&#39;)
            .replace(/[\f]/g, &#39;\\f&#39;)
            .replace(/[\t]/g, &#39;\\t&#39;);
};
</code></pre>

<h2 id="opal-global_regexp-function-pattern"><code>Opal.global_regexp = function(pattern)</code></h2>

<p>Create a global Regexp from a RegExp object and cache the result
on the object itself ($$g attribute).</p>

<pre class="code js"><code class="js">Opal.global_regexp = function(pattern) {
  if (pattern.global) {
    return pattern; // RegExp already has the global flag
  }
  if (pattern.$$g == null) {
    pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? &#39;gm&#39; : &#39;g&#39;) + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
  } else {
    pattern.$$g.lastIndex = null; // reset lastIndex property
  }
  return pattern.$$g;
};
</code></pre>

<h2 id="opal-global_multiline_regexp-function-pattern"><code>Opal.global_multiline_regexp = function(pattern)</code></h2>

<p>Create a global multiline Regexp from a RegExp object and cache the result
on the object itself ($$gm or $$g attribute).</p>

<pre class="code js"><code class="js">Opal.global_multiline_regexp = function(pattern) {
  var result, flags;

  // RegExp already has the global and multiline flag
  if (pattern.global &amp;&amp; pattern.multiline) return pattern;

  flags = &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;);
  if (pattern.multiline) {
    // we are using the $$g attribute because the Regexp is already multiline
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, flags);
    }
    result = pattern.$$g;
  } else {
    if (pattern.$$gm == null) {
      pattern.$$gm = new RegExp(pattern.source, flags);
    }
    result = pattern.$$gm;
  }
  result.lastIndex = null; // reset lastIndex property
  return result;
};
</code></pre>

<h2 id="opal-regexp-function-parts-flags"><code>Opal.regexp = function(parts, flags)</code></h2>

<p>Combine multiple regexp parts together</p>

<pre class="code js"><code class="js">Opal.regexp = function(parts, flags) {
  var part;
  var ignoreCase = typeof flags !== &#39;undefined&#39; &amp;&amp; flags &amp;&amp; flags.indexOf(&#39;i&#39;) &gt;= 0;

  for (var i = 0, ii = parts.length; i &lt; ii; i++) {
    part = parts[i];
    if (part instanceof RegExp) {
      if (part.ignoreCase !== ignoreCase)
        Opal.Kernel.$warn(
          &quot;ignore case doesn&#39;t match for &quot; + part.source.$inspect(),
          new Map([[&#39;uplevel&#39;,  1]])
        )

      part = part.source;
    }
    if (part === &#39;&#39;) part = &#39;(?:&#39; + part + &#39;)&#39;;
    parts[i] = part;
  }

  if (flags) {
    return new RegExp(parts.join(&#39;&#39;), flags);
  } else {
    return new RegExp(parts.join(&#39;&#39;));
  }
};
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="require-system">Require system</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="return-retval-then-return_val-true"><code>return retval.then($return_val(true))</code></h2>

<p>A special case of require having an async top:
We will need to await it.</p>

<pre class="code js"><code class="js">return retval.then($return_val(true));
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="strings">Strings</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="opal-set_encoding-function-str-name-type"><code>Opal.set_encoding = function(str, name, type)</code></h2>

<p>Sets the encoding on a string, will treat string literals as frozen strings
raising a FrozenError.</p>

<p>@param str [String] the string on which the encoding should be set
@param name [String] the canonical name of the encoding
@param type [String] possible values are either <code>&quot;encoding&quot;</code>, <code>&quot;internal_encoding&quot;</code>, or `undefined</p>

<pre class="code js"><code class="js">Opal.set_encoding = function(str, name, type) {
  if (typeof type === &quot;undefined&quot;) type = &quot;encoding&quot;;
  if (typeof str === &#39;string&#39; || str.$$frozen === true)
    $raise(Opal.FrozenError, &quot;can&#39;t modify frozen String&quot;);

  var encoding = Opal.find_encoding(name);

  if (encoding === str[type]) { return str; }

  str[type] = encoding;

  return str;
};
</code></pre>

<h2 id="opal-find_encoding-function-name"><code>Opal.find_encoding = function(name)</code></h2>

<p>Fetches the encoding for the given name or raises ArgumentError.</p>

<pre class="code js"><code class="js">Opal.find_encoding = function(name) {
  var register = Opal.encodings;
  var encoding = register[name] || register[name.toUpperCase()];
  if (!encoding) $raise(Opal.ArgumentError, &quot;unknown encoding name - &quot; + name);
  return encoding;
}
</code></pre>

<h2 id="opal-enc-function-str-name"><code>Opal.enc = function(str, name)</code></h2>

<p>@returns a String object with the encoding set from a string literal</p>

<pre class="code js"><code class="js">Opal.enc = function(str, name) {
  var dup = new String(str);
  dup = Opal.set_encoding(dup, name);
  dup.internal_encoding = dup.encoding;
  return dup
}
</code></pre>

<h2 id="opal-binary-function-str"><code>Opal.binary = function(str)</code></h2>

<p>@returns a String object with the internal encoding set to Binary</p>

<pre class="code js"><code class="js">Opal.binary = function(str) {
  var dup = new String(str);
  return Opal.set_encoding(dup, &quot;binary&quot;, &quot;internal_encoding&quot;);
}
</code></pre>

<h2 id="opal-queue-function-proc"><code>Opal.queue = function(proc)</code></h2>

<p>Run a block of code, but if it returns a Promise, don&#39;t run the next
one, but queue it.</p>

<pre class="code js"><code class="js">Opal.queue = function(proc) {
  if (Opal.last_promise) {
    // The async path is taken only if anything before returned a
    // Promise(V2).
    Opal.last_promise = Opal.last_promise.then(function() {
      if (!Opal.promise_unhandled_exception) return proc(Opal);
    })[&#39;catch&#39;](function(error) {
      if (Opal.respond_to(error, &#39;$full_message&#39;)) {
        error = error.$full_message();
      }
      console.error(error);
      // Abort further execution
      Opal.promise_unhandled_exception = true;
      Opal.exit(1);
    });
    return Opal.last_promise;
  }
  else {
    var ret = proc(Opal);
    if (typeof Promise === &#39;function&#39; &amp;&amp; typeof ret === &#39;object&#39; &amp;&amp; ret instanceof Promise) {
      Opal.last_promise = ret;
    }
    return ret;
  }
}
</code></pre>

<h2 id="part-597705">``</h2>

<h2 id="operator-helpers">Operator helpers</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2 id="function-are_both_numbers_or_strings-lhs-rhs"><code>function are_both_numbers_or_strings(lhs, rhs)</code></h2>

<p>Optimized helpers for calls like $truthy((a)<a href="b">&#39;$===&#39;</a>) -&gt; $eqeqeq(a, b)</p>

<pre class="code js"><code class="js">function are_both_numbers_or_strings(lhs, rhs) {
  return (typeof lhs === &#39;number&#39; &amp;&amp; typeof rhs === &#39;number&#39;) ||
         (typeof lhs === &#39;string&#39; &amp;&amp; typeof rhs === &#39;string&#39;);
}
</code></pre>

<h2 id="function-return_val-arg"><code>function $return_val(arg)</code></h2>

<p>Shortcuts - optimized function generators for simple kinds of functions</p>

<pre class="code js"><code class="js">function $return_val(arg) {
  return function() {
    return arg;
  }
}
</code></pre>

<h2 id="opal-ensure_kwargs-function-kwargs"><code>Opal.ensure_kwargs = function(kwargs)</code></h2>

<p>Primitives for handling parameters</p>

<pre class="code js"><code class="js">Opal.ensure_kwargs = function(kwargs) {
  if (kwargs == null) {
    return new Map();
  } else if (kwargs.$$is_hash) {
    return kwargs;
  } else {
    $raise(Opal.ArgumentError, &#39;expected kwargs&#39;);
  }
}
</code></pre>

<h2 id="opal-large_array_unpack-function-str"><code>Opal.large_array_unpack = function(str)</code></h2>

<p>Arrays of size &gt; 32 elements that contain only strings,
symbols, integers and nils are compiled as a self-extracting
string.</p>

<pre class="code js"><code class="js">Opal.large_array_unpack = function(str) {
  var array = str.split(&quot;,&quot;), length = array.length, i;
  for (i = 0; i &lt; length; i++) {
    switch(array[i][0]) {
      case undefined:
        array[i] = nil
        break;
      case &#39;-&#39;:
      case &#39;0&#39;:
      case &#39;1&#39;:
      case &#39;2&#39;:
      case &#39;3&#39;:
      case &#39;4&#39;:
      case &#39;5&#39;:
      case &#39;6&#39;:
      case &#39;7&#39;:
      case &#39;8&#39;:
      case &#39;9&#39;:
        array[i] = +array[i];
    }
  }
  return array;
}
</code></pre>

<h2 id="opal-opal32_init-return_val-0x4f70616c"><code>Opal.opal32_init = $return_val(0x4f70616c)</code></h2>

<h2 id="opal32-checksum-algorithm-for-hash">Opal32-checksum algorithm for #hash</h2>

<pre class="code js"><code class="js">Opal.opal32_init = $return_val(0x4f70616c);
</code></pre>

<h2 id="opal-basicobject-basicobject-allocate_class-basicobject-null"><code>Opal.BasicObject = BasicObject = $allocate_class(&#39;BasicObject&#39;, null)</code></h2>

<h2 id="initialization">Initialization</h2>

<pre class="code js"><code class="js">Opal.BasicObject = BasicObject = $allocate_class(&#39;BasicObject&#39;, null);
</code></pre>

<h2 id="basicobject-const-basicobject-basicobject"><code>BasicObject.$$const.BasicObject = BasicObject</code></h2>

<p>BasicObject can reach itself, avoid const_set to skip the $$base_module logic</p>

<pre class="code js"><code class="js">BasicObject.$$const.BasicObject = BasicObject;
</code></pre>

<h2 id="const_set-_object-basicobject-basicobject"><code>$const_set(_Object, &quot;BasicObject&quot;,  BasicObject)</code></h2>

<p>Assign basic constants</p>

<pre class="code js"><code class="js">$const_set(_Object, &quot;BasicObject&quot;,  BasicObject);
</code></pre>

<h2 id="basicobject-class-class"><code>BasicObject.$$class = Class</code></h2>

<p>Fix booted classes to have correct .class value</p>

<pre class="code js"><code class="js">BasicObject.$$class = Class;
</code></pre>

<h2 id="prop-_object-prototype-tostring-function"><code>$prop(_Object.$$prototype, &#39;toString&#39;, function()</code></h2>

<p>Forward .toString() to #to_s</p>

<pre class="code js"><code class="js">$prop(_Object.$$prototype, &#39;toString&#39;, function() {
  var to_s = this.$to_s();
  if (to_s.$$is_string &amp;&amp; typeof(to_s) === &#39;object&#39;) {
    // a string created using new String(&#39;string&#39;)
    return to_s.valueOf();
  } else {
    return to_s;
  }
});
</code></pre>

<h2 id="prop-_object-prototype-require-opal-require"><code>$prop(_Object.$$prototype, &#39;$require&#39;, Opal.require)</code></h2>

<p>Make Kernel#require immediately available as it&#39;s needed to require all the
other corelib files.</p>

<pre class="code js"><code class="js">$prop(_Object.$$prototype, &#39;$require&#39;, Opal.require);
</code></pre>

<h2 id="opal-top-new-_object"><code>Opal.top = new _Object()</code></h2>

<p>Instantiate the main object</p>

<pre class="code js"><code class="js">Opal.top = new _Object();
</code></pre>

<h2 id="function-top_define_method"><code>function top_define_method()</code></h2>

<p>Foward calls to define_method on the top object to Object</p>

<pre class="code js"><code class="js">function top_define_method() {
  var block = top_define_method.$$p;
  top_define_method.$$p = null;
  return Opal.send(_Object, &#39;define_method&#39;, arguments, block)
};
</code></pre>

<h2 id="opal-nilclass-allocate_class-nilclass-opal-object"><code>Opal.NilClass = $allocate_class(&#39;NilClass&#39;, Opal.Object)</code></h2>

<p>Nil</p>

<pre class="code js"><code class="js">Opal.NilClass = $allocate_class(&#39;NilClass&#39;, Opal.Object);
</code></pre>

<h2 id="object-defineproperty-gvars"><code>Object.defineProperty($gvars, &quot;@&quot;,</code></h2>

<p>Define a &quot;$@&quot; global variable, which would compute and return a backtrace on demand.</p>

<pre class="code js"><code class="js">Object.defineProperty($gvars, &quot;@&quot;, {
</code></pre>

<h2 id="opal-file_sources"><code>Opal.file_sources = {}</code></h2>

<p>If enable-file-source-embed compiler option is enabled, each module loaded will add its
sources to this object</p>

<pre class="code js"><code class="js">Opal.file_sources = {};
</code></pre>
</div></div>

      <div id="footer">
  Generated on 11/23/23 by
  <!-- <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a> -->
  0.9.34 (ruby-2.7.5).
</div>

    </div>
  </body>
</html>