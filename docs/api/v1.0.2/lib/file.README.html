<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; lib (Opal v1.0.2)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  <span class="title"><a href="/docs">Opal Docs</a></span>
  
    &raquo;
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>ws: a Node.js WebSocket library</h1>

<p><a href="https://www.npmjs.com/package/ws"><img src="https://img.shields.io/npm/v/ws.svg" alt="Version npm"></a>
<a href="https://travis-ci.org/websockets/ws"><img src="https://img.shields.io/travis/websockets/ws/master.svg" alt="Linux Build"></a>
<a href="https://ci.appveyor.com/project/lpinca/ws"><img src="https://ci.appveyor.com/api/projects/status/github/websockets/ws?branch=master&svg=true" alt="Windows Build"></a>
<a href="https://coveralls.io/r/websockets/ws?branch=master"><img src="https://img.shields.io/coveralls/websockets/ws/master.svg" alt="Coverage Status"></a></p>

<p><code>ws</code> is a simple to use, blazing fast, and thoroughly tested WebSocket client
and server implementation.</p>

<p>Passes the quite extensive Autobahn test suite. See <a href="http://websockets.github.io/ws/">http://websockets.github.io/ws/</a>
for the full reports.</p>

<h2>Protocol support</h2>

<ul>
<li><strong>HyBi drafts 07-12</strong> (Use the option <code>protocolVersion: 8</code>)</li>
<li><strong>HyBi drafts 13-17</strong> (Current default, alternatively option <code>protocolVersion: 13</code>)</li>
</ul>

<h2>Installing</h2>

<pre class="code ruby"><code class="ruby">npm install --save ws
</code></pre>

<h3>Opt-in for performance</h3>

<p>There are 2 optional modules that can be installed along side with the <code>ws</code>
module. These modules are binary addons which improve certain operations, but as
they are binary addons they require compilation which can fail if no c++
compiler is installed on the host system.</p>

<ul>
<li><code>npm install --save bufferutil</code>: Improves internal buffer operations which
allows for faster processing of masked WebSocket frames and general buffer
operations.</li>
<li><code>npm install --save utf-8-validate</code>: The specification requires validation of
invalid UTF-8 chars, some of these validations could not be done in JavaScript
hence the need for a binary addon. In most cases you will already be
validating the input that you receive for security purposes leading to double
validation. But if you want to be 100% spec-conforming and have fast
validation of UTF-8 then this module is a must.</li>
</ul>

<h2>API Docs</h2>

<p>See <a href="https://github.com/websockets/ws/blob/master/doc/ws.md"><code>/doc/ws.md</code></a>
for Node.js-like docs for the ws classes.</p>

<h2>WebSocket compression</h2>

<p><code>ws</code> supports the <a href="https://tools.ietf.org/html/rfc7692">permessage-deflate extension</a> extension
which enables the client and server to negotiate a compression algorithm and
its parameters, and then selectively apply it to the data payloads of each
WebSocket message.</p>

<p>The extension is enabled by default but adds a significant overhead in terms of
performance and memory comsumption. We suggest to use WebSocket compression
only if it is really needed.</p>

<p>To disable the extension you can set the <code>perMessageDeflate</code> option to <code>false</code>.
On the server:</p>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({
  perMessageDeflate: false,
  port: 8080
});
</code></pre>

<p>On the client:</p>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;, {
  perMessageDeflate: false
});
</code></pre>

<h2>Usage examples</h2>

<h3>Sending and receiving text data</h3>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;);

ws.on(&#39;open&#39;, function open() {
  ws.send(&#39;something&#39;);
});

ws.on(&#39;message&#39;, function incoming(data, flags) {
  // flags.binary will be set if a binary data is received.
  // flags.masked will be set if the data was masked.
});
</code></pre>

<h3>Sending binary data</h3>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;ws://www.host.com/path&#39;);

ws.on(&#39;open&#39;, function open() {
  const array = new Float32Array(5);

  for (var i = 0; i &lt; array.length; ++i) {
    array[i] = i / 2;
  }

  ws.send(array);
});
</code></pre>

<h3>Server example</h3>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({ port: 8080 });

wss.on(&#39;connection&#39;, function connection(ws) {
  ws.on(&#39;message&#39;, function incoming(message) {
    console.log(&#39;received: %s&#39;, message);
  });

  ws.send(&#39;something&#39;);
});
</code></pre>

<h3>Broadcast example</h3>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const wss = new WebSocket.Server({ port: 8080 });

// Broadcast to all.
wss.broadcast = function broadcast(data) {
  wss.clients.forEach(function each(client) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(data);
    }
  });
};

wss.on(&#39;connection&#39;, function connection(ws) {
  ws.on(&#39;message&#39;, function incoming(data) {
    // Broadcast to everyone else.
    wss.clients.forEach(function each(client) {
      if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) {
        client.send(data);
      }
    });
  });
});
</code></pre>

<h3>ExpressJS example</h3>

<pre class="code js"><code class="js">const express = require(&#39;express&#39;);
const http = require(&#39;http&#39;);
const url = require(&#39;url&#39;);
const WebSocket = require(&#39;ws&#39;);

const app = express();

app.use(function (req, res) {
  res.send({ msg: &quot;hello&quot; });
});

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

wss.on(&#39;connection&#39;, function connection(ws) {
  const location = url.parse(ws.upgradeReq.url, true);
  // You might use location.query.access_token to authenticate or share sessions
  // or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)

  ws.on(&#39;message&#39;, function incoming(message) {
    console.log(&#39;received: %s&#39;, message);
  });

  ws.send(&#39;something&#39;);
});

server.listen(8080, function listening() {
  console.log(&#39;Listening on %d&#39;, server.address().port);
});
</code></pre>

<h3>echo.websocket.org demo</h3>

<pre class="code js"><code class="js">const WebSocket = require(&#39;ws&#39;);

const ws = new WebSocket(&#39;wss://echo.websocket.org/&#39;, {
  origin: &#39;https://websocket.org&#39;
});

ws.on(&#39;open&#39;, function open() {
  console.log(&#39;connected&#39;);
  ws.send(Date.now());
});

ws.on(&#39;close&#39;, function close() {
  console.log(&#39;disconnected&#39;);
});

ws.on(&#39;message&#39;, function incoming(data, flags) {
  console.log(`Roundtrip time: ${Date.now() - data} ms`, flags);

  setTimeout(function timeout() {
    ws.send(Date.now());
  }, 500);
});
</code></pre>

<h3>Other examples</h3>

<p>For a full example with a browser client communicating with a ws server, see the
examples folder.</p>

<p>Otherwise, see the test cases.</p>

<h2>Error handling best practices</h2>

<pre class="code js"><code class="js">// If the WebSocket is closed before the following send is attempted
ws.send(&#39;something&#39;);

// Errors (both immediate and async write errors) can be detected in an optional
// callback. The callback is also the only way of being notified that data has
// actually been sent.
ws.send(&#39;something&#39;, function ack(error) {
  // If error is not defined, the send has been completed, otherwise the error
  // object will indicate what failed.
});

// Immediate errors can also be handled with `try...catch`, but **note** that
// since sends are inherently asynchronous, socket write failures will *not* be
// captured when this technique is used.
try { ws.send(&#39;something&#39;); }
catch (e) { /* handle error */ }
</code></pre>

<h2>Changelog</h2>

<p>We&#39;re using the GitHub <a href="https://github.com/websockets/ws/releases"><code>releases</code></a>
for changelog entries.</p>

<h2>License</h2>

<p><a href="LICENSE">MIT</a></p>
</div></div>

      <div id="footer">
  Generated on 02/02/20 by
  <!-- <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a> -->
  0.9.9 (ruby-2.6.3).
</div>

    </div>
  </body>
</html>