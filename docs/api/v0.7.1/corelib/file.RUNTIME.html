<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: RUNTIME
  
    &mdash; corelib (Opal v0.7.1)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "RUNTIME";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  <span class="title"><a href="/docs">Opal Docs</a></span>
  
    &raquo;
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: RUNTIME</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>runtime.js</h1>

<h2><code>Opal = this.Opal = {}</code></h2>

<p>The Opal object that is exposed globally</p>

<pre class="code js"><code class="js">var Opal = this.Opal = {};
</code></pre>

<h2><code>bridged_classes = Opal.bridged_classes = []</code></h2>

<p>All bridged classes - keep track to donate methods from Object</p>

<pre class="code js"><code class="js">var bridged_classes = Opal.bridged_classes = [];
</code></pre>

<h2><code>TopScope = function(){}</code></h2>

<p>TopScope is used for inheriting constants from the top scope</p>

<pre class="code js"><code class="js">var TopScope = function(){};
</code></pre>

<h2><code>TopScope.prototype = Opal</code></h2>

<p>Opal just acts as the top scope</p>

<pre class="code js"><code class="js">TopScope.prototype = Opal;
</code></pre>

<h2><code>Opal.constructor = TopScope</code></h2>

<p>To inherit scopes</p>

<pre class="code js"><code class="js">Opal.constructor = TopScope;
</code></pre>

<h2><code>Opal.constants = []</code></h2>

<p>List top scope constants</p>

<pre class="code js"><code class="js">Opal.constants = [];
</code></pre>

<h2><code>Opal.global = this</code></h2>

<p>This is a useful reference to global object inside ruby files</p>

<pre class="code js"><code class="js">Opal.global = this;
</code></pre>

<h2><code>$hasOwn = Opal.hasOwnProperty</code></h2>

<p>Minify common function calls</p>

<pre class="code js"><code class="js">var $hasOwn = Opal.hasOwnProperty;
</code></pre>

<h2><code>unique_id = 0</code></h2>

<p>Generates unique id for every ruby object</p>

<pre class="code js"><code class="js">var unique_id = 0;
</code></pre>

<h2><code>Opal.uid = function()</code></h2>

<p>Return next unique id</p>

<pre class="code js"><code class="js">Opal.uid = function() {
  return unique_id++;
};
</code></pre>

<h2><code>Opal.cvars = {}</code></h2>

<p>Table holds all class variables</p>

<pre class="code js"><code class="js">Opal.cvars = {};
</code></pre>

<h2><code>Opal.gvars = {}</code></h2>

<p>Globals table</p>

<pre class="code js"><code class="js">Opal.gvars = {};
</code></pre>

<h2><code>Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); }</code></h2>

<p>Exit function, this should be replaced by platform specific implementation
(See nodejs and phantom for examples)</p>

<pre class="code js"><code class="js">Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); };
</code></pre>

<h2><code>Opal.get = function(name)</code></h2>

<p>Get a constant on the given scope. Every class and module in Opal has a
scope used to store, and inherit, constants. For example, the top level
<code>Object</code> in ruby has a scope accessible as <code>Opal.Object.$$scope</code>.</p>

<p>To get the <code>Array</code> class using this scope, you could use:</p>

<p>Opal.Object.$$scope.get(&quot;Array&quot;)</p>

<p>If a constant with the given name cannot be found, then a dispatch to the
class/module&#39;s <code>#const_method</code> is called, which by default will raise an
error.</p>

<p>@param [String] name the name of the constant to lookup
@returns [RubyObject]</p>

<pre class="code js"><code class="js">Opal.get = function(name) {
  var constant = this[name];

  if (constant == null) {
    return this.base.$const_missing(name);
  }

  return constant;
};
</code></pre>

<h2><code>function create_scope(base, klass, id)</code></h2>

<p>Create a new constants scope for the given class with the given
base. Constants are looked up through their parents, so the base
scope will be the outer scope of the new klass.</p>

<pre class="code js"><code class="js">function create_scope(base, klass, id) {
  var const_alloc = function() {};
  var const_scope = const_alloc.prototype = new base.constructor();

  klass.$$scope       = const_scope;
  klass.$$base_module = base.base;

  const_scope.base        = klass;
  const_scope.constructor = const_alloc;
  const_scope.constants   = [];

  if (id) {
    klass.$$orig_scope = base;
    base[id] = base.constructor[id] = klass;
    base.constants.push(id);
  }
}
</code></pre>

<h2><code>Opal.klass = function(base, superklass, id, constructor)</code></h2>

<p>A <code>class Foo; end</code> expression in ruby is compiled to call this runtime
method which either returns an existing class of the given name, or creates
a new class in the given <code>base</code> scope.
*
If a constant with the given name exists, then we check to make sure that
it is a class and also that the superclasses match. If either of these
fail, then we raise a <code>TypeError</code>. Note, superklass may be null if one was
not specified in the ruby code.
*
We pass a constructor to this method of the form <code>function ClassName() {}</code>
simply so that classes show up with nicely formatted names inside debuggers
in the web browser (or node/sprockets).
*
The <code>base</code> is the current <code>self</code> value where the class is being created
from. We use this to get the scope for where the class should be created.
If <code>base</code> is an object (not a class/module), we simple get its class and
use that as the base instead.
*
@param [Object] base where the class is being created
@param [Class] superklass superclass of the new class (may be null)
@param [String] id the name of the class to be created
@param [Function] constructor function to use as constructor
@return [Class] new or existing ruby class</p>

<pre class="code js"><code class="js">Opal.klass = function(base, superklass, id, constructor) {
  // If base is an object, use its class
  if (!base.$$is_class) {
    base = base.$$class;
  }

  // Not specifying a superclass means we can assume it to be Object
  if (superklass === null) {
    superklass = ObjectClass;
  }

  var klass = base.$$scope[id];

  // If a constant exists in the scope, then we must use that
  if ($hasOwn.call(base.$$scope, id) &amp;&amp; klass.$$orig_scope === base.$$scope) {
    // Make sure the existing constant is a class, or raise error
    if (!klass.$$is_class) {
      throw Opal.TypeError.$new(id + &quot; is not a class&quot;);
    }

    // Make sure existing class has same superclass
    if (superklass !== klass.$$super &amp;&amp; superklass !== ObjectClass) {
      throw Opal.TypeError.$new(&quot;superclass mismatch for class &quot; + id);
    }
  }
  else if (typeof(superklass) === &#39;function&#39;) {
    // passed native constructor as superklass, so bridge it as ruby class
    return bridge_class(id, superklass);
  }
  else {
    // if class doesnt exist, create a new one with given superclass
    klass = boot_class(superklass, constructor);

    // name class using base (e.g. Foo or Foo::Baz)
    klass.$$name = id;

    // every class gets its own constant scope, inherited from current scope
    create_scope(base.$$scope, klass, id);

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    base[id] = base.$$scope[id] = klass;

    // Copy all parent constants to child, unless parent is Object
    if (superklass !== ObjectClass &amp;&amp; superklass !== BasicObjectClass) {
      donate_constants(superklass, klass);
    }

    // call .inherited() hook with new class on the superclass
    if (superklass.$inherited) {
      superklass.$inherited(klass);
    }
  }

  return klass;
};
</code></pre>

<h2><code>function boot_class(superklass, constructor)</code></h2>

<p>Create generic class with given superclass.</p>

<pre class="code js"><code class="js">function boot_class(superklass, constructor) {
  var alloc = boot_class_alloc(null, constructor, superklass)

  return boot_class_object(superklass, alloc);
}
</code></pre>

<h2><code>Opal.boot = boot_class</code></h2>

<p>Make <code>boot_class</code> available to the JS-API</p>

<pre class="code js"><code class="js">Opal.boot = boot_class;
</code></pre>

<h2><code>function boot_class_object(superklass, alloc)</code></h2>

<p>The class object itself (as in <code>Class.new</code>)
*
@param [(Opal) Class] superklass Another class object (as in <code>Class.new</code>)
@param [constructor]  alloc      The constructor that holds the prototype
                                 that will be used for instances of the
                                 newly constructed class.</p>

<pre class="code js"><code class="js">function boot_class_object(superklass, alloc) {
  var singleton_class = function() {};
  singleton_class.prototype = superklass.constructor.prototype;

  function OpalClass() {}
  OpalClass.prototype = new singleton_class();

  var klass = new OpalClass();

  setup_module_or_class_object(klass, OpalClass, superklass, alloc.prototype);

  // @property $$alloc This is the constructor of instances of the current
  //                   class. Its prototype will be used for method lookup
  klass.$$alloc = alloc;

  // @property $$proto.$$class Make available to instances a reference to the
  //                           class they belong to.
  klass.$$proto.$$class = klass;

  return klass;
}
</code></pre>

<h2><code>function setup_module_or_class_object(module, constructor, superklass, prototype)</code></h2>

<p>Adds common/required properties to a module or class object
(as in <code>Module.new</code> / <code>Class.new</code>)
*
@param module      The module or class that needs to be prepared
*
@param constructor The constructor of the module or class itself,
                   usually it&#39;s already assigned by using <code>new</code>. Some
                   ipothesis on why it&#39;s needed can be found below.
*
@param superklass  The superclass of the class/module object, for modules
                   is <code>Module</code> (of <code>ModuleClass</code> in JS context)
*
@param prototype   The prototype on which the class/module methods will
                   be stored.</p>

<pre class="code js"><code class="js">function setup_module_or_class_object(module, constructor, superklass, prototype) {
  // @property $$id Each class is assigned a unique `id` that helps
  //                comparation and implementation of `#object_id`
  module.$$id = unique_id++;

  // @property $$proto This is the prototype on which methods will be defined
  module.$$proto = prototype;

  // @property constructor keeps a ref to the constructor, but apparently the
  //                       constructor is already set on:
  //
  //                          `var module = new constructor` is called.
  //
  //                       Maybe there are some browsers not abiding (IE6?)
  module.constructor = constructor;

  // @property $$is_class Clearly mark this as a class-like
  module.$$is_class = true;

  // @property $$super the superclass, doesn&#39;t get changed by module inclusions
  module.$$super = superklass;

  // @property $$parent direct parent class or module
  //                    starts with the superclass, after module inclusion is
  //                    the last included module
  module.$$parent = superklass;

  // @property $$methods keeps track of methods defined on the class
  //                     but seems to be used just by `define_basic_object_method`
  //                     and for donating (Ruby) Object methods to bridged classes
  //                     TODO: check if it can be removed
  module.$$methods = [];

  // @property $$inc included modules
  module.$$inc = [];
}
</code></pre>

<h2><code>Opal.module = function(base, id)</code></h2>

<p>Define new module (or return existing module). The given <code>base</code> is basically
the current <code>self</code> value the <code>module</code> statement was defined in. If this is
a ruby module or class, then it is used, otherwise if the base is a ruby
object then that objects real ruby class is used (e.g. if the base is the
main object, then the top level <code>Object</code> class is used as the base).</p>

<p>If a module of the given name is already defined in the base, then that
instance is just returned.</p>

<p>If there is a class of the given name in the base, then an error is
generated instead (cannot have a class and module of same name in same base).</p>

<p>Otherwise, a new module is created in the base with the given name, and that
new instance is returned back (to be referenced at runtime).</p>

<p>@param [RubyModule or Class] base class or module this definition is inside
@param [String] id the name of the new (or existing) module
@returns [RubyModule]</p>

<pre class="code js"><code class="js">Opal.module = function(base, id) {
  var module;

  if (!base.$$is_class) {
    base = base.$$class;
  }

  if ($hasOwn.call(base.$$scope, id)) {
    module = base.$$scope[id];

    if (!module.$$is_mod &amp;&amp; module !== ObjectClass) {
      throw Opal.TypeError.$new(id + &quot; is not a module&quot;);
    }
  }
  else {
    module = boot_module_object();
    module.$$name = id;

    create_scope(base.$$scope, module, id);

    // Name new module directly onto current scope (Opal.Foo.Baz = module)
    base[id] = base.$$scope[id] = module;
  }

  return module;
};
</code></pre>

<h2><code>function boot_module_object()</code></h2>

<p>Internal function to create a new module instance. This simply sets up
the prototype hierarchy and method tables.</p>

<pre class="code js"><code class="js">function boot_module_object() {
  var mtor = function() {};
  mtor.prototype = ModuleClass.constructor.prototype;

  function module_constructor() {}
  module_constructor.prototype = new mtor();

  var module = new module_constructor();
  var module_prototype = {};

  setup_module_or_class_object(module, module_constructor, ModuleClass, module_prototype);

  module.$$is_mod = true;
  module.$$dep    = [];

  return module;
}
</code></pre>

<h2><code>Opal.get_singleton_class = function(object)</code></h2>

<p>Return the singleton class for the passed object.</p>

<p>If the given object alredy has a singleton class, then it will be stored on
the object as the <code>$$meta</code> property. If this exists, then it is simply
returned back.</p>

<p>Otherwise, a new singleton object for the class or object is created, set on
the object at <code>$$meta</code> for future use, and then returned.</p>

<p>@param [RubyObject] object the ruby object
@returns [RubyClass] the singleton class for object</p>

<pre class="code js"><code class="js">Opal.get_singleton_class = function(object) {
  if (object.$$meta) {
    return object.$$meta;
  }

  if (object.$$is_class) {
    return build_class_singleton_class(object);
  }

  return build_object_singleton_class(object);
};
</code></pre>

<h2><code>function build_class_singleton_class(klass)</code></h2>

<p>Build the singleton class for an existing class.</p>

<p>NOTE: Actually in MRI a class&#39; singleton class inherits from its
superclass&#39; singleton class which in turn inherits from Class.</p>

<p>@param [RubyClass] klass
@returns [RubyClass]</p>

<pre class="code js"><code class="js">function build_class_singleton_class(klass) {
  var meta = new Opal.Class.$$alloc;

  meta.$$class = Opal.Class;
  meta.$$proto = klass.constructor.prototype;

  meta.$$is_singleton = true;
  meta.$$inc          = [];
  meta.$$methods      = [];
  meta.$$scope        = klass.$$scope;

  return klass.$$meta = meta;
}
</code></pre>

<h2><code>function build_object_singleton_class(object)</code></h2>

<p>Build the singleton class for a Ruby (non class) Object.</p>

<p>@param [RubyObject] object
@returns [RubyClass]</p>

<pre class="code js"><code class="js">function build_object_singleton_class(object) {
  var orig_class = object.$$class,
      class_id   = &quot;#&lt;Class:#&lt;&quot; + orig_class.$$name + &quot;:&quot; + orig_class.$$id + &quot;&gt;&gt;&quot;;

  var Singleton = function () {};
  var meta = Opal.boot(orig_class, Singleton);
  meta.$$name   = class_id;

  meta.$$proto  = object;
  meta.$$class  = orig_class.$$class;
  meta.$$scope  = orig_class.$$scope;
  meta.$$parent = orig_class;
  return object.$$meta = meta;
}
</code></pre>

<h2><code>Opal.append_features = function(module, klass)</code></h2>

<p>The actual inclusion of a module into a class.</p>

<h2>Class <code>$$parent</code> and <code>iclass</code></h2>

<p>To handle <code>super</code> calls, every class has a <code>$$parent</code>. This parent is
used to resolve the next class for a super call. A normal class would
have this point to its superclass. However, if a class includes a module
then this would need to take into account the module. The module would
also have to then point its <code>$$parent</code> to the actual superclass. We
cannot modify modules like this, because it might be included in more
then one class. To fix this, we actually insert an <code>iclass</code> as the class&#39;
<code>$$parent</code> which can then point to the superclass. The <code>iclass</code> acts as
a proxy to the actual module, so the <code>super</code> chain can then search it for
the required method.</p>

<p>@param [RubyModule] module the module to include
@param [RubyClass] klass the target class to include module into
@returns [null]</p>

<pre class="code js"><code class="js">Opal.append_features = function(module, klass) {
  var included = klass.$$inc;

  // check if this module is already included in the klass
  for (var j = 0, jj = included.length; j &lt; jj; j++) {
    if (included[j] === module) {
      return;
    }
  }

  included.push(module);
  module.$$dep.push(klass);

  // iclass
  var iclass = {
    $$name:   module.$$name,
    $$proto:  module.$$proto,
    $$parent: klass.$$parent,
    $$module: module,
    $$iclass: true
  };

  klass.$$parent = iclass;

  var donator   = module.$$proto,
      prototype = klass.$$proto,
      methods   = module.$$methods;

  for (var i = 0, length = methods.length; i &lt; length; i++) {
    var method = methods[i], current;


    if ( prototype.hasOwnProperty(method) &amp;&amp;
        !(current = prototype[method]).$$donated &amp;&amp; !current.$$stub ) {
      // if the target class already has a method of the same name defined
      // and that method was NOT donated, then it must be a method defined
      // by the class so we do not want to override it
    }
    else {
      prototype[method] = donator[method];
      prototype[method].$$donated = true;
    }
  }

  if (klass.$$dep) {
    donate_methods(klass, methods.slice(), true);
  }

  donate_constants(module, klass);
};
</code></pre>

<h2><code>function boot_class_alloc(id, constructor, superklass)</code></h2>

<p>Boot a base class (makes instances).</p>

<pre class="code js"><code class="js">function boot_class_alloc(id, constructor, superklass) {
  if (superklass) {
    var ctor = function() {};
        ctor.prototype   = superklass.$$proto || superklass.prototype;

    if (id) {
      ctor.displayName = id;
    }

    constructor.prototype = new ctor();
  }

  constructor.prototype.constructor = constructor;

  return constructor;
}
</code></pre>

<h2><code>function boot_core_class_object(id, alloc, superclass)</code></h2>

<p>Builds the class object for core classes:</p>

<ul>
<li>make the class object have a singleton class</li>
<li>make the singleton class inherit from its parent singleton class
*
@param id         [String]      the name of the class
@param alloc      [Function]    the constructor for the core class instances
@param superclass [Class alloc] the constructor of the superclass</li>
</ul>

<pre class="code js"><code class="js">function boot_core_class_object(id, alloc, superclass) {
  var superclass_constructor = function() {};
      superclass_constructor.prototype = superclass.prototype;

  var singleton_class = function() {};
      singleton_class.prototype = new superclass_constructor();

  singleton_class.displayName = &quot;#&lt;Class:&quot;+id+&quot;&gt;&quot;;

  // the singleton_class acts as the class object constructor
  var klass = new singleton_class();

  setup_module_or_class_object(klass, singleton_class, superclass, alloc.prototype);

  klass.$$alloc = alloc;
  klass.$$name  = id;

  // Give all instances a ref to their class
  alloc.prototype.$$class = klass;

  Opal[id] = klass;
  Opal.constants.push(id);

  return klass;
}
</code></pre>

<h2><code>function bridge_class(name, constructor)</code></h2>

<p>For performance, some core ruby classes are toll-free bridged to their
native javascript counterparts (e.g. a ruby Array is a javascript Array).
*
This method is used to setup a native constructor (e.g. Array), to have
its prototype act like a normal ruby class. Firstly, a new ruby class is
created using the native constructor so that its prototype is set as the
target for th new class. Note: all bridged classes are set to inherit
from Object.
*
Bridged classes are tracked in <code>bridged_classes</code> array so that methods
defined on Object can be &quot;donated&quot; to all bridged classes. This allows
us to fake the inheritance of a native prototype from our Object
prototype.
*
Example:
*
   bridge_class(&quot;Proc&quot;, Function);
*
@param [String] name the name of the ruby class to create
@param [Function] constructor native javascript constructor to use
@return [Class] returns new ruby class</p>

<pre class="code js"><code class="js">function bridge_class(name, constructor) {
  var klass = boot_class_object(ObjectClass, constructor);

  klass.$$name = name;

  create_scope(Opal, klass, name);
  bridged_classes.push(klass);

  var object_methods = BasicObjectClass.$$methods.concat(ObjectClass.$$methods);

  for (var i = 0, len = object_methods.length; i &lt; len; i++) {
    var meth = object_methods[i];
    constructor.prototype[meth] = ObjectClass.$$proto[meth];
  }

  add_stubs_subscriber(constructor.prototype);

  return klass;
}
</code></pre>

<h2><code>Opal.casgn = function(base_module, name, value)</code></h2>

<p>constant assign</p>

<pre class="code js"><code class="js">Opal.casgn = function(base_module, name, value) {
  var scope = base_module.$$scope;

  if (value.$$is_class &amp;&amp; value.$$name === nil) {
    value.$$name = name;
  }

  if (value.$$is_class) {
    value.$$base_module = base_module;
  }

  scope.constants.push(name);
  return scope[name] = value;
};
</code></pre>

<h2><code>Opal.cdecl = function(base_scope, name, value)</code></h2>

<p>constant decl</p>

<pre class="code js"><code class="js">Opal.cdecl = function(base_scope, name, value) {
  base_scope.constants.push(name);
  return base_scope[name] = value;
};
</code></pre>

<h2><code>function donate_constants(source_mod, target_mod)</code></h2>

<p>When a source module is included into the target module, we must also copy
its constants to the target.</p>

<pre class="code js"><code class="js">function donate_constants(source_mod, target_mod) {
  var source_constants = source_mod.$$scope.constants,
      target_scope     = target_mod.$$scope,
      target_constants = target_scope.constants;

  for (var i = 0, length = source_constants.length; i &lt; length; i++) {
    target_constants.push(source_constants[i]);
    target_scope[source_constants[i]] = source_mod.$$scope[source_constants[i]];
  }
};
</code></pre>

<h2><code>Opal.add_stubs = function(stubs)</code></h2>

<p>Methods stubs are used to facilitate method_missing in opal. A stub is a
placeholder function which just calls <code>method_missing</code> on the receiver.
If no method with the given name is actually defined on an object, then it
is obvious to say that the stub will be called instead, and then in turn
method_missing will be called.
*
When a file in ruby gets compiled to javascript, it includes a call to
this function which adds stubs for every method name in the compiled file.
It should then be safe to assume that method_missing will work for any
method call detected.
*
Method stubs are added to the BasicObject prototype, which every other
ruby object inherits, so all objects should handle method missing. A stub
is only added if the given property name (method name) is not already
defined.
*
Note: all ruby methods have a <code>$</code> prefix in javascript, so all stubs will
have this prefix as well (to make this method more performant).
*
   Opal.add_stubs([&quot;$foo&quot;, &quot;$bar&quot;, &quot;$baz=&quot;]);
*
All stub functions will have a private <code>$$stub</code> property set to true so
that other internal methods can detect if a method is just a stub or not.
<code>Kernel#respond_to?</code> uses this property to detect a methods presence.
*
@param [Array] stubs an array of method stubs to add</p>

<pre class="code js"><code class="js">Opal.add_stubs = function(stubs) {
  var subscribers = Opal.stub_subscribers;
  var subscriber;

  for (var i = 0, length = stubs.length; i &lt; length; i++) {
    var method_name = stubs[i], stub = stub_for(method_name);

    for (var j = 0; j &lt; subscribers.length; j++) {
      subscriber = subscribers[j];
      if (!(method_name in subscriber)) {
        subscriber[method_name] = stub;
      }
    }
  }
};
</code></pre>

<h2><code>function add_stubs_subscriber(prototype)</code></h2>

<p>Add a prototype to the subscribers list, and (TODO) add previously stubbed
methods.
*
@param [Prototype]</p>

<pre class="code js"><code class="js">function add_stubs_subscriber(prototype) {
  // TODO: Add previously stubbed methods too.
  Opal.stub_subscribers.push(prototype);
}
</code></pre>

<h2><code>Opal.stub_subscribers = [BasicObject.prototype]</code></h2>

<p>Keep a list of prototypes that want method_missing stubs to be added.
*
@default [Prototype List] BasicObject.prototype</p>

<pre class="code js"><code class="js">Opal.stub_subscribers = [BasicObject.prototype];
</code></pre>

<h2><code>function add_stub_for(prototype, stub)</code></h2>

<p>Add a method_missing stub function to the given prototype for the
given name.
*
@param [Prototype] prototype the target prototype
@param [String] stub stub name to add (e.g. &quot;$foo&quot;)</p>

<pre class="code js"><code class="js">function add_stub_for(prototype, stub) {
  var method_missing_stub = stub_for(stub);
  prototype[stub] = method_missing_stub;
}
</code></pre>

<h2><code>function stub_for(method_name)</code></h2>

<p>Generate the method_missing stub for a given method name.
*
@param [String] method_name The js-name of the method to stub (e.g. &quot;$foo&quot;)</p>

<pre class="code js"><code class="js">function stub_for(method_name) {
  function method_missing_stub() {
    // Copy any given block onto the method_missing dispatcher
    this.$method_missing.$$p = method_missing_stub.$$p;

    // Set block property to null ready for the next call (stop false-positives)
    method_missing_stub.$$p = null;

    // call method missing with correct args (remove &#39;$&#39; prefix on method name)
    return this.$method_missing.apply(this, [method_name.slice(1)].concat($slice.call(arguments)));
  }

  method_missing_stub.$$stub = true;

  return method_missing_stub;
}
</code></pre>

<h2><code>Opal.add_stub_for = add_stub_for</code></h2>

<p>Expose for other parts of Opal to use</p>

<pre class="code js"><code class="js">Opal.add_stub_for = add_stub_for;
</code></pre>

<h2><code>Opal.ac = function(actual, expected, object, meth)</code></h2>

<p>Arity count error dispatcher</p>

<pre class="code js"><code class="js">Opal.ac = function(actual, expected, object, meth) {
  var inspect = (object.$$is_class ? object.$$name + &#39;.&#39; : object.$$class.$$name + &#39;#&#39;) + meth;
  var msg = &#39;[&#39; + inspect + &#39;] wrong number of arguments(&#39; + actual + &#39; for &#39; + expected + &#39;)&#39;;
  throw Opal.ArgumentError.$new(msg);
};
</code></pre>

<h2><code>Opal.find_super_dispatcher = function(obj, jsid, current_func, iter, defs)</code></h2>

<p>Super dispatcher</p>

<pre class="code js"><code class="js">Opal.find_super_dispatcher = function(obj, jsid, current_func, iter, defs) {
  var dispatcher;

  if (defs) {
    dispatcher = obj.$$is_class ? defs.$$super : obj.$$class.$$proto;
  }
  else {
    if (obj.$$is_class) {
      dispatcher = obj.$$super;
    }
    else {
      dispatcher = find_obj_super_dispatcher(obj, jsid, current_func);
    }
  }

  dispatcher = dispatcher[&#39;$&#39; + jsid];
  dispatcher.$$p = iter;

  return dispatcher;
};
</code></pre>

<h2><code>Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, iter, defs)</code></h2>

<p>Iter dispatcher for super in a block</p>

<pre class="code js"><code class="js">Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, iter, defs) {
  if (current_func.$$def) {
    return Opal.find_super_dispatcher(obj, current_func.$$jsid, current_func, iter, defs);
  }
  else {
    return Opal.find_super_dispatcher(obj, jsid, current_func, iter, defs);
  }
};
</code></pre>

<h2><code>break</code></h2>

<p>ok</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2><code>if (!klass)</code></h2>

<p>if we arent in a class, we couldnt find current?</p>

<pre class="code js"><code class="js">if (!klass) {
</code></pre>

<h2><code>while (klass)</code></h2>

<p>else, let&#39;s find the next one</p>

<pre class="code js"><code class="js">while (klass) {
</code></pre>

<h2><code>break</code></h2>

<p>ok</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2><code>Opal.ret = function(val)</code></h2>

<p>Used to return as an expression. Sometimes, we can&#39;t simply return from
a javascript function as if we were a method, as the return is used as
an expression, or even inside a block which must &quot;return&quot; to the outer
method. This helper simply throws an error which is then caught by the
method. This approach is expensive, so it is only used when absolutely
needed.</p>

<pre class="code js"><code class="js">Opal.ret = function(val) {
  Opal.returner.$v = val;
  throw Opal.returner;
};
</code></pre>

<h2><code>Opal.yield1 = function(block, arg)</code></h2>

<p>handles yield calls for 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yield1 = function(block, arg) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  if (block.length &gt; 1 &amp;&amp; arg.$$is_array) {
    return block.apply(null, arg);
  }
  else {
    return block(arg);
  }
};
</code></pre>

<h2><code>Opal.yieldX = function(block, args)</code></h2>

<p>handles yield for &gt; 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yieldX = function(block, args) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  if (block.length &gt; 1 &amp;&amp; args.length == 1) {
    if (args[0].$$is_array) {
      return block.apply(null, args[0]);
    }
  }

  if (!args.$$is_array) {
    args = $slice.call(args);
  }

  return block.apply(null, args);
};
</code></pre>

<h2><code>Opal.rescue = function(exception, candidates)</code></h2>

<p>Finds the corresponding exception match in candidates.  Each candidate can
be a value, or an array of values.  Returns null if not found.</p>

<pre class="code js"><code class="js">Opal.rescue = function(exception, candidates) {
  for (var i = 0; i &lt; candidates.length; i++) {
    var candidate = candidates[i];

    if (candidate.$$is_array) {
      var result = Opal.rescue(exception, candidate);

      if (result) {
        return result;
      }
    }
    else if (candidate[&#39;$===&#39;](exception)) {
      return candidate;
    }
  }

  return null;
};
</code></pre>

<h2><code>Opal.to_ary = function(value)</code></h2>

<p>Helper to convert the given object to an array</p>

<pre class="code js"><code class="js">Opal.to_ary = function(value) {
  if (value.$$is_array) {
    return value;
  }
  else if (value.$to_ary &amp;&amp; !value.$to_ary.$$stub) {
    return value.$to_ary();
  }

  return [value];
};
</code></pre>

<h2><code>Opal.kwrestargs = function(given_args, used_args)</code></h2>

<p>Used to get a list of rest keyword arguments. Method takes the given
keyword args, i.e. the hash literal passed to the method containing all
keyword arguemnts passed to method, as well as the used args which are
the names of required and optional arguments defined. This method then
just returns all key/value pairs which have not been used, in a new
hash literal.</p>

<p>@param given_args [Hash] all kwargs given to method
@param used_args [Object<String: true>] all keys used as named kwargs
@return [Hash]</p>

<pre class="code js"><code class="js">Opal.kwrestargs = function(given_args, used_args) {
  var keys      = [],
      map       = {},
      key       = null,
      given_map = given_args.smap;

  for (key in given_map) {
    if (!used_args[key]) {
      keys.push(key);
      map[key] = given_map[key];
    }
  }

  return Opal.hash2(keys, map);
};
</code></pre>

<h2><code>Opal.send = function(recv, mid)</code></h2>

<p>Call a ruby method on a ruby object with some arguments:
*
  var my_array = [1, 2, 3, 4]
  Opal.send(my_array, &#39;length&#39;)     # =&gt; 4
  Opal.send(my_array, &#39;reverse!&#39;)   # =&gt; [4, 3, 2, 1]
*
A missing method will be forwarded to the object via
method_missing.
*
The result of either call with be returned.
*
@param [Object] recv the ruby object
@param [String] mid ruby method to call</p>

<pre class="code js"><code class="js">Opal.send = function(recv, mid) {
  var args = $slice.call(arguments, 2),
      func = recv[&#39;$&#39; + mid];

  if (func) {
    return func.apply(recv, args);
  }

  return recv.$method_missing.apply(recv, [mid].concat(args));
};
</code></pre>

<h2><code>function donate_methods(klass, defined, indirect)</code></h2>

<p>Donate methods for a class/module</p>

<pre class="code js"><code class="js">function donate_methods(klass, defined, indirect) {
  var methods = klass.$$methods, included_in = klass.$$dep;

  // if (!indirect) {
    klass.$$methods = methods.concat(defined);
  // }

  if (included_in) {
    for (var i = 0, length = included_in.length; i &lt; length; i++) {
      var includee = included_in[i];
      var dest     = includee.$$proto;

      for (var j = 0, jj = defined.length; j &lt; jj; j++) {
        var method = defined[j];

        dest[method] = klass.$$proto[method];
        dest[method].$$donated = true;
      }

      if (includee.$$dep) {
        donate_methods(includee, defined, true);
      }
    }
  }
};
</code></pre>

<h2><code>function define_module_method(module, jsid, body)</code></h2>

<p>Define the given method on the module.</p>

<p>This also handles donating methods to all classes that include this
module. Method conflicts are also handled here, where a class might already
have defined a method of the same name, or another included module defined
the same method.</p>

<p>@param [RubyModule] module the module method defined on
@param [String] jsid javascript friendly method name (e.g. &quot;$foo&quot;)
@param [Function] body method body of actual function</p>

<pre class="code js"><code class="js">function define_module_method(module, jsid, body) {
  module.$$proto[jsid] = body;
  body.$$owner = module;

  module.$$methods.push(jsid);

  if (module.$$module_function) {
    module[jsid] = body;
  }

  var included_in = module.$$dep;

  if (included_in) {
    for (var i = 0, length = included_in.length; i &lt; length; i++) {
      var includee = included_in[i];
      var dest = includee.$$proto;
      var current = dest[jsid];


      if (dest.hasOwnProperty(jsid) &amp;&amp; !current.$$donated &amp;&amp; !current.$$stub) {
        // target class has already defined the same method name - do nothing
      }
      else if (dest.hasOwnProperty(jsid) &amp;&amp; !current.$$stub) {
        // target class includes another module that has defined this method
        var klass_includees = includee.$$inc;

        for (var j = 0, jj = klass_includees.length; j &lt; jj; j++) {
          if (klass_includees[j] === current.$$owner) {
            var current_owner_index = j;
          }
          if (klass_includees[j] === module) {
            var module_index = j;
          }
        }

        // only redefine method on class if the module was included AFTER
        // the module which defined the current method body. Also make sure
        // a module can overwrite a method it defined before
        if (current_owner_index &lt;= module_index) {
          dest[jsid] = body;
          dest[jsid].$$donated = true;
        }
      }
      else {
        // neither a class, or module included by class, has defined method
        dest[jsid] = body;
        dest[jsid].$$donated = true;
      }

      if (includee.$$dep) {
        donate_methods(includee, [jsid], true);
      }
    }
  }
}
</code></pre>

<h2><code>Opal.defn = function(obj, jsid, body)</code></h2>

<p>Used to define methods on an object. This is a helper method, used by the
compiled source to define methods on special case objects when the compiler
can not determine the destination object, or the object is a Module
instance. This can get called by <code>Module#define_method</code> as well.</p>

<h2>Modules</h2>

<p>Any method defined on a module will come through this runtime helper.
The method is added to the module body, and the owner of the method is
set to be the module itself. This is used later when choosing which
method should show on a class if more than 1 included modules define
the same method. Finally, if the module is in <code>module_function</code> mode,
then the method is also defined onto the module itself.</p>

<h2>Classes</h2>

<p>This helper will only be called for classes when a method is being
defined indirectly; either through <code>Module#define_method</code>, or by a
literal <code>def</code> method inside an <code>instance_eval</code> or <code>class_eval</code> body. In
either case, the method is simply added to the class&#39; prototype. A special
exception exists for <code>BasicObject</code> and <code>Object</code>. These two classes are
special because they are used in toll-free bridged classes. In each of
these two cases, extra work is required to define the methods on toll-free
bridged class&#39; prototypes as well.</p>

<h2>Objects</h2>

<p>If a simple ruby object is the object, then the method is simply just
defined on the object as a singleton method. This would be the case when
a method is defined inside an <code>instance_eval</code> block.</p>

<p>@param [RubyObject or Class] obj the actual obj to define method for
@param [String] jsid the javascript friendly method name (e.g. &#39;$foo&#39;)
@param [Function] body the literal javascript function used as method
@returns [null]</p>

<pre class="code js"><code class="js">Opal.defn = function(obj, jsid, body) {
  if (obj.$$is_mod) {
    define_module_method(obj, jsid, body);
  }
  else if (obj.$$is_class) {
    obj.$$proto[jsid] = body;

    if (obj === BasicObjectClass) {
      define_basic_object_method(jsid, body);
    }
    else if (obj === ObjectClass) {
      donate_methods(obj, [jsid]);
    }
  }
  else {
    obj[jsid] = body;
  }

  return nil;
};
</code></pre>

<h2><code>Opal.defs = function(obj, jsid, body)</code></h2>

<p>Define a singleton method on the given object.</p>

<pre class="code js"><code class="js">Opal.defs = function(obj, jsid, body) {
  if (obj.$$is_class || obj.$$is_mod) {
    obj.constructor.prototype[jsid] = body;
  }
  else {
    obj[jsid] = body;
  }
};
</code></pre>

<h2><code>Opal.hash2 = function(keys, map)</code></h2>

<p>hash2 is a faster creator for hashes that just use symbols and
strings as keys. The map and keys array can be constructed at
compile time, so they are just added here by the constructor
function</p>

<pre class="code js"><code class="js">Opal.hash2 = function(keys, map) {
  var hash = new Opal.Hash.$$alloc();

  hash.keys = keys;
  hash.map  = {};
  hash.smap = map;

  return hash;
};
</code></pre>

<h2><code>Opal.range = function(first, last, exc)</code></h2>

<p>Create a new range instance with first and last values, and whether the
range excludes the last value.</p>

<pre class="code js"><code class="js">Opal.range = function(first, last, exc) {
  var range         = new Opal.Range.$$alloc();
      range.begin   = first;
      range.end     = last;
      range.exclude = exc;

  return range;
};
</code></pre>

<h2><code>(function(Opal)</code></h2>

<h2>Require system</h2>

<pre class="code js"><code class="js">(function(Opal) {
  var loaded_features = [&#39;corelib/runtime.js&#39;],
      require_table   = {&#39;corelib/runtime.js&#39;: true},
      modules         = {};

  var current_dir  = &#39;.&#39;;

  function mark_as_loaded(filename) {
    if (require_table[filename]) {
      return false;
    }

    loaded_features.push(filename);
    require_table[filename] = true;

    return true;
  }

  function normalize_loadable_path(path) {
    var parts, part, new_parts = [], SEPARATOR = &#39;/&#39;;

    if (current_dir !== &#39;.&#39;) {
      path = current_dir.replace(/\/*$/, &#39;/&#39;) + path;
    }

    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i &lt; ii; i++) {
      part = parts[i];
      if (part == &#39;&#39;) continue;
      (part === &#39;..&#39;) ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  }

  function load(path) {
    mark_as_loaded(path);

    var module = modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.dynamic_require_severity || &#39;warning&#39;;
      var message  = &#39;cannot load such file -- &#39; + path;

      if (severity === &quot;error&quot;) {
        Opal.LoadError ? Opal.LoadError.$new(message) : function(){throw message}();
      }
      else if (severity === &quot;warning&quot;) {
        console.warn(&#39;WARNING: LoadError: &#39; + message);
      }
    }

    return true;
  }

  function require(path) {
    if (require_table[path]) {
      return false;
    }

    return load(path);
  }

  Opal.modules         = modules;
  Opal.loaded_features = loaded_features;

  Opal.normalize_loadable_path = normalize_loadable_path;
  Opal.mark_as_loaded          = mark_as_loaded;

  Opal.load    = load;
  Opal.require = require;
})(Opal);
</code></pre>

<h2>``</h2>

<h2>Initialization</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>BasicObjectClass</code></h2>

<p>The actual class for BasicObject</p>

<pre class="code js"><code class="js">var BasicObjectClass;
</code></pre>

<h2><code>ObjectClass</code></h2>

<p>The actual Object class</p>

<pre class="code js"><code class="js">var ObjectClass;
</code></pre>

<h2><code>ModuleClass</code></h2>

<p>The actual Module class</p>

<pre class="code js"><code class="js">var ModuleClass;
</code></pre>

<h2><code>ClassClass</code></h2>

<p>The actual Class class</p>

<pre class="code js"><code class="js">var ClassClass;
</code></pre>

<h2>function: <code>BasicObject()</code></h2>

<p>Constructor for instances of BasicObject</p>

<pre class="code js"><code class="js">function BasicObject(){}
</code></pre>

<h2>function: <code>Object()</code></h2>

<p>Constructor for instances of Object</p>

<pre class="code js"><code class="js">function Object(){}
</code></pre>

<h2>function: <code>Class()</code></h2>

<p>Constructor for instances of Class</p>

<pre class="code js"><code class="js">function Class(){}
</code></pre>

<h2>function: <code>Module()</code></h2>

<p>Constructor for instances of Module</p>

<pre class="code js"><code class="js">function Module(){}
</code></pre>

<h2>function: <code>NilClass()</code></h2>

<p>Constructor for instances of NilClass (nil)</p>

<pre class="code js"><code class="js">function NilClass(){}
</code></pre>

<h2><code>boot_class_alloc(&#39;BasicObject&#39;, BasicObject)</code></h2>

<p>Constructors for <em>instances</em> of core objects</p>

<pre class="code js"><code class="js">boot_class_alloc(&#39;BasicObject&#39;, BasicObject);
</code></pre>

<h2><code>BasicObjectClass = boot_core_class_object(&#39;BasicObject&#39;, BasicObject, Class)</code></h2>

<p>Constructors for <em>classes</em> of core objects</p>

<pre class="code js"><code class="js">BasicObjectClass = boot_core_class_object(&#39;BasicObject&#39;, BasicObject, Class);
</code></pre>

<h2><code>BasicObjectClass.$$class = ClassClass</code></h2>

<p>Fix booted classes to use their metaclass</p>

<pre class="code js"><code class="js">BasicObjectClass.$$class = ClassClass;
</code></pre>

<h2><code>BasicObjectClass.$$super = null</code></h2>

<p>Fix superclasses of booted classes</p>

<pre class="code js"><code class="js">BasicObjectClass.$$super = null;
</code></pre>

<h2><code>ObjectClass.$$dep = bridged_classes</code></h2>

<p>Internally, Object acts like a module as it is &quot;included&quot; into bridged
classes. In other words, we donate methods from Object into our bridged
classes as their prototypes don&#39;t inherit from our root Object, so they
act like module includes.</p>

<pre class="code js"><code class="js">ObjectClass.$$dep = bridged_classes;
</code></pre>

<h2><code>nil_id = Opal.uid(); // nil id is traditionally 4</code></h2>

<p>Nil</p>

<pre class="code js"><code class="js">var nil_id = Opal.uid(); // nil id is traditionally 4
</code></pre>
</div></div>

      <div id="footer">
  Generated on 03/13/18 by
  <!-- <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a> -->
  0.9.9 (ruby-2.5.0).
</div>

    </div>
  </body>
</html>