<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: RUNTIME
  
    &mdash; corelib (Opal v1.0.3)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "RUNTIME";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  <span class="title"><a href="/docs">Opal Docs</a></span>
  
    &raquo;
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: RUNTIME</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>runtime.js</h1>

<h2>``</h2>

<p>@note
  A few conventions for the documentation of this file:</p>

<ol>
<li>Always use &quot;//&quot; (in contrast with &quot;/**/&quot;)</li>
<li>The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)</li>
<li><code>@param</code> and <code>@return</code> types should be preceded by <code>JS.</code> when referring to
 JavaScript constructors (e.g. <code>JS.Function</code>) otherwise Ruby is assumed.</li>
<li><code>nil</code> and <code>null</code> being unambiguous refer to the respective
 objects/values in Ruby and JavaScript</li>
<li>This is still WIP :) so please give feedback and suggestions on how
 to improve or for alternative solutions</li>
</ol>

<p>The way the code is digested before going through Yardoc is a secret kept
  in the docs repo (<a href="https://github.com/opal/docs/tree/master">https://github.com/opal/docs/tree/master</a>).</p>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>if (typeof(global) !== &#39;undefined&#39;) { global_object = global; }</code></h2>

<p>Detect the global object</p>

<pre class="code js"><code class="js">if (typeof(global) !== &#39;undefined&#39;) { global_object = global; }
</code></pre>

<h2><code>if (typeof(global_object.console) === &#39;object&#39;)</code></h2>

<p>Setup a dummy console object if missing</p>

<pre class="code js"><code class="js">if (typeof(global_object.console) === &#39;object&#39;) {
</code></pre>

<h2><code>BasicObject</code></h2>

<p>The actual class for BasicObject</p>

<pre class="code js"><code class="js">var BasicObject;
</code></pre>

<h2><code>_Object</code></h2>

<p>The actual Object class.
The leading underscore is to avoid confusion with window.Object()</p>

<pre class="code js"><code class="js">var _Object;
</code></pre>

<h2><code>Module</code></h2>

<p>The actual Module class</p>

<pre class="code js"><code class="js">var Module;
</code></pre>

<h2><code>Class</code></h2>

<p>The actual Class class</p>

<pre class="code js"><code class="js">var Class;
</code></pre>

<h2><code>Opal = this.Opal = {}</code></h2>

<p>The Opal object that is exposed globally</p>

<pre class="code js"><code class="js">var Opal = this.Opal = {};
</code></pre>

<h2><code>Opal.global = global_object</code></h2>

<p>This is a useful reference to global object inside ruby files</p>

<pre class="code js"><code class="js">Opal.global = global_object;
</code></pre>

<h2><code>Opal.config =</code></h2>

<p>Configure runtime behavior with regards to require and unsupported fearures</p>

<pre class="code js"><code class="js">Opal.config = {
</code></pre>

<h2><code>$hasOwn       = Object.hasOwnProperty</code></h2>

<p>Minify common function calls</p>

<pre class="code js"><code class="js">var $hasOwn       = Object.hasOwnProperty;
</code></pre>

<h2><code>nil_id = 4</code></h2>

<p>Nil object id is always 4</p>

<pre class="code js"><code class="js">var nil_id = 4;
</code></pre>

<h2><code>unique_id = nil_id</code></h2>

<p>Generates even sequential numbers greater than 4
(nil_id) to serve as unique ids for ruby objects</p>

<pre class="code js"><code class="js">var unique_id = nil_id;
</code></pre>

<h2><code>Opal.uid = function()</code></h2>

<p>Return next unique id</p>

<pre class="code js"><code class="js">Opal.uid = function() {
  unique_id += 2;
  return unique_id;
};
</code></pre>

<h2><code>Opal.id = function(obj)</code></h2>

<p>Retrieve or assign the id of an object</p>

<pre class="code js"><code class="js">Opal.id = function(obj) {
  if (obj.$$is_number) return (obj * 2)+1;
  if (obj.$$id != null) {
    return obj.$$id;
  }
  $defineProperty(obj, &#39;$$id&#39;, Opal.uid());
  return obj.$$id;
};
</code></pre>

<h2><code>Opal.gvars = {}</code></h2>

<p>Globals table</p>

<pre class="code js"><code class="js">Opal.gvars = {};
</code></pre>

<h2><code>Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); }</code></h2>

<p>Exit function, this should be replaced by platform specific implementation
(See nodejs and chrome for examples)</p>

<pre class="code js"><code class="js">Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log(&#39;Exited with status &#39;+status); };
</code></pre>

<h2><code>Opal.exceptions = []</code></h2>

<p>keeps track of exceptions for $!</p>

<pre class="code js"><code class="js">Opal.exceptions = [];
</code></pre>

<h2><code>Opal.pop_exception = function()</code></h2>

<p>@private
Pops an exception from the stack and updates <code>$!</code>.</p>

<pre class="code js"><code class="js">Opal.pop_exception = function() {
  Opal.gvars[&quot;!&quot;] = Opal.exceptions.pop() || nil;
};
</code></pre>

<h2><code>Opal.inspect = function(obj)</code></h2>

<p>Inspect any kind of object, including non Ruby ones</p>

<pre class="code js"><code class="js">Opal.inspect = function(obj) {
  if (obj === undefined) {
    return &quot;undefined&quot;;
  }
  else if (obj === null) {
    return &quot;null&quot;;
  }
  else if (!obj.$$class) {
    return obj.toString();
  }
  else {
    return obj.$inspect();
  }
};
</code></pre>

<h2><code>object[name] = initialValue</code></h2>

<p>Special case for:
  s = &quot;string&quot;
  def s.m; end
String class is the only class that:</p>

<ul>
<li>compiles to JS primitive</li>
<li>allows method definition directly on instances
numbers, true, false and nil do not support it.</li>
</ul>

<pre class="code js"><code class="js">object[name] = initialValue;
</code></pre>

<h2>``</h2>

<h2>Truth</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2>``</h2>

<h2>Constants</h2>

<p>For future reference:</p>

<ul>
<li>The Rails autoloading guide (<a href="http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html">http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html</a>)</li>
<li>@ConradIrwin&#39;s 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (<a href="http://cirw.in/blog/constant-lookup.html">http://cirw.in/blog/constant-lookup.html</a>)</li>
</ul>

<p>Legend of MRI concepts/names:</p>

<ul>
<li>constant reference (cref): the module/class that acts as a namespace</li>
<li>nesting: the namespaces wrapping the current scope, e.g. nesting inside
       <code>module A; module B::C; end; end</code> is <code>[B::C, A]</code></li>
</ul>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>function const_get_name(cref, name)</code></h2>

<p>Get the constant in the scope of the current cref</p>

<pre class="code js"><code class="js">function const_get_name(cref, name) {
  if (cref) return cref.$$const[name];
}
</code></pre>

<h2><code>function const_lookup_nesting(nesting, name)</code></h2>

<p>Walk up the nesting array looking for the constant</p>

<pre class="code js"><code class="js">function const_lookup_nesting(nesting, name) {
  var i, ii, result, constant;

  if (nesting.length === 0) return;

  // If the nesting is not empty the constant is looked up in its elements
  // and in order. The ancestors of those elements are ignored.
  for (i = 0, ii = nesting.length; i &lt; ii; i++) {
    constant = nesting[i].$$const[name];
    if (constant != null) return constant;
  }
}
</code></pre>

<h2><code>function const_lookup_ancestors(cref, name)</code></h2>

<p>Walk up the ancestors chain looking for the constant</p>

<pre class="code js"><code class="js">function const_lookup_ancestors(cref, name) {
  var i, ii, result, ancestors;

  if (cref == null) return;

  ancestors = Opal.ancestors(cref);

  for (i = 0, ii = ancestors.length; i &lt; ii; i++) {
    if (ancestors[i].$$const &amp;&amp; $hasOwn.call(ancestors[i].$$const, name)) {
      return ancestors[i].$$const[name];
    }
  }
}
</code></pre>

<h2><code>function const_lookup_Object(cref, name)</code></h2>

<p>Walk up Object&#39;s ancestors chain looking for the constant,
but only if cref is missing or a module.</p>

<pre class="code js"><code class="js">function const_lookup_Object(cref, name) {
  if (cref == null || cref.$$is_module) {
    return const_lookup_ancestors(_Object, name);
  }
}
</code></pre>

<h2><code>function const_missing(cref, name, skip_missing)</code></h2>

<p>Call const_missing if nothing else worked</p>

<pre class="code js"><code class="js">function const_missing(cref, name, skip_missing) {
  if (!skip_missing) {
    return (cref || _Object).$const_missing(name);
  }
}
</code></pre>

<h2><code>Opal.const_get_local = function(cref, name, skip_missing)</code></h2>

<p>Look for the constant just in the current cref or call <code>#const_missing</code></p>

<pre class="code js"><code class="js">Opal.const_get_local = function(cref, name, skip_missing) {
  var result;

  if (cref == null) return;

  if (cref === &#39;::&#39;) cref = _Object;

  if (!cref.$$is_module &amp;&amp; !cref.$$is_class) {
    throw new Opal.TypeError(cref.toString() + &quot; is not a class/module&quot;);
  }

  result = const_get_name(cref, name);              if (result != null) return result;
  result = const_missing(cref, name, skip_missing); if (result != null) return result;
};
</code></pre>

<h2><code>Opal.const_get_qualified = function(cref, name, skip_missing)</code></h2>

<p>Look for the constant relative to a cref or call <code>#const_missing</code> (when the
constant is prefixed by <code>::</code>).</p>

<pre class="code js"><code class="js">Opal.const_get_qualified = function(cref, name, skip_missing) {
  var result, cache, cached, current_version = Opal.const_cache_version;

  if (cref == null) return;

  if (cref === &#39;::&#39;) cref = _Object;

  if (!cref.$$is_module &amp;&amp; !cref.$$is_class) {
    throw new Opal.TypeError(cref.toString() + &quot; is not a class/module&quot;);
  }

  if ((cache = cref.$$const_cache) == null) {
    $defineProperty(cref, &#39;$$const_cache&#39;, Object.create(null));
    cache = cref.$$const_cache;
  }
  cached = cache[name];

  if (cached == null || cached[0] !== current_version) {
    ((result = const_get_name(cref, name))              != null) ||
    ((result = const_lookup_ancestors(cref, name))      != null);
    cache[name] = [current_version, result];
  } else {
    result = cached[1];
  }

  return result != null ? result : const_missing(cref, name, skip_missing);
};
</code></pre>

<h2><code>Opal.const_cache_version = 1</code></h2>

<p>Initialize the top level constant cache generation counter</p>

<pre class="code js"><code class="js">Opal.const_cache_version = 1;
</code></pre>

<h2><code>Opal.const_get_relative = function(nesting, name, skip_missing)</code></h2>

<p>Look for the constant in the open using the current nesting and the nearest
cref ancestors or call <code>#const_missing</code> (when the constant has no :: prefix).</p>

<pre class="code js"><code class="js">Opal.const_get_relative = function(nesting, name, skip_missing) {
  var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

  if ((cache = nesting.$$const_cache) == null) {
    $defineProperty(nesting, &#39;$$const_cache&#39;, Object.create(null));
    cache = nesting.$$const_cache;
  }
  cached = cache[name];

  if (cached == null || cached[0] !== current_version) {
    ((result = const_get_name(cref, name))              != null) ||
    ((result = const_lookup_nesting(nesting, name))     != null) ||
    ((result = const_lookup_ancestors(cref, name))      != null) ||
    ((result = const_lookup_Object(cref, name))         != null);

    cache[name] = [current_version, result];
  } else {
    result = cached[1];
  }

  return result != null ? result : const_missing(cref, name, skip_missing);
};
</code></pre>

<h2><code>Opal.const_set = function(cref, name, value)</code></h2>

<p>Register the constant on a cref and opportunistically set the name of
unnamed classes/modules.</p>

<pre class="code js"><code class="js">Opal.const_set = function(cref, name, value) {
  if (cref == null || cref === &#39;::&#39;) cref = _Object;

  if (value.$$is_a_module) {
    if (value.$$name == null || value.$$name === nil) value.$$name = name;
    if (value.$$base_module == null) value.$$base_module = cref;
  }

  cref.$$const = (cref.$$const || Object.create(null));
  cref.$$const[name] = value;

  // Add a short helper to navigate constants manually.
  // @example
  //   Opal.$$.Regexp.$$.IGNORECASE
  cref.$$ = cref.$$const;

  Opal.const_cache_version++;

  // Expose top level constants onto the Opal object
  if (cref === _Object) Opal[name] = value;

  // Name new class directly onto current scope (Opal.Foo.Baz = klass)
  $defineProperty(cref, name, value);

  return value;
};
</code></pre>

<h2><code>Opal.constants = function(cref, inherit)</code></h2>

<p>Get all the constants reachable from a given cref, by default will include
inherited constants.</p>

<pre class="code js"><code class="js">Opal.constants = function(cref, inherit) {
  if (inherit == null) inherit = true;

  var module, modules = [cref], module_constants, i, ii, constants = {}, constant;

  if (inherit) modules = modules.concat(Opal.ancestors(cref));
  if (inherit &amp;&amp; cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

  for (i = 0, ii = modules.length; i &lt; ii; i++) {
    module = modules[i];

    // Don not show Objects constants unless we&#39;re querying Object itself
    if (cref !== _Object &amp;&amp; module == _Object) break;

    for (constant in module.$$const) {
      constants[constant] = true;
    }
  }

  return Object.keys(constants);
};
</code></pre>

<h2><code>Opal.const_remove = function(cref, name)</code></h2>

<p>Remove a constant from a cref.</p>

<pre class="code js"><code class="js">Opal.const_remove = function(cref, name) {
  Opal.const_cache_version++;

  if (cref.$$const[name] != null) {
    var old = cref.$$const[name];
    delete cref.$$const[name];
    return old;
  }

  if (cref.$$autoload != null &amp;&amp; cref.$$autoload[name] != null) {
    delete cref.$$autoload[name];
    return nil;
  }

  throw Opal.NameError.$new(&quot;constant &quot;+cref+&quot;::&quot;+cref.$name()+&quot; not defined&quot;);
};
</code></pre>

<h2>``</h2>

<h2>Modules &amp; Classes</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.allocate_class = function(name, superclass)</code></h2>

<p>A <code>class Foo; end</code> expression in ruby is compiled to call this runtime
method which either returns an existing class of the given name, or creates
a new class in the given <code>base</code> scope.</p>

<p>If a constant with the given name exists, then we check to make sure that
it is a class and also that the superclasses match. If either of these
fail, then we raise a <code>TypeError</code>. Note, <code>superclass</code> may be null if one
was not specified in the ruby code.</p>

<p>We pass a constructor to this method of the form <code>function ClassName() {}</code>
simply so that classes show up with nicely formatted names inside debuggers
in the web browser (or node/sprockets).</p>

<p>The <code>scope</code> is the current <code>self</code> value where the class is being created
from. We use this to get the scope for where the class should be created.
If <code>scope</code> is an object (not a class/module), we simple get its class and
use that as the scope instead.</p>

<p>@param scope        [Object] where the class is being created
@param superclass  [Class,null] superclass of the new class (may be null)
@param id          [String] the name of the class to be created
@param constructor [JS.Function] function to use as constructor</p>

<p>@return new [Class]  or existing ruby class</p>

<pre class="code js"><code class="js">Opal.allocate_class = function(name, superclass) {
  var klass, constructor;

  if (superclass != null &amp;&amp; superclass.$$bridge) {
    // Inheritance from bridged classes requires
    // calling original JS constructors
    constructor = function() {
      var args = $slice.call(arguments),
          self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

      // and replacing a __proto__ manually
      $setPrototype(self, klass.$$prototype);
      return self;
    }
  } else {
    constructor = function(){};
  }

  if (name) {
    $defineProperty(constructor, &#39;displayName&#39;, &#39;::&#39;+name);
  }

  klass = constructor;

  $defineProperty(klass, &#39;$$name&#39;, name);
  $defineProperty(klass, &#39;$$constructor&#39;, constructor);
  $defineProperty(klass, &#39;$$prototype&#39;, constructor.prototype);
  $defineProperty(klass, &#39;$$const&#39;, {});
  $defineProperty(klass, &#39;$$is_class&#39;, true);
  $defineProperty(klass, &#39;$$is_a_module&#39;, true);
  $defineProperty(klass, &#39;$$super&#39;, superclass);
  $defineProperty(klass, &#39;$$cvars&#39;, {});
  $defineProperty(klass, &#39;$$own_included_modules&#39;, []);
  $defineProperty(klass, &#39;$$own_prepended_modules&#39;, []);
  $defineProperty(klass, &#39;$$ancestors&#39;, []);
  $defineProperty(klass, &#39;$$ancestors_cache_version&#39;, null);

  $defineProperty(klass.$$prototype, &#39;$$class&#39;, klass);

  // By default if there are no singleton class methods
  // __proto__ is Class.prototype
  // Later singleton methods generate a singleton_class
  // and inject it into ancestors chain
  if (Opal.Class) {
    $setPrototype(klass, Opal.Class.prototype);
  }

  if (superclass != null) {
    $setPrototype(klass.$$prototype, superclass.$$prototype);

    if (superclass.$$meta) {
      // If superclass has metaclass then we have explicitely inherit it.
      Opal.build_class_singleton_class(klass);
    }
  }

  return klass;
};
</code></pre>

<h2><code>klass = const_get_name(scope, name)</code></h2>

<p>Try to find the class in the current scope</p>

<pre class="code js"><code class="js">var klass = const_get_name(scope, name);
</code></pre>

<h2><code>if (klass)</code></h2>

<p>If the class exists in the scope, then we must use that</p>

<pre class="code js"><code class="js">if (klass) {
</code></pre>

<h2><code>if (!klass.$$is_class)</code></h2>

<p>Make sure the existing constant is a class, or raise error</p>

<pre class="code js"><code class="js">if (!klass.$$is_class) {
</code></pre>

<h2><code>scope = _Object</code></h2>

<p>Global scope</p>

<pre class="code js"><code class="js">scope = _Object;
</code></pre>

<h2><code>scope = scope.$$class</code></h2>

<p>Scope is an object, use its class</p>

<pre class="code js"><code class="js">scope = scope.$$class;
</code></pre>

<h2><code>if (superclass != null &amp;&amp; !superclass.hasOwnProperty(&#39;$$is_class&#39;))</code></h2>

<p>If the superclass is not an Opal-generated class then we&#39;re bridging a native JS class</p>

<pre class="code js"><code class="js">if (superclass != null &amp;&amp; !superclass.hasOwnProperty(&#39;$$is_class&#39;)) {
</code></pre>

<h2><code>ensureSuperclassMatch(klass, superclass)</code></h2>

<p>Make sure existing class has same superclass</p>

<pre class="code js"><code class="js">ensureSuperclassMatch(klass, superclass);
</code></pre>

<h2>``</h2>

<p>Class doesn&#39;t exist, create a new one with given superclass...</p>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>if (superclass == null)</code></h2>

<p>Not specifying a superclass means we can assume it to be Object</p>

<pre class="code js"><code class="js">if (superclass == null) {
</code></pre>

<h2><code>klass = Opal.allocate_class(name, superclass)</code></h2>

<p>Create the class object (instance of Class)</p>

<pre class="code js"><code class="js">klass = Opal.allocate_class(name, superclass);
</code></pre>

<h2><code>if (superclass.$inherited)</code></h2>

<p>Call .inherited() hook with new class on the superclass</p>

<pre class="code js"><code class="js">if (superclass.$inherited) {
</code></pre>

<h2><code>Opal.allocate_module = function(name)</code></h2>

<p>Define new module (or return existing module). The given <code>scope</code> is basically
the current <code>self</code> value the <code>module</code> statement was defined in. If this is
a ruby module or class, then it is used, otherwise if the scope is a ruby
object then that objects real ruby class is used (e.g. if the scope is the
main object, then the top level <code>Object</code> class is used as the scope).</p>

<p>If a module of the given name is already defined in the scope, then that
instance is just returned.</p>

<p>If there is a class of the given name in the scope, then an error is
generated instead (cannot have a class and module of same name in same scope).</p>

<p>Otherwise, a new module is created in the scope with the given name, and that
new instance is returned back (to be referenced at runtime).</p>

<p>@param  scope [Module, Class] class or module this definition is inside
@param  id   [String] the name of the new (or existing) module</p>

<p>@return [Module]</p>

<pre class="code js"><code class="js">Opal.allocate_module = function(name) {
  var constructor = function(){};
  if (name) {
    $defineProperty(constructor, &#39;displayName&#39;, name+&#39;.$$constructor&#39;);
  }

  var module = constructor;

  if (name)
    $defineProperty(constructor, &#39;displayName&#39;, name+&#39;.constructor&#39;);

  $defineProperty(module, &#39;$$name&#39;, name);
  $defineProperty(module, &#39;$$prototype&#39;, constructor.prototype);
  $defineProperty(module, &#39;$$const&#39;, {});
  $defineProperty(module, &#39;$$is_module&#39;, true);
  $defineProperty(module, &#39;$$is_a_module&#39;, true);
  $defineProperty(module, &#39;$$cvars&#39;, {});
  $defineProperty(module, &#39;$$iclasses&#39;, []);
  $defineProperty(module, &#39;$$own_included_modules&#39;, []);
  $defineProperty(module, &#39;$$own_prepended_modules&#39;, []);
  $defineProperty(module, &#39;$$ancestors&#39;, [module]);
  $defineProperty(module, &#39;$$ancestors_cache_version&#39;, null);

  $setPrototype(module, Opal.Module.prototype);

  return module;
};
</code></pre>

<h2><code>scope = _Object</code></h2>

<p>Global scope</p>

<pre class="code js"><code class="js">scope = _Object;
</code></pre>

<h2><code>scope = scope.$$class</code></h2>

<p>Scope is an object, use its class</p>

<pre class="code js"><code class="js">scope = scope.$$class;
</code></pre>

<h2><code>module = Opal.allocate_module(name)</code></h2>

<p>Module doesnt exist, create a new one...</p>

<pre class="code js"><code class="js">module = Opal.allocate_module(name);
</code></pre>

<h2><code>Opal.get_singleton_class = function(object)</code></h2>

<p>Return the singleton class for the passed object.</p>

<p>If the given object alredy has a singleton class, then it will be stored on
the object as the <code>$$meta</code> property. If this exists, then it is simply
returned back.</p>

<p>Otherwise, a new singleton object for the class or object is created, set on
the object at <code>$$meta</code> for future use, and then returned.</p>

<p>@param object [Object] the ruby object
@return [Class] the singleton class for object</p>

<pre class="code js"><code class="js">Opal.get_singleton_class = function(object) {
  if (object.$$meta) {
    return object.$$meta;
  }

  if (object.hasOwnProperty(&#39;$$is_class&#39;)) {
    return Opal.build_class_singleton_class(object);
  } else if (object.hasOwnProperty(&#39;$$is_module&#39;)) {
    return Opal.build_module_singletin_class(object);
  } else {
    return Opal.build_object_singleton_class(object);
  }
};
</code></pre>

<h2><code>Opal.build_class_singleton_class = function(klass)</code></h2>

<p>Build the singleton class for an existing class. Class object are built
with their singleton class already in the prototype chain and inheriting
from their superclass object (up to <code>Class</code> itself).</p>

<p>NOTE: Actually in MRI a class&#39; singleton class inherits from its
superclass&#39; singleton class which in turn inherits from Class.</p>

<p>@param klass [Class]
@return [Class]</p>

<pre class="code js"><code class="js">Opal.build_class_singleton_class = function(klass) {
  var superclass, meta;

  if (klass.$$meta) {
    return klass.$$meta;
  }

  // The singleton_class superclass is the singleton_class of its superclass;
  // but BasicObject has no superclass (its `$$super` is null), thus we
  // fallback on `Class`.
  superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

  meta = Opal.allocate_class(null, superclass, function(){});

  $defineProperty(meta, &#39;$$is_singleton&#39;, true);
  $defineProperty(meta, &#39;$$singleton_of&#39;, klass);
  $defineProperty(klass, &#39;$$meta&#39;, meta);
  $setPrototype(klass, meta.$$prototype);
  // Restoring ClassName.class
  $defineProperty(klass, &#39;$$class&#39;, Opal.Class);

  return meta;
};
</code></pre>

<h2><code>$defineProperty(mod, &#39;$$class&#39;, Opal.Module)</code></h2>

<p>Restoring ModuleName.class</p>

<pre class="code js"><code class="js">$defineProperty(mod, &#39;$$class&#39;, Opal.Module);
</code></pre>

<h2><code>Opal.build_object_singleton_class = function(object)</code></h2>

<p>Build the singleton class for a Ruby (non class) Object.</p>

<p>@param object [Object]
@return [Class]</p>

<pre class="code js"><code class="js">Opal.build_object_singleton_class = function(object) {
  var superclass = object.$$class,
      klass = Opal.allocate_class(nil, superclass, function(){});

  $defineProperty(klass, &#39;$$is_singleton&#39;, true);
  $defineProperty(klass, &#39;$$singleton_of&#39;, object);

  delete klass.$$prototype.$$class;

  $defineProperty(object, &#39;$$meta&#39;, klass);

  $setPrototype(object, object.$$meta.$$prototype);

  return klass;
};
</code></pre>

<h2><code>Opal.class_variables = function(module)</code></h2>

<p>Returns an object containing all pairs of names/values
for all class variables defined in provided +module+
and its ancestors.</p>

<p>@param module [Module]
@return [Object]</p>

<pre class="code js"><code class="js">Opal.class_variables = function(module) {
  var ancestors = Opal.ancestors(module),
      i, length = ancestors.length,
      result = {};

  for (i = length - 1; i &gt;= 0; i--) {
    var ancestor = ancestors[i];

    for (var cvar in ancestor.$$cvars) {
      result[cvar] = ancestor.$$cvars[cvar];
    }
  }

  return result;
};
</code></pre>

<h2><code>Opal.class_variable_set = function(module, name, value)</code></h2>

<p>Sets class variable with specified +name+ to +value+
in provided +module+</p>

<p>@param module [Module]
@param name [String]
@param value [Object]</p>

<pre class="code js"><code class="js">Opal.class_variable_set = function(module, name, value) {
  var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

  for (i = length - 2; i &gt;= 0; i--) {
    var ancestor = ancestors[i];

    if ($hasOwn.call(ancestor.$$cvars, name)) {
      ancestor.$$cvars[name] = value;
      return value;
    }
  }

  module.$$cvars[name] = value;

  return value;
};
</code></pre>

<h2><code>break</code></h2>

<p>superclass</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2><code>Opal.append_features = function(module, includer)</code></h2>

<p>The actual inclusion of a module into a class.</p>

<h2>Class <code>$$parent</code> and <code>iclass</code></h2>

<p>To handle <code>super</code> calls, every class has a <code>$$parent</code>. This parent is
used to resolve the next class for a super call. A normal class would
have this point to its superclass. However, if a class includes a module
then this would need to take into account the module. The module would
also have to then point its <code>$$parent</code> to the actual superclass. We
cannot modify modules like this, because it might be included in more
then one class. To fix this, we actually insert an <code>iclass</code> as the class&#39;
<code>$$parent</code> which can then point to the superclass. The <code>iclass</code> acts as
a proxy to the actual module, so the <code>super</code> chain can then search it for
the required method.</p>

<p>@param module [Module] the module to include
@param includer [Module] the target class to include module into
@return [null]</p>

<pre class="code js"><code class="js">Opal.append_features = function(module, includer) {
  var module_ancestors = Opal.ancestors(module);
  var iclasses = [];

  if (module_ancestors.indexOf(includer) !== -1) {
    throw Opal.ArgumentError.$new(&#39;cyclic include detected&#39;);
  }

  for (var i = 0, length = module_ancestors.length; i &lt; length; i++) {
    var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
    $defineProperty(iclass, &#39;$$included&#39;, true);
    iclasses.push(iclass);
  }
  var includer_ancestors = Opal.ancestors(includer),
      chain = chain_iclasses(iclasses),
      start_chain_after,
      end_chain_on;

  if (includer_ancestors.indexOf(module) === -1) {
    // first time include

    // includer -&gt; chain.first -&gt; ...chain... -&gt; chain.last -&gt; includer.parent
    start_chain_after = includer.$$prototype;
    end_chain_on = Object.getPrototypeOf(includer.$$prototype);
  } else {
    // The module has been already included,
    // we don&#39;t need to put it into the ancestors chain again,
    // but this module may have new included modules.
    // If it&#39;s true we need to copy them.
    //
    // The simplest way is to replace ancestors chain from
    //          parent
    //            |
    //   `module` iclass (has a $$root flag)
    //            |
    //   ...previos chain of module.included_modules ...
    //            |
    //  &quot;next ancestor&quot; (has a $$root flag or is a real class)
    //
    // to
    //          parent
    //            |
    //    `module` iclass (has a $$root flag)
    //            |
    //   ...regenerated chain of module.included_modules
    //            |
    //   &quot;next ancestor&quot; (has a $$root flag or is a real class)
    //
    // because there are no intermediate classes between `parent` and `next ancestor`.
    // It doesn&#39;t break any prototypes of other objects as we don&#39;t change class references.

    var proto = includer.$$prototype, parent = proto, module_iclass = Object.getPrototypeOf(parent);

    while (module_iclass != null) {
      if (isRoot(module_iclass) &amp;&amp; module_iclass.$$module === module) {
        break;
      }

      parent = module_iclass;
      module_iclass = Object.getPrototypeOf(module_iclass);
    }

    var next_ancestor = Object.getPrototypeOf(module_iclass);

    // skip non-root iclasses (that were recursively included)
    while (next_ancestor.hasOwnProperty(&#39;$$iclass&#39;) &amp;&amp; !isRoot(next_ancestor)) {
      next_ancestor = Object.getPrototypeOf(next_ancestor);
    }

    start_chain_after = parent;
    end_chain_on = next_ancestor;
  }

  $setPrototype(start_chain_after, chain.first);
  $setPrototype(chain.last, end_chain_on);

  // recalculate own_included_modules cache
  includer.$$own_included_modules = own_included_modules(includer);

  Opal.const_cache_version++;
};
</code></pre>

<h2><code>module_ancestors = Opal.ancestors(module)</code></h2>

<p>Here we change the ancestors chain from</p>

<p>prepender
     |
   parent</p>

<p>to:</p>

<p>dummy(prepender)
     |
 iclass(module)
     |
iclass(prepender)
     |
   parent</p>

<pre class="code js"><code class="js">var module_ancestors = Opal.ancestors(module);
</code></pre>

<h2><code>prepender_iclass = dummy_prepender.$$define_methods_on</code></h2>

<p>The module already has some prepended modules
which means that we don&#39;t need to make it &quot;dummy&quot;</p>

<pre class="code js"><code class="js">prepender_iclass = dummy_prepender.$$define_methods_on;
</code></pre>

<h2><code>prepender_iclass = create_dummy_iclass(prepender)</code></h2>

<p>Making the module &quot;dummy&quot;</p>

<pre class="code js"><code class="js">prepender_iclass = create_dummy_iclass(prepender);
</code></pre>

<h2><code>$setPrototype(dummy_prepender, prepender_iclass)</code></h2>

<p>Converting
  dummy(prepender) -&gt; previous_parent
to
  dummy(prepender) -&gt; iclass(prepender) -&gt; previous_parent</p>

<pre class="code js"><code class="js">$setPrototype(dummy_prepender, prepender_iclass);
</code></pre>

<h2>``</h2>

<p>first time prepend</p>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>end_chain_on = Object.getPrototypeOf(dummy_prepender)</code></h2>

<p>next $$root or prepender_iclass or non-$$iclass</p>

<pre class="code js"><code class="js">end_chain_on = Object.getPrototypeOf(dummy_prepender);
</code></pre>

<h2><code>prepender.$$own_prepended_modules = own_prepended_modules(prepender)</code></h2>

<p>recalculate own_prepended_modules cache</p>

<pre class="code js"><code class="js">prepender.$$own_prepended_modules = own_prepended_modules(prepender);
</code></pre>

<h2><code>function create_dummy_iclass(module)</code></h2>

<p>Dummy iclass doesn&#39;t receive updates when the module gets a new method.</p>

<pre class="code js"><code class="js">function create_dummy_iclass(module) {
  var iclass = {},
      proto = module.$$prototype;

  if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
    proto = proto.$$define_methods_on;
  }

  var props = Object.getOwnPropertyNames(proto),
      length = props.length, i;

  for (i = 0; i &lt; length; i++) {
    var prop = props[i];
    $defineProperty(iclass, prop, proto[prop]);
  }

  $defineProperty(iclass, &#39;$$iclass&#39;, true);
  $defineProperty(iclass, &#39;$$module&#39;, module);

  return iclass;
}
</code></pre>

<h2><code>Opal.bridge = function(native_klass, klass)</code></h2>

<p>For performance, some core Ruby classes are toll-free bridged to their
native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).</p>

<p>This method is used to setup a native constructor (e.g. Array), to have
its prototype act like a normal Ruby class. Firstly, a new Ruby class is
created using the native constructor so that its prototype is set as the
target for the new class. Note: all bridged classes are set to inherit
from Object.</p>

<p>Example:</p>

<p>Opal.bridge(self, Function);</p>

<p>@param klass       [Class] the Ruby class to bridge
@param constructor [JS.Function] native JavaScript constructor to use
@return [Class] returns the passed Ruby class</p>

<pre class="code js"><code class="js">Opal.bridge = function(native_klass, klass) {
  if (native_klass.hasOwnProperty(&#39;$$bridge&#39;)) {
    throw Opal.ArgumentError.$new(&quot;already bridged&quot;);
  }

  var klass_to_inject, klass_reference;

  klass_to_inject = klass.$$super || Opal.Object;
  klass_reference = klass;
  var original_prototype = klass.$$prototype;

  // constructor is a JS function with a prototype chain like:
  // - constructor
  //   - super
  //
  // What we need to do is to inject our class (with its prototype chain)
  // between constructor and super. For example, after injecting ::Object
  // into JS String we get:
  //
  // - constructor (window.String)
  //   - Opal.Object
  //     - Opal.Kernel
  //       - Opal.BasicObject
  //         - super (window.Object)
  //           - null
  //
  $defineProperty(native_klass, &#39;$$bridge&#39;, klass);
  $setPrototype(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
  $defineProperty(klass, &#39;$$prototype&#39;, native_klass.prototype);

  $defineProperty(klass.$$prototype, &#39;$$class&#39;, klass);
  $defineProperty(klass, &#39;$$constructor&#39;, native_klass);
  $defineProperty(klass, &#39;$$bridge&#39;, true);
};
</code></pre>

<h2><code>Opal.ancestors = function(module)</code></h2>

<p>The Array of ancestors for a given module/class</p>

<pre class="code js"><code class="js">Opal.ancestors = function(module) {
  if (!module) { return []; }

  if (module.$$ancestors_cache_version === Opal.const_cache_version) {
    return module.$$ancestors;
  }

  var result = [], i, mods, length;

  for (i = 0, mods = own_ancestors(module), length = mods.length; i &lt; length; i++) {
    result.push(mods[i]);
  }

  if (module.$$super) {
    for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i &lt; length; i++) {
      result.push(mods[i]);
    }
  }

  module.$$ancestors_cache_version = Opal.const_cache_version;
  module.$$ancestors = result;

  return result;
};
</code></pre>

<h2>``</h2>

<h2>Method Missing</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.add_stubs = function(stubs)</code></h2>

<p>Methods stubs are used to facilitate method_missing in opal. A stub is a
placeholder function which just calls <code>method_missing</code> on the receiver.
If no method with the given name is actually defined on an object, then it
is obvious to say that the stub will be called instead, and then in turn
method_missing will be called.</p>

<p>When a file in ruby gets compiled to javascript, it includes a call to
this function which adds stubs for every method name in the compiled file.
It should then be safe to assume that method_missing will work for any
method call detected.</p>

<p>Method stubs are added to the BasicObject prototype, which every other
ruby object inherits, so all objects should handle method missing. A stub
is only added if the given property name (method name) is not already
defined.</p>

<p>Note: all ruby methods have a <code>$</code> prefix in javascript, so all stubs will
have this prefix as well (to make this method more performant).</p>

<p>Opal.add_stubs([&quot;$foo&quot;, &quot;$bar&quot;, &quot;$baz=&quot;]);</p>

<p>All stub functions will have a private <code>$$stub</code> property set to true so
that other internal methods can detect if a method is just a stub or not.
<code>Kernel#respond_to?</code> uses this property to detect a methods presence.</p>

<p>@param stubs [Array] an array of method stubs to add
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.add_stubs = function(stubs) {
  var proto = Opal.BasicObject.$$prototype;

  for (var i = 0, length = stubs.length; i &lt; length; i++) {
    var stub = stubs[i], existing_method = proto[stub];

    if (existing_method == null || existing_method.$$stub) {
      Opal.add_stub_for(proto, stub);
    }
  }
};
</code></pre>

<h2><code>Opal.add_stub_for = function(prototype, stub)</code></h2>

<p>Add a method_missing stub function to the given prototype for the
given name.</p>

<p>@param prototype [Prototype] the target prototype
@param stub [String] stub name to add (e.g. &quot;$foo&quot;)
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.add_stub_for = function(prototype, stub) {
  var method_missing_stub = Opal.stub_for(stub);
  $defineProperty(prototype, stub, method_missing_stub);
};
</code></pre>

<h2><code>Opal.stub_for = function(method_name)</code></h2>

<p>Generate the method_missing stub for a given method name.</p>

<p>@param method_name [String] The js-name of the method to stub (e.g. &quot;$foo&quot;)
@return [undefined]</p>

<pre class="code js"><code class="js">Opal.stub_for = function(method_name) {
  function method_missing_stub() {
    // Copy any given block onto the method_missing dispatcher
    this.$method_missing.$$p = method_missing_stub.$$p;

    // Set block property to null ready for the next call (stop false-positives)
    method_missing_stub.$$p = null;

    // call method missing with correct args (remove &#39;$&#39; prefix on method name)
    var args_ary = new Array(arguments.length);
    for(var i = 0, l = args_ary.length; i &lt; l; i++) { args_ary[i] = arguments[i]; }

    return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
  }

  method_missing_stub.$$stub = true;

  return method_missing_stub;
};
</code></pre>

<h2>``</h2>

<h2>Methods</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.ac = function(actual, expected, object, meth)</code></h2>

<p>Arity count error dispatcher for methods</p>

<p>@param actual [Fixnum] number of arguments given to method
@param expected [Fixnum] expected number of arguments
@param object [Object] owner of the method +meth+
@param meth [String] method name that got wrong number of arguments
@raise [ArgumentError]</p>

<pre class="code js"><code class="js">Opal.ac = function(actual, expected, object, meth) {
  var inspect = &#39;&#39;;
  if (object.$$is_a_module) {
    inspect += object.$$name + &#39;.&#39;;
  }
  else {
    inspect += object.$$class.$$name + &#39;#&#39;;
  }
  inspect += meth;

  throw Opal.ArgumentError.$new(&#39;[&#39; + inspect + &#39;] wrong number of arguments(&#39; + actual + &#39; for &#39; + expected + &#39;)&#39;);
};
</code></pre>

<h2><code>Opal.block_ac = function(actual, expected, context)</code></h2>

<p>Arity count error dispatcher for blocks</p>

<p>@param actual [Fixnum] number of arguments given to block
@param expected [Fixnum] expected number of arguments
@param context [Object] context of the block definition
@raise [ArgumentError]</p>

<pre class="code js"><code class="js">Opal.block_ac = function(actual, expected, context) {
  var inspect = &quot;`block in &quot; + context + &quot;&#39;&quot;;

  throw Opal.ArgumentError.$new(inspect + &#39;: wrong number of arguments (&#39; + actual + &#39; for &#39; + expected + &#39;)&#39;);
};
</code></pre>

<h2><code>Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs)</code></h2>

<p>Super dispatcher</p>

<pre class="code js"><code class="js">Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {
  var jsid = &#39;$&#39; + mid, ancestors, super_method;

  if (obj.hasOwnProperty(&#39;$$meta&#39;)) {
    ancestors = Opal.ancestors(obj.$$meta);
  } else {
    ancestors = Opal.ancestors(obj.$$class);
  }

  var current_index = ancestors.indexOf(current_func.$$owner);

  for (var i = current_index + 1; i &lt; ancestors.length; i++) {
    var ancestor = ancestors[i],
        proto = ancestor.$$prototype;

    if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
      proto = proto.$$define_methods_on;
    }

    if (proto.hasOwnProperty(jsid)) {
      var method = proto[jsid];

      if (!method.$$stub) {
        super_method = method;
      }
      break;
    }
  }

  if (!defcheck &amp;&amp; super_method == null &amp;&amp; Opal.Kernel.$method_missing === obj.$method_missing) {
    // method_missing hasn&#39;t been explicitly defined
    throw Opal.NoMethodError.$new(&#39;super: no superclass method `&#39;+mid+&quot;&#39; for &quot;+obj, mid);
  }

  return super_method;
};
</code></pre>

<h2><code>Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit)</code></h2>

<p>Iter dispatcher for super in a block</p>

<pre class="code js"><code class="js">Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
  var call_jsid = jsid;

  if (!current_func) {
    throw Opal.RuntimeError.$new(&quot;super called outside of method&quot;);
  }

  if (implicit &amp;&amp; current_func.$$define_meth) {
    throw Opal.RuntimeError.$new(&quot;implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly&quot;);
  }

  if (current_func.$$def) {
    call_jsid = current_func.$$jsid;
  }

  return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
};
</code></pre>

<h2><code>Opal.ret = function(val)</code></h2>

<p>Used to return as an expression. Sometimes, we can&#39;t simply return from
a javascript function as if we were a method, as the return is used as
an expression, or even inside a block which must &quot;return&quot; to the outer
method. This helper simply throws an error which is then caught by the
method. This approach is expensive, so it is only used when absolutely
needed.</p>

<pre class="code js"><code class="js">Opal.ret = function(val) {
  Opal.returner.$v = val;
  throw Opal.returner;
};
</code></pre>

<h2><code>Opal.brk = function(val, breaker)</code></h2>

<p>Used to break out of a block.</p>

<pre class="code js"><code class="js">Opal.brk = function(val, breaker) {
  breaker.$v = val;
  throw breaker;
};
</code></pre>

<h2><code>Opal.new_brk = function()</code></h2>

<p>Builds a new unique breaker, this is to avoid multiple nested breaks to get
in the way of each other.</p>

<pre class="code js"><code class="js">Opal.new_brk = function() {
  return new Error(&#39;unexpected break&#39;);
};
</code></pre>

<h2><code>Opal.yield1 = function(block, arg)</code></h2>

<p>handles yield calls for 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yield1 = function(block, arg) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  var has_mlhs = block.$$has_top_level_mlhs_arg,
      has_trailing_comma = block.$$has_trailing_comma_in_args;

  if (block.length &gt; 1 || ((has_mlhs || has_trailing_comma) &amp;&amp; block.length === 1)) {
    arg = Opal.to_ary(arg);
  }

  if ((block.length &gt; 1 || (has_trailing_comma &amp;&amp; block.length === 1)) &amp;&amp; arg.$$is_array) {
    return block.apply(null, arg);
  }
  else {
    return block(arg);
  }
};
</code></pre>

<h2><code>Opal.yieldX = function(block, args)</code></h2>

<p>handles yield for &gt; 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.yieldX = function(block, args) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  if (block.length &gt; 1 &amp;&amp; args.length === 1) {
    if (args[0].$$is_array) {
      return block.apply(null, args[0]);
    }
  }

  if (!args.$$is_array) {
    var args_ary = new Array(args.length);
    for(var i = 0, l = args_ary.length; i &lt; l; i++) { args_ary[i] = args[i]; }

    return block.apply(null, args_ary);
  }

  return block.apply(null, args);
};
</code></pre>

<h2><code>Opal.rescue = function(exception, candidates)</code></h2>

<p>Finds the corresponding exception match in candidates.  Each candidate can
be a value, or an array of values.  Returns null if not found.</p>

<pre class="code js"><code class="js">Opal.rescue = function(exception, candidates) {
  for (var i = 0; i &lt; candidates.length; i++) {
    var candidate = candidates[i];

    if (candidate.$$is_array) {
      var result = Opal.rescue(exception, candidate);

      if (result) {
        return result;
      }
    }
    else if (candidate === Opal.JS.Error) {
      return candidate;
    }
    else if (candidate[&#39;$===&#39;](exception)) {
      return candidate;
    }
  }

  return null;
};
</code></pre>

<h2><code>Opal.to_hash = function(value)</code></h2>

<p>Helpers for extracting kwsplats
Used for: { **h }</p>

<pre class="code js"><code class="js">Opal.to_hash = function(value) {
  if (value.$$is_hash) {
    return value;
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_hash&#39;, true)) {
    var hash = value.$to_hash();
    if (hash.$$is_hash) {
      return hash;
    }
    else {
      throw Opal.TypeError.$new(&quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Hash (&quot; + value.$$class + &quot;#to_hash gives &quot; + hash.$$class + &quot;)&quot;);
    }
  }
  else {
    throw Opal.TypeError.$new(&quot;no implicit conversion of &quot; + value.$$class + &quot; into Hash&quot;);
  }
};
</code></pre>

<h2>``</h2>

<p>Helpers for implementing multiple assignment
Our code for extracting the values and assigning them only works if the
return value is a JS array.
So if we get an Array subclass, extract the wrapped JS array from it</p>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.to_ary = function(value)</code></h2>

<p>Used for: a, b = something (no splat)</p>

<pre class="code js"><code class="js">Opal.to_ary = function(value) {
  if (value.$$is_array) {
    return value;
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_ary&#39;, true)) {
    var ary = value.$to_ary();
    if (ary === nil) {
      return [value];
    }
    else if (ary.$$is_array) {
      return ary;
    }
    else {
      throw Opal.TypeError.$new(&quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Array (&quot; + value.$$class + &quot;#to_ary gives &quot; + ary.$$class + &quot;)&quot;);
    }
  }
  else {
    return [value];
  }
};
</code></pre>

<h2><code>Opal.to_a = function(value)</code></h2>

<p>Used for: a, b = *something (with splat)</p>

<pre class="code js"><code class="js">Opal.to_a = function(value) {
  if (value.$$is_array) {
    // A splatted array must be copied
    return value.slice();
  }
  else if (value[&#39;$respond_to?&#39;](&#39;to_a&#39;, true)) {
    var ary = value.$to_a();
    if (ary === nil) {
      return [value];
    }
    else if (ary.$$is_array) {
      return ary;
    }
    else {
      throw Opal.TypeError.$new(&quot;Can&#39;t convert &quot; + value.$$class +
        &quot; to Array (&quot; + value.$$class + &quot;#to_a gives &quot; + ary.$$class + &quot;)&quot;);
    }
  }
  else {
    return [value];
  }
};
</code></pre>

<h2><code>Opal.extract_kwargs = function(parameters)</code></h2>

<p>Used for extracting keyword arguments from arguments passed to
JS function. If provided +arguments+ list doesn&#39;t have a Hash
as a last item, returns a blank Hash.</p>

<p>@param parameters [Array]
@return [Hash]</p>

<pre class="code js"><code class="js">Opal.extract_kwargs = function(parameters) {
  var kwargs = parameters[parameters.length - 1];
  if (kwargs != null &amp;&amp; kwargs[&#39;$respond_to?&#39;](&#39;to_hash&#39;, true)) {
    $splice.call(parameters, parameters.length - 1, 1);
    return kwargs.$to_hash();
  }
  else {
    return Opal.hash2([], {});
  }
};
</code></pre>

<h2><code>Opal.kwrestargs = function(given_args, used_args)</code></h2>

<p>Used to get a list of rest keyword arguments. Method takes the given
keyword args, i.e. the hash literal passed to the method containing all
keyword arguemnts passed to method, as well as the used args which are
the names of required and optional arguments defined. This method then
just returns all key/value pairs which have not been used, in a new
hash literal.</p>

<p>@param given_args [Hash] all kwargs given to method
@param used_args [Object<String: true>] all keys used as named kwargs
@return [Hash]</p>

<pre class="code js"><code class="js">Opal.kwrestargs = function(given_args, used_args) {
  var keys      = [],
      map       = {},
      key           ,
      given_map = given_args.$$smap;

  for (key in given_map) {
    if (!used_args[key]) {
      keys.push(key);
      map[key] = given_map[key];
    }
  }

  return Opal.hash2(keys, map);
};
</code></pre>

<h2><code>Opal.send = function(recv, method, args, block)</code></h2>

<p>Calls passed method on a ruby object with arguments and block:</p>

<p>Can take a method or a method name.</p>

<ol>
<li>When method name gets passed it invokes it by its name
and calls &#39;method_missing&#39; when object doesn&#39;t have this method.
Used internally by Opal to invoke method that takes a block or a splat.</li>
<li>When method (i.e. method body) gets passed, it doesn&#39;t trigger &#39;method_missing&#39;
because it doesn&#39;t know the name of the actual method.
Used internally by Opal to invoke &#39;super&#39;.</li>
</ol>

<p>@example
  var my_array = [1, 2, 3, 4]
  Opal.send(my_array, &#39;length&#39;)                    # =&gt; 4
  Opal.send(my_array, my_array.$length)            # =&gt; 4</p>

<p>Opal.send(my_array, &#39;reverse!&#39;)                  # =&gt; [4, 3, 2, 1]
  Opal.send(my_array, my_array[&#39;$reverse!&#39;]&#39;)      # =&gt; [4, 3, 2, 1]</p>

<p>@param recv [Object] ruby object
@param method [Function, String] method body or name of the method
@param args [Array] arguments that will be passed to the method call
@param block [Function] ruby block
@return [Object] returning value of the method call</p>

<pre class="code js"><code class="js">Opal.send = function(recv, method, args, block) {
  var body = (typeof(method) === &#39;string&#39;) ? recv[&#39;$&#39;+method] : method;

  if (body != null) {
    if (typeof block === &#39;function&#39;) {
      body.$$p = block;
    }
    return body.apply(recv, args);
  }

  return recv.$method_missing.apply(recv, [method].concat(args));
};
</code></pre>

<h2><code>Opal.def = function(obj, jsid, body)</code></h2>

<p>Used to define methods on an object. This is a helper method, used by the
compiled source to define methods on special case objects when the compiler
can not determine the destination object, or the object is a Module
instance. This can get called by <code>Module#define_method</code> as well.</p>

<h2>Modules</h2>

<p>Any method defined on a module will come through this runtime helper.
The method is added to the module body, and the owner of the method is
set to be the module itself. This is used later when choosing which
method should show on a class if more than 1 included modules define
the same method. Finally, if the module is in <code>module_function</code> mode,
then the method is also defined onto the module itself.</p>

<h2>Classes</h2>

<p>This helper will only be called for classes when a method is being
defined indirectly; either through <code>Module#define_method</code>, or by a
literal <code>def</code> method inside an <code>instance_eval</code> or <code>class_eval</code> body. In
either case, the method is simply added to the class&#39; prototype. A special
exception exists for <code>BasicObject</code> and <code>Object</code>. These two classes are
special because they are used in toll-free bridged classes. In each of
these two cases, extra work is required to define the methods on toll-free
bridged class&#39; prototypes as well.</p>

<h2>Objects</h2>

<p>If a simple ruby object is the object, then the method is simply just
defined on the object as a singleton method. This would be the case when
a method is defined inside an <code>instance_eval</code> block.</p>

<p>@param obj  [Object, Class] the actual obj to define method for
@param jsid [String] the JavaScript friendly method name (e.g. &#39;$foo&#39;)
@param body [JS.Function] the literal JavaScript function used as method
@return [null]</p>

<pre class="code js"><code class="js">Opal.def = function(obj, jsid, body) {
  // Special case for a method definition in the
  // top-level namespace
  if (obj === Opal.top) {
    Opal.defn(Opal.Object, jsid, body)
  }
  // if instance_eval is invoked on a module/class, it sets inst_eval_mod
  else if (!obj.$$eval &amp;&amp; obj.$$is_a_module) {
    Opal.defn(obj, jsid, body);
  }
  else {
    Opal.defs(obj, jsid, body);
  }
};
</code></pre>

<h2><code>Opal.defn = function(module, jsid, body)</code></h2>

<p>Define method on a module or class (see Opal.def).</p>

<pre class="code js"><code class="js">Opal.defn = function(module, jsid, body) {
  body.displayName = jsid;
  body.$$owner = module;

  var proto = module.$$prototype;
  if (proto.hasOwnProperty(&#39;$$dummy&#39;)) {
    proto = proto.$$define_methods_on;
  }
  $defineProperty(proto, jsid, body);

  if (module.$$is_module) {
    if (module.$$module_function) {
      Opal.defs(module, jsid, body)
    }

    for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i &lt; length; i++) {
      var iclass = iclasses[i];
      $defineProperty(iclass, jsid, body);
    }
  }

  var singleton_of = module.$$singleton_of;
  if (module.$method_added &amp;&amp; !module.$method_added.$$stub &amp;&amp; !singleton_of) {
    module.$method_added(jsid.substr(1));
  }
  else if (singleton_of &amp;&amp; singleton_of.$singleton_method_added &amp;&amp; !singleton_of.$singleton_method_added.$$stub) {
    singleton_of.$singleton_method_added(jsid.substr(1));
  }
};
</code></pre>

<h2><code>Opal.defs = function(obj, jsid, body)</code></h2>

<p>Define a singleton method on the given object (see Opal.def).</p>

<pre class="code js"><code class="js">Opal.defs = function(obj, jsid, body) {
  if (obj.$$is_string || obj.$$is_number) {
    throw Opal.TypeError.$new(&quot;can&#39;t define singleton&quot;);
  }
  Opal.defn(Opal.get_singleton_class(obj), jsid, body)
};
</code></pre>

<h2><code>Opal.rdef = function(obj, jsid)</code></h2>

<p>Called from #remove_method.</p>

<pre class="code js"><code class="js">Opal.rdef = function(obj, jsid) {
  if (!$hasOwn.call(obj.$$prototype, jsid)) {
    throw Opal.NameError.$new(&quot;method &#39;&quot; + jsid.substr(1) + &quot;&#39; not defined in &quot; + obj.$name());
  }

  delete obj.$$prototype[jsid];

  if (obj.$$is_singleton) {
    if (obj.$$prototype.$singleton_method_removed &amp;&amp; !obj.$$prototype.$singleton_method_removed.$$stub) {
      obj.$$prototype.$singleton_method_removed(jsid.substr(1));
    }
  }
  else {
    if (obj.$method_removed &amp;&amp; !obj.$method_removed.$$stub) {
      obj.$method_removed(jsid.substr(1));
    }
  }
};
</code></pre>

<h2><code>Opal.udef = function(obj, jsid)</code></h2>

<p>Called from #undef_method.</p>

<pre class="code js"><code class="js">Opal.udef = function(obj, jsid) {
  if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
    throw Opal.NameError.$new(&quot;method &#39;&quot; + jsid.substr(1) + &quot;&#39; not defined in &quot; + obj.$name());
  }

  Opal.add_stub_for(obj.$$prototype, jsid);

  if (obj.$$is_singleton) {
    if (obj.$$prototype.$singleton_method_undefined &amp;&amp; !obj.$$prototype.$singleton_method_undefined.$$stub) {
      obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
    }
  }
  else {
    if (obj.$method_undefined &amp;&amp; !obj.$method_undefined.$$stub) {
      obj.$method_undefined(jsid.substr(1));
    }
  }
};
</code></pre>

<h2><code>if (obj.$$eval)</code></h2>

<p>When running inside #instance_eval the alias refers to class methods.</p>

<pre class="code js"><code class="js">if (obj.$$eval) {
</code></pre>

<h2><code>body = Opal.Object.$$prototype[old_id]</code></h2>

<p>try to look into Object</p>

<pre class="code js"><code class="js">body = Opal.Object.$$prototype[old_id]
</code></pre>

<h2><code>if (body.$$alias_of) body = body.$$alias_of</code></h2>

<p>If the body is itself an alias use the original body
to keep the max depth at 1.</p>

<pre class="code js"><code class="js">if (body.$$alias_of) body = body.$$alias_of;
</code></pre>

<h2><code>alias = function()</code></h2>

<p>We need a wrapper because otherwise properties
would be ovrewritten on the original body.</p>

<pre class="code js"><code class="js">alias = function() {
  var block = alias.$$p, args, i, ii;

  args = new Array(arguments.length);
  for(i = 0, ii = arguments.length; i &lt; ii; i++) {
    args[i] = arguments[i];
  }

  if (block != null) { alias.$$p = null }

  return Opal.send(this, body, args, block);
};
</code></pre>

<h2><code>alias.displayName       = name</code></h2>

<p>Try to make the browser pick the right name</p>

<pre class="code js"><code class="js">alias.displayName       = name;
</code></pre>

<h2>``</h2>

<h2>Hashes</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.hash2 = function(keys, smap)</code></h2>

<p>A faster Hash creator for hashes that just use symbols and
strings as keys. The map and keys array can be constructed at
compile time, so they are just added here by the constructor
function.</p>

<pre class="code js"><code class="js">Opal.hash2 = function(keys, smap) {
  var hash = new Opal.Hash();

  hash.$$smap = smap;
  hash.$$map  = Object.create(null);
  hash.$$keys = keys;

  return hash;
};
</code></pre>

<h2><code>Opal.range = function(first, last, exc)</code></h2>

<p>Create a new range instance with first and last values, and whether the
range excludes the last value.</p>

<pre class="code js"><code class="js">Opal.range = function(first, last, exc) {
  var range         = new Opal.Range();
      range.begin   = first;
      range.end     = last;
      range.excl    = exc;

  return range;
};
</code></pre>

<h2><code>Opal.ivar = function(name)</code></h2>

<p>Get the ivar name for a given name.
Mostly adds a trailing $ to reserved names.</p>

<pre class="code js"><code class="js">Opal.ivar = function(name) {
  if (
      // properties
      name === &quot;constructor&quot; ||
      name === &quot;displayName&quot; ||
      name === &quot;__count__&quot; ||
      name === &quot;__noSuchMethod__&quot; ||
      name === &quot;__parent__&quot; ||
      name === &quot;__proto__&quot; ||

      // methods
      name === &quot;hasOwnProperty&quot; ||
      name === &quot;valueOf&quot;
     )
  {
    return name + &quot;$&quot;;
  }

  return name;
};
</code></pre>

<h2>``</h2>

<h2>Regexps</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>Opal.escape_regexp = function(str)</code></h2>

<p>Escape Regexp special chars letting the resulting string be used to build
a new Regexp.</p>

<pre class="code js"><code class="js">Opal.escape_regexp = function(str) {
  return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, &#39;\\$1&#39;)
            .replace(/[\n]/g, &#39;\\n&#39;)
            .replace(/[\r]/g, &#39;\\r&#39;)
            .replace(/[\f]/g, &#39;\\f&#39;)
            .replace(/[\t]/g, &#39;\\t&#39;);
};
</code></pre>

<h2><code>Opal.global_regexp = function(pattern)</code></h2>

<p>Create a global Regexp from a RegExp object and cache the result
on the object itself ($$g attribute).</p>

<pre class="code js"><code class="js">Opal.global_regexp = function(pattern) {
  if (pattern.global) {
    return pattern; // RegExp already has the global flag
  }
  if (pattern.$$g == null) {
    pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? &#39;gm&#39; : &#39;g&#39;) + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
  } else {
    pattern.$$g.lastIndex = null; // reset lastIndex property
  }
  return pattern.$$g;
};
</code></pre>

<h2><code>Opal.global_multiline_regexp = function(pattern)</code></h2>

<p>Create a global multiline Regexp from a RegExp object and cache the result
on the object itself ($$gm or $$g attribute).</p>

<pre class="code js"><code class="js">Opal.global_multiline_regexp = function(pattern) {
  var result;
  if (pattern.multiline) {
    if (pattern.global) {
      return pattern; // RegExp already has the global and multiline flag
    }
    // we are using the $$g attribute because the Regexp is already multiline
    if (pattern.$$g != null) {
      result = pattern.$$g;
    } else {
      result = pattern.$$g = new RegExp(pattern.source, &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
    }
  } else if (pattern.$$gm != null) {
    result = pattern.$$gm;
  } else {
    result = pattern.$$gm = new RegExp(pattern.source, &#39;gm&#39; + (pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;));
  }
  result.lastIndex = null; // reset lastIndex property
  return result;
};
</code></pre>

<h2>``</h2>

<h2>Require system</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>function $BasicObject() {}</code></h2>

<h2>Initialization</h2>

<pre class="code js"><code class="js">function $BasicObject() {}
</code></pre>

<h2><code>BasicObject.$$const[&quot;BasicObject&quot;] = BasicObject</code></h2>

<p>BasicObject can reach itself, avoid const_set to skip the $$base_module logic</p>

<pre class="code js"><code class="js">BasicObject.$$const[&quot;BasicObject&quot;] = BasicObject;
</code></pre>

<h2><code>Opal.const_set(_Object, &quot;BasicObject&quot;,  BasicObject)</code></h2>

<p>Assign basic constants</p>

<pre class="code js"><code class="js">Opal.const_set(_Object, &quot;BasicObject&quot;,  BasicObject);
</code></pre>

<h2><code>BasicObject.$$class = Class</code></h2>

<p>Fix booted classes to have correct .class value</p>

<pre class="code js"><code class="js">BasicObject.$$class = Class;
</code></pre>

<h2><code>$defineProperty(_Object.$$prototype, &#39;toString&#39;, function()</code></h2>

<p>Forward .toString() to #to_s</p>

<pre class="code js"><code class="js">$defineProperty(_Object.$$prototype, &#39;toString&#39;, function() {
  var to_s = this.$to_s();
  if (to_s.$$is_string &amp;&amp; typeof(to_s) === &#39;object&#39;) {
    // a string created using new String(&#39;string&#39;)
    return to_s.valueOf();
  } else {
    return to_s;
  }
});
</code></pre>

<h2><code>$defineProperty(_Object.$$prototype, &#39;$require&#39;, Opal.require)</code></h2>

<p>Make Kernel#require immediately available as it&#39;s needed to require all the
other corelib files.</p>

<pre class="code js"><code class="js">$defineProperty(_Object.$$prototype, &#39;$require&#39;, Opal.require);
</code></pre>

<h2><code>Opal.$$ = _Object.$$</code></h2>

<p>Add a short helper to navigate constants manually.
@example
  Opal.$$.Regexp.$$.IGNORECASE</p>

<pre class="code js"><code class="js">Opal.$$ = _Object.$$;
</code></pre>

<h2><code>Opal.top = new _Object()</code></h2>

<p>Instantiate the main object</p>

<pre class="code js"><code class="js">Opal.top = new _Object();
</code></pre>

<h2><code>function $NilClass() {}</code></h2>

<p>Nil</p>

<pre class="code js"><code class="js">function $NilClass() {}
</code></pre>

<h2><code>Opal.breaker  = new Error(&#39;unexpected break (old)&#39;)</code></h2>

<p>Errors</p>

<pre class="code js"><code class="js">Opal.breaker  = new Error(&#39;unexpected break (old)&#39;);
</code></pre>
</div></div>

      <div id="footer">
  Generated on 02/02/20 by
  <!-- <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a> -->
  0.9.9 (ruby-2.6.3).
</div>

    </div>
  </body>
</html>