<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: RUNTIME
  
    &mdash; corelib (Opal v0.6.3)
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  pathId = "RUNTIME";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  <span class="title"><a href="/docs">Opal Docs</a></span>
  
    &raquo;
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: RUNTIME</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1>runtime.js</h1>

<h2><code>Opal = this.Opal = {}</code></h2>

<p>The Opal object that is exposed globally</p>

<pre class="code js"><code class="js">var Opal = this.Opal = {};
</code></pre>

<h2><code>RubyBasicObject</code></h2>

<p>The actual class for BasicObject</p>

<pre class="code js"><code class="js">var RubyBasicObject;
</code></pre>

<h2><code>RubyObject</code></h2>

<p>The actual Object class</p>

<pre class="code js"><code class="js">var RubyObject;
</code></pre>

<h2><code>RubyModule</code></h2>

<p>The actual Module class</p>

<pre class="code js"><code class="js">var RubyModule;
</code></pre>

<h2><code>RubyClass</code></h2>

<p>The actual Class class</p>

<pre class="code js"><code class="js">var RubyClass;
</code></pre>

<h2>function: <code>BasicObject()</code></h2>

<p>Constructor for instances of BasicObject</p>

<pre class="code js"><code class="js">function BasicObject(){}
</code></pre>

<h2>function: <code>Object()</code></h2>

<p>Constructor for instances of Object</p>

<pre class="code js"><code class="js">function Object(){}
</code></pre>

<h2>function: <code>Class()</code></h2>

<p>Constructor for instances of Class</p>

<pre class="code js"><code class="js">function Class(){}
</code></pre>

<h2>function: <code>Module()</code></h2>

<p>Constructor for instances of Module</p>

<pre class="code js"><code class="js">function Module(){}
</code></pre>

<h2>function: <code>NilClass()</code></h2>

<p>Constructor for instances of NilClass (nil)</p>

<pre class="code js"><code class="js">function NilClass(){}
</code></pre>

<h2><code>bridged_classes = []</code></h2>

<p>All bridged classes - keep track to donate methods from Object</p>

<pre class="code js"><code class="js">var bridged_classes = [];
</code></pre>

<h2><code>TopScope = function(){}</code></h2>

<p>TopScope is used for inheriting constants from the top scope</p>

<pre class="code js"><code class="js">var TopScope = function(){};
</code></pre>

<h2><code>TopScope.prototype = Opal</code></h2>

<p>Opal just acts as the top scope</p>

<pre class="code js"><code class="js">TopScope.prototype = Opal;
</code></pre>

<h2><code>Opal.constructor  = TopScope</code></h2>

<p>To inherit scopes</p>

<pre class="code js"><code class="js">Opal.constructor  = TopScope;
</code></pre>

<h2><code>Opal.global = this</code></h2>

<p>This is a useful reference to global object inside ruby files</p>

<pre class="code js"><code class="js">Opal.global = this;
</code></pre>

<h2><code>$hasOwn = Opal.hasOwnProperty</code></h2>

<p>Minify common function calls</p>

<pre class="code js"><code class="js">var $hasOwn = Opal.hasOwnProperty;
</code></pre>

<h2><code>unique_id = 0</code></h2>

<p>Generates unique id for every ruby object</p>

<pre class="code js"><code class="js">var unique_id = 0;
</code></pre>

<h2><code>Opal.uid = function()</code></h2>

<p>Return next unique id</p>

<pre class="code js"><code class="js">Opal.uid = function() {
  return unique_id++;
};
</code></pre>

<h2><code>Opal.cvars = {}</code></h2>

<p>Table holds all class variables</p>

<pre class="code js"><code class="js">Opal.cvars = {};
</code></pre>

<h2><code>Opal.gvars = {}</code></h2>

<p>Globals table</p>

<pre class="code js"><code class="js">Opal.gvars = {};
</code></pre>

<h2><code>function create_scope(base, klass, id)</code></h2>

<p>Create a new constants scope for the given class with the given
base. Constants are looked up through their parents, so the base
scope will be the outer scope of the new klass.</p>

<pre class="code js"><code class="js">function create_scope(base, klass, id) {
  var const_alloc   = function() {};
  var const_scope   = const_alloc.prototype = new base.constructor();
  klass._scope      = const_scope;
  const_scope.base  = klass;
  klass._base_module = base.base;
  const_scope.constructor = const_alloc;
  const_scope.constants = [];

  if (id) {
    klass._orig_scope = base;
    base[id] = base.constructor[id] = klass;
    base.constants.push(id);
  }
}
</code></pre>

<h2><code>Opal.klass = function(base, superklass, id, constructor)</code></h2>

<p>A <code>class Foo; end</code> expression in ruby is compiled to call this runtime
method which either returns an existing class of the given name, or creates
a new class in the given <code>base</code> scope.
*
If a constant with the given name exists, then we check to make sure that
it is a class and also that the superclasses match. If either of these
fail, then we raise a <code>TypeError</code>. Note, superklass may be null if one was
not specified in the ruby code.
*
We pass a constructor to this method of the form <code>function ClassName() {}</code>
simply so that classes show up with nicely formatted names inside debuggers
in the web browser (or node/sprockets).
*
The <code>base</code> is the current <code>self</code> value where the class is being created
from. We use this to get the scope for where the class should be created.
If <code>base</code> is an object (not a class/module), we simple get its class and
use that as the base instead.
*
@param [Object] base where the class is being created
@param [Class] superklass superclass of the new class (may be null)
@param [String] id the name of the class to be created
@param [Function] constructor function to use as constructor
@return [Class] new or existing ruby class</p>

<pre class="code js"><code class="js">Opal.klass = function(base, superklass, id, constructor) {

  // If base is an object, use its class
  if (!base._isClass) {
    base = base._klass;
  }

  // Not specifying a superclass means we can assume it to be Object
  if (superklass === null) {
    superklass = RubyObject;
  }

  var klass = base._scope[id];

  // If a constant exists in the scope, then we must use that
  if ($hasOwn.call(base._scope, id) &amp;&amp; klass._orig_scope === base._scope) {

    // Make sure the existing constant is a class, or raise error
    if (!klass._isClass) {
      throw Opal.TypeError.$new(id + &quot; is not a class&quot;);
    }

    // Make sure existing class has same superclass
    if (superklass !== klass._super &amp;&amp; superklass !== RubyObject) {
      throw Opal.TypeError.$new(&quot;superclass mismatch for class &quot; + id);
    }
  }
  else if (typeof(superklass) === &#39;function&#39;) {
    // passed native constructor as superklass, so bridge it as ruby class
    return bridge_class(id, superklass);
  }
  else {
    // if class doesnt exist, create a new one with given superclass
    klass = boot_class(superklass, constructor);

    // name class using base (e.g. Foo or Foo::Baz)
    klass._name = id;

    // every class gets its own constant scope, inherited from current scope
    create_scope(base._scope, klass, id);

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    base[id] = base._scope[id] = klass;

    // Copy all parent constants to child, unless parent is Object
    if (superklass !== RubyObject &amp;&amp; superklass !== RubyBasicObject) {
      Opal.donate_constants(superklass, klass);
    }

    // call .inherited() hook with new class on the superclass
    if (superklass.$inherited) {
      superklass.$inherited(klass);
    }
  }

  return klass;
};
</code></pre>

<h2><code>boot_class = Opal.boot = function(superklass, constructor)</code></h2>

<p>Create generic class with given superclass.</p>

<pre class="code js"><code class="js">var boot_class = Opal.boot = function(superklass, constructor) {
  // instances
  var ctor = function() {};
      ctor.prototype = superklass._proto;

  constructor.prototype = new ctor();

  constructor.prototype.constructor = constructor;

  return boot_class_meta(superklass, constructor);
};
</code></pre>

<h2><code>function boot_class_meta(superklass, constructor)</code></h2>

<p>class itself</p>

<pre class="code js"><code class="js">function boot_class_meta(superklass, constructor) {
  var mtor = function() {};
  mtor.prototype = superklass.constructor.prototype;

  function OpalClass() {};
  OpalClass.prototype = new mtor();

  var klass = new OpalClass();

  klass._id         = unique_id++;
  klass._alloc      = constructor;
  klass._isClass    = true;
  klass.constructor = OpalClass;
  klass._super      = superklass;
  klass._methods    = [];
  klass.__inc__     = [];
  klass.__parent    = superklass;
  klass._proto      = constructor.prototype;

  constructor.prototype._klass = klass;

  return klass;
}
</code></pre>

<h2><code>Opal.module = function(base, id)</code></h2>

<p>Define new module (or return existing module)</p>

<pre class="code js"><code class="js">Opal.module = function(base, id) {
  var module;

  if (!base._isClass) {
    base = base._klass;
  }

  if ($hasOwn.call(base._scope, id)) {
    module = base._scope[id];

    if (!module.__mod__ &amp;&amp; module !== RubyObject) {
      throw Opal.TypeError.$new(id + &quot; is not a module&quot;)
    }
  }
  else {
    module = boot_module()
    module._name = id;

    create_scope(base._scope, module, id);

    // Name new module directly onto current scope (Opal.Foo.Baz = module)
    base[id] = base._scope[id] = module;
  }

  return module;
};
</code></pre>

<h2><code>function boot_module()</code></h2>

<p>Internal function to create a new module instance. This simply sets up
the prototype hierarchy and method tables.</p>

<pre class="code js"><code class="js">function boot_module() {
  var mtor = function() {};
  mtor.prototype = RubyModule.constructor.prototype;

  function OpalModule() {};
  OpalModule.prototype = new mtor();

  var module = new OpalModule();

  module._id         = unique_id++;
  module._isClass    = true;
  module.constructor = OpalModule;
  module._super      = RubyModule;
  module._methods    = [];
  module.__inc__     = [];
  module.__parent    = RubyModule;
  module._proto      = {};
  module.__mod__     = true;
  module.__dep__     = [];

  return module;
}
</code></pre>

<h2><code>boot_defclass = function(id, constructor, superklass)</code></h2>

<p>Boot a base class (makes instances).</p>

<pre class="code js"><code class="js">var boot_defclass = function(id, constructor, superklass) {
  if (superklass) {
    var ctor           = function() {};
        ctor.prototype = superklass.prototype;

    constructor.prototype = new ctor();
  }

  constructor.prototype.constructor = constructor;

  return constructor;
};
</code></pre>

<h2><code>boot_makemeta = function(id, constructor, superklass)</code></h2>

<p>Boot the actual (meta?) classes of core classes</p>

<pre class="code js"><code class="js">var boot_makemeta = function(id, constructor, superklass) {

  var mtor = function() {};
  mtor.prototype  = superklass.prototype;

  function OpalClass() {};
  OpalClass.prototype = new mtor();

  var klass = new OpalClass();

  klass._id         = unique_id++;
  klass._alloc      = constructor;
  klass._isClass    = true;
  klass._name       = id;
  klass._super      = superklass;
  klass.constructor = OpalClass;
  klass._methods    = [];
  klass.__inc__     = [];
  klass.__parent    = superklass;
  klass._proto      = constructor.prototype;

  constructor.prototype._klass = klass;

  Opal[id] = klass;
  Opal.constants.push(id);

  return klass;
};
</code></pre>

<h2><code>function bridge_class(name, constructor)</code></h2>

<p>For performance, some core ruby classes are toll-free bridged to their
native javascript counterparts (e.g. a ruby Array is a javascript Array).
*
This method is used to setup a native constructor (e.g. Array), to have
its prototype act like a normal ruby class. Firstly, a new ruby class is
created using the native constructor so that its prototype is set as the
target for th new class. Note: all bridged classes are set to inherit
from Object.
*
Bridged classes are tracked in <code>bridged_classes</code> array so that methods
defined on Object can be &quot;donated&quot; to all bridged classes. This allows
us to fake the inheritance of a native prototype from our Object
prototype.
*
Example:
*
   bridge_class(&quot;Proc&quot;, Function);
*
@param [String] name the name of the ruby class to create
@param [Function] constructor native javascript constructor to use
@return [Class] returns new ruby class</p>

<pre class="code js"><code class="js">function bridge_class(name, constructor) {
  var klass = boot_class_meta(RubyObject, constructor);

  klass._name = name;

  create_scope(Opal, klass, name);
  bridged_classes.push(klass);

  var object_methods = RubyBasicObject._methods.concat(RubyObject._methods);

  for (var i = 0, len = object_methods.length; i &lt; len; i++) {
    var meth = object_methods[i];
    constructor.prototype[meth] = RubyObject._proto[meth];
  }

  return klass;
};
</code></pre>

<h2><code>Opal.casgn = function(base_module, name, value)</code></h2>

<p>constant assign</p>

<pre class="code js"><code class="js">Opal.casgn = function(base_module, name, value) {
  var scope = base_module._scope;

  if (value._isClass &amp;&amp; value._name === nil) {
    value._name = name;
  }

  if (value._isClass) {
    value._base_module = base_module;
  }

  scope.constants.push(name);
  return scope[name] = value;
};
</code></pre>

<h2><code>Opal.cdecl = function(base_scope, name, value)</code></h2>

<p>constant decl</p>

<pre class="code js"><code class="js">Opal.cdecl = function(base_scope, name, value) {
  base_scope.constants.push(name);
  return base_scope[name] = value;
};
</code></pre>

<h2><code>Opal.cget = function(base_scope, path)</code></h2>

<p>constant get</p>

<pre class="code js"><code class="js">Opal.cget = function(base_scope, path) {
  if (path == null) {
    path       = base_scope;
    base_scope = Opal.Object;
  }

  var result = base_scope;

  path = path.split(&#39;::&#39;);
  while (path.length != 0) {
    result = result.$const_get(path.shift());
  }

  return result;
}
</code></pre>

<h2><code>Opal.donate_constants = function(source_mod, target_mod)</code></h2>

<p>When a source module is included into the target module, we must also copy
its constants to the target.</p>

<pre class="code js"><code class="js">Opal.donate_constants = function(source_mod, target_mod) {
  var source_constants = source_mod._scope.constants,
      target_scope     = target_mod._scope,
      target_constants = target_scope.constants;

  for (var i = 0, length = source_constants.length; i &lt; length; i++) {
    target_constants.push(source_constants[i]);
    target_scope[source_constants[i]] = source_mod._scope[source_constants[i]];
  }
};
</code></pre>

<h2><code>Opal.add_stubs = function(stubs)</code></h2>

<p>Methods stubs are used to facilitate method_missing in opal. A stub is a
placeholder function which just calls <code>method_missing</code> on the receiver.
If no method with the given name is actually defined on an object, then it
is obvious to say that the stub will be called instead, and then in turn
method_missing will be called.
*
When a file in ruby gets compiled to javascript, it includes a call to
this function which adds stubs for every method name in the compiled file.
It should then be safe to assume that method_missing will work for any
method call detected.
*
Method stubs are added to the BasicObject prototype, which every other
ruby object inherits, so all objects should handle method missing. A stub
is only added if the given property name (method name) is not already
defined.
*
Note: all ruby methods have a <code>$</code> prefix in javascript, so all stubs will
have this prefix as well (to make this method more performant).
*
   Opal.add_stubs([&quot;$foo&quot;, &quot;$bar&quot;, &quot;$baz=&quot;]);
*
All stub functions will have a private <code>rb_stub</code> property set to true so
that other internal methods can detect if a method is just a stub or not.
<code>Kernel#respond_to?</code> uses this property to detect a methods presence.
*
@param [Array] stubs an array of method stubs to add</p>

<pre class="code js"><code class="js">Opal.add_stubs = function(stubs) {
  for (var i = 0, length = stubs.length; i &lt; length; i++) {
    var stub = stubs[i];

    if (!BasicObject.prototype[stub]) {
      BasicObject.prototype[stub] = true;
      add_stub_for(BasicObject.prototype, stub);
    }
  }
};
</code></pre>

<h2><code>function add_stub_for(prototype, stub)</code></h2>

<p>Actuall add a method_missing stub function to the given prototype for the
given name.
*
@param [Prototype] prototype the target prototype
@param [String] stub stub name to add (e.g. &quot;$foo&quot;)</p>

<pre class="code js"><code class="js">function add_stub_for(prototype, stub) {
  function method_missing_stub() {
    // Copy any given block onto the method_missing dispatcher
    this.$method_missing._p = method_missing_stub._p;

    // Set block property to null ready for the next call (stop false-positives)
    method_missing_stub._p = null;

    // call method missing with correct args (remove &#39;$&#39; prefix on method name)
    return this.$method_missing.apply(this, [stub.slice(1)].concat($slice.call(arguments)));
  }

  method_missing_stub.rb_stub = true;
  prototype[stub] = method_missing_stub;
}
</code></pre>

<h2><code>Opal.add_stub_for = add_stub_for</code></h2>

<p>Expose for other parts of Opal to use</p>

<pre class="code js"><code class="js">Opal.add_stub_for = add_stub_for;
</code></pre>

<h2><code>Opal.cm = function(name)</code></h2>

<p>Const missing dispatcher</p>

<pre class="code js"><code class="js">Opal.cm = function(name) {
  return this.base.$const_missing(name);
};
</code></pre>

<h2><code>Opal.ac = function(actual, expected, object, meth)</code></h2>

<p>Arity count error dispatcher</p>

<pre class="code js"><code class="js">Opal.ac = function(actual, expected, object, meth) {
  var inspect = (object._isClass ? object._name + &#39;.&#39; : object._klass._name + &#39;#&#39;) + meth;
  var msg = &#39;[&#39; + inspect + &#39;] wrong number of arguments(&#39; + actual + &#39; for &#39; + expected + &#39;)&#39;;
  throw Opal.ArgumentError.$new(msg);
};
</code></pre>

<h2><code>Opal.find_super_dispatcher = function(obj, jsid, current_func, iter, defs)</code></h2>

<p>Super dispatcher</p>

<pre class="code js"><code class="js">Opal.find_super_dispatcher = function(obj, jsid, current_func, iter, defs) {
  var dispatcher;

  if (defs) {
    dispatcher = obj._isClass ? defs._super : obj._klass._proto;
  }
  else {
    if (obj._isClass) {
      dispatcher = obj._super;
    }
    else {
      dispatcher = find_obj_super_dispatcher(obj, jsid, current_func);
    }
  }

  dispatcher = dispatcher[&#39;$&#39; + jsid];
  dispatcher._p = iter;

  return dispatcher;
};
</code></pre>

<h2><code>Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, iter, defs)</code></h2>

<p>Iter dispatcher for super in a block</p>

<pre class="code js"><code class="js">Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, iter, defs) {
  if (current_func._def) {
    return Opal.find_super_dispatcher(obj, current_func._jsid, current_func, iter, defs);
  }
  else {
    return Opal.find_super_dispatcher(obj, jsid, current_func, iter, defs);
  }
};
</code></pre>

<h2><code>break</code></h2>

<p>ok</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2><code>if (!klass)</code></h2>

<p>if we arent in a class, we couldnt find current?</p>

<pre class="code js"><code class="js">if (!klass) {
</code></pre>

<h2><code>while (klass)</code></h2>

<p>else, let&#39;s find the next one</p>

<pre class="code js"><code class="js">while (klass) {
</code></pre>

<h2><code>break</code></h2>

<p>ok</p>

<pre class="code js"><code class="js">break;
</code></pre>

<h2><code>Opal.$return = function(val)</code></h2>

<p>Used to return as an expression. Sometimes, we can&#39;t simply return from
a javascript function as if we were a method, as the return is used as
an expression, or even inside a block which must &quot;return&quot; to the outer
method. This helper simply throws an error which is then caught by the
method. This approach is expensive, so it is only used when absolutely
needed.</p>

<pre class="code js"><code class="js">Opal.$return = function(val) {
  Opal.returner.$v = val;
  throw Opal.returner;
};
</code></pre>

<h2><code>Opal.$yield1 = function(block, arg)</code></h2>

<p>handles yield calls for 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.$yield1 = function(block, arg) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  if (block.length &gt; 1) {
    if (arg._isArray) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  }
  else {
    return block(arg);
  }
};
</code></pre>

<h2><code>Opal.$yieldX = function(block, args)</code></h2>

<p>handles yield for &gt; 1 yielded arg</p>

<pre class="code js"><code class="js">Opal.$yieldX = function(block, args) {
  if (typeof(block) !== &quot;function&quot;) {
    throw Opal.LocalJumpError.$new(&quot;no block given&quot;);
  }

  if (block.length &gt; 1 &amp;&amp; args.length == 1) {
    if (args[0]._isArray) {
      return block.apply(null, args[0]);
    }
  }

  if (!args._isArray) {
    args = $slice.call(args);
  }

  return block.apply(null, args);
};
</code></pre>

<h2><code>Opal.$rescue = function(exception, candidates)</code></h2>

<p>Finds the corresponding exception match in candidates.  Each candidate can
be a value, or an array of values.  Returns null if not found.</p>

<pre class="code js"><code class="js">Opal.$rescue = function(exception, candidates) {
  for (var i = 0; i != candidates.length; i++) {
    var candidate = candidates[i];
    if (candidate._isArray) {
      var subresult;
      if (subresult = Opal.$rescue(exception, candidate)) {
        return subresult;
      }
    }
    else if (candidate[&#39;$===&#39;](exception)) {
      return candidate;
    }
  }
  return null;
};
</code></pre>

<h2><code>Opal.to_ary = function(value)</code></h2>

<p>Helper to convert the given object to an array</p>

<pre class="code js"><code class="js">Opal.to_ary = function(value) {
  if (value._isArray) {
    return value;
  }
  else if (value.$to_ary &amp;&amp; !value.$to_ary.rb_stub) {
    return value.$to_ary();
  }

  return [value];
};
</code></pre>

<h2><code>Opal.send = function(recv, mid)</code></h2>

<p>Call a ruby method on a ruby object with some arguments:</p>

<p>var my_array = [1, 2, 3, 4]
Opal.send(my_array, &#39;length&#39;)     # =&gt; 4
Opal.send(my_array, &#39;reverse!&#39;)   # =&gt; [4, 3, 2, 1]</p>

<p>A missing method will be forwarded to the object via
method_missing.</p>

<p>The result of either call with be returned.</p>

<p>@param [Object] recv the ruby object
@param [String] mid ruby method to call</p>

<pre class="code js"><code class="js">Opal.send = function(recv, mid) {
  var args = $slice.call(arguments, 2),
      func = recv[&#39;$&#39; + mid];

  if (func) {
    return func.apply(recv, args);
  }

  return recv.$method_missing.apply(recv, [mid].concat(args));
};
</code></pre>

<h2><code>Opal.donate = function(klass, defined, indirect)</code></h2>

<p>Donate methods for a class/module</p>

<pre class="code js"><code class="js">Opal.donate = function(klass, defined, indirect) {
  var methods = klass._methods, included_in = klass.__dep__;

  // if (!indirect) {
    klass._methods = methods.concat(defined);
  // }

  if (included_in) {
    for (var i = 0, length = included_in.length; i &lt; length; i++) {
      var includee = included_in[i];
      var dest = includee._proto;

      for (var j = 0, jj = defined.length; j &lt; jj; j++) {
        var method = defined[j];
        dest[method] = klass._proto[method];
        dest[method]._donated = true;
      }

      if (includee.__dep__) {
        Opal.donate(includee, defined, true);
      }
    }
  }
};
</code></pre>

<h2><code>Opal.defs = function(obj, jsid, body)</code></h2>

<p>Define a singleton method on the given object.</p>

<pre class="code js"><code class="js">Opal.defs = function(obj, jsid, body) {
  if (obj._isClass || obj.__mod__) {
    obj.constructor.prototype[jsid] = body;
  }
  else {
    obj[jsid] = body;
  }
};
</code></pre>

<h2><code>Opal.hash2 = function(keys, map)</code></h2>

<p>hash2 is a faster creator for hashes that just use symbols and
strings as keys. The map and keys array can be constructed at
compile time, so they are just added here by the constructor
function</p>

<pre class="code js"><code class="js">Opal.hash2 = function(keys, map) {
  var hash = new Opal.Hash._alloc;

  hash.keys = keys;
  hash.map  = map;

  return hash;
};
</code></pre>

<h2><code>Opal.range = function(first, last, exc)</code></h2>

<p>Create a new range instance with first and last values, and whether the
range excludes the last value.</p>

<pre class="code js"><code class="js">Opal.range = function(first, last, exc) {
  var range         = new Opal.Range._alloc;
      range.begin   = first;
      range.end     = last;
      range.exclude = exc;

  return range;
};
</code></pre>

<h2>``</h2>

<h2>Initialization</h2>

<pre class="code js"><code class="js">
</code></pre>

<h2><code>boot_defclass(&#39;BasicObject&#39;, BasicObject)</code></h2>

<p>Constructors for <em>instances</em> of core objects</p>

<pre class="code js"><code class="js">boot_defclass(&#39;BasicObject&#39;, BasicObject);
</code></pre>

<h2><code>RubyBasicObject = boot_makemeta(&#39;BasicObject&#39;, BasicObject, Class)</code></h2>

<p>Constructors for <em>classes</em> of core objects</p>

<pre class="code js"><code class="js">RubyBasicObject = boot_makemeta(&#39;BasicObject&#39;, BasicObject, Class);
</code></pre>

<h2><code>RubyBasicObject._klass = RubyClass</code></h2>

<p>Fix booted classes to use their metaclass</p>

<pre class="code js"><code class="js">RubyBasicObject._klass = RubyClass;
</code></pre>

<h2><code>RubyBasicObject._super = null</code></h2>

<p>Fix superclasses of booted classes</p>

<pre class="code js"><code class="js">RubyBasicObject._super = null;
</code></pre>

<h2><code>RubyObject.__dep__ = bridged_classes</code></h2>

<p>Internally, Object acts like a module as it is &quot;included&quot; into bridged
classes. In other words, we donate methods from Object into our bridged
classes as their prototypes don&#39;t inherit from our root Object, so they
act like module includes.</p>

<pre class="code js"><code class="js">RubyObject.__dep__ = bridged_classes;
</code></pre>
</div></div>

      <div id="footer">
  Generated on 03/13/18 by
  <!-- <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a> -->
  0.9.9 (ruby-2.5.0).
</div>

    </div>
  </body>
</html>