Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $truthy = Opal.truthy, $module = Opal.module, $eqeq = Opal.eqeq, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('=~,require,raise,==');
  
  if ($truthy($$('RUBY_VERSION')['$=~'](/^1\.[89]\./))) {
    
    self.$require("parser/version");
    self.$raise($$('LoadError'), "parser v" + ($$$($$('Parser'), 'VERSION')) + " cannot run on Ruby " + ($$('RUBY_VERSION')) + ".\n" + "Please upgrade to Ruby 2.0.0 or higher, or use an older version of the parser gem.\n");
  };
  self.$require("set");
  self.$require("racc/parser");
  self.$require("ast");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$require("parser/version");
    self.$require("parser/messages");
    self.$require("parser/deprecation");
    (function($base) {
      var self = $module($base, 'AST');

      
      
      self.$require("parser/ast/node");
      self.$require("parser/ast/processor");
      return self.$require("parser/meta");
    })($nesting[0]);
    (function($base) {
      var self = $module($base, 'Source');

      
      
      self.$require("parser/source/buffer");
      self.$require("parser/source/range");
      self.$require("parser/source/comment");
      self.$require("parser/source/comment/associator");
      self.$require("parser/source/rewriter");
      self.$require("parser/source/rewriter/action");
      self.$require("parser/source/tree_rewriter");
      self.$require("parser/source/tree_rewriter/action");
      self.$require("parser/source/map");
      self.$require("parser/source/map/operator");
      self.$require("parser/source/map/collection");
      self.$require("parser/source/map/constant");
      self.$require("parser/source/map/variable");
      self.$require("parser/source/map/keyword");
      self.$require("parser/source/map/definition");
      self.$require("parser/source/map/method_definition");
      self.$require("parser/source/map/send");
      self.$require("parser/source/map/index");
      self.$require("parser/source/map/condition");
      self.$require("parser/source/map/ternary");
      self.$require("parser/source/map/for");
      self.$require("parser/source/map/rescue_body");
      self.$require("parser/source/map/heredoc");
      return self.$require("parser/source/map/objc_kwarg");
    })($nesting[0]);
    self.$require("parser/syntax_error");
    self.$require("parser/clobbering_error");
    self.$require("parser/diagnostic");
    self.$require("parser/diagnostic/engine");
    self.$require("parser/static_environment");
    if ($eqeq($$('RUBY_ENGINE'), "truffleruby")) {
      self.$require("parser/lexer-F0")
    } else {
      self.$require("parser/lexer-F1")
    };
    self.$require("parser/lexer-strings");
    self.$require("parser/lexer/literal");
    self.$require("parser/lexer/stack_state");
    self.$require("parser/lexer/dedenter");
    (function($base) {
      var self = $module($base, 'Builders');

      
      return self.$require("parser/builders/default")
    })($nesting[0]);
    self.$require("parser/context");
    self.$require("parser/max_numparam_stack");
    self.$require("parser/current_arg_stack");
    self.$require("parser/variables_stack");
    self.$require("parser/base");
    self.$require("parser/rewriter");
    return self.$require("parser/tree_rewriter");
  })($nesting[0], $nesting);
});
