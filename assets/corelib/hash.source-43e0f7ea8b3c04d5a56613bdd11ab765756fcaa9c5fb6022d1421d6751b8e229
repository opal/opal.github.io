Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $yield1 = Opal.yield1, $hash_clone = Opal.hash_clone, $hash_delete = Opal.hash_delete, $hash_each = Opal.hash_each, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $deny_frozen_access = Opal.deny_frozen_access, $freeze = Opal.freeze, $opal32_init = Opal.opal32_init, $opal32_add = Opal.opal32_add, $klass = Opal.klass, $slice = Opal.slice, $Opal = Opal.Opal, $Kernel = Opal.Kernel, $defs = Opal.defs, $def = Opal.def, $send = Opal.send, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $truthy = Opal.truthy, $to_a = Opal.to_a, $return_self = Opal.return_self, $not = Opal.not, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,coerce_to?,[],merge!,allocate,raise,inspect,coerce_to!,each,fetch,>=,>,==,lambda?,abs,arity,enum_for,size,respond_to?,class,dig,except!,dup,delete,new,map,to_proc,flatten,frozen?,eql?,default,default_proc,default_proc=,default=,to_h,proc,!,select,select!,has_key?,indexes,index,length,[]=,has_value?');
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    self.$include($$$('Enumerable'));
    self.$$prototype.$$is_hash = true;
    $defs(self, '$[]', function $Hash_$$$1($a) {
      var $post_args, argv, self = this;

      
      $post_args = $slice(arguments);
      argv = $post_args;
      
      var hash, argc = argv.length, arg, i;

      if (argc === 1) {
        hash = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $Opal['$coerce_to?'](argv['$[]'](0), $$$('Array'), "to_ary");
        if (argv === nil) {
          $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash");
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          arg = argv[i];
          if (!arg.$$is_array)
            $Kernel.$raise($$$('ArgumentError'), "invalid element " + ((arg).$inspect()) + " for Hash");
          if (arg.length === 1) {
            hash.$store(arg[0], nil);
          } else if (arg.length === 2) {
            hash.$store(arg[0], arg[1]);
          } else {
            $Kernel.$raise($$$('ArgumentError'), "invalid number of elements (" + (arg.length) + " for " + ((arg).$inspect()) + "), must be 1..2");
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        $Kernel.$raise($$$('ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, -1);
    $defs(self, '$allocate', function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    });
    $defs(self, '$try_convert', function $$try_convert(obj) {
      
      return $Opal['$coerce_to?'](obj, $$$('Hash'), "to_hash")
    });
    
    $def(self, '$initialize', function $$initialize(defaults) {
      var block = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      ;
      ;
      
      $deny_frozen_access(self);

      if (defaults !== undefined && block !== nil) {
        $Kernel.$raise($$$('ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, -1);
    
    $def(self, '$==', function $Hash_$eq_eq$2(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.size !== other.size) {
        return false;
      }

      return $hash_each(self, true, function(key, value) {
        var other_value = $hash_get(other, key);
        if (other_value === undefined || !value['$eql?'](other_value)) {
          return [true, false];
        }
        return [false, true];
      });
    
    });
    
    $def(self, '$>=', function $Hash_$gt_eq$3(other) {
      var self = this, result = nil;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size < other.size) {
        return false;
      }
    ;
      result = true;
      $send(other, 'each', [], function $$4(other_key, other_val){var self = $$4.$$s == null ? this : $$4.$$s, val = nil;

        
        if (other_key == null) other_key = nil;
        if (other_val == null) other_val = nil;
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, {$$s: self});
      return result;
    });
    
    $def(self, '$>', function $Hash_$gt$5(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      if (self.size <= other.size) {
        return false;
      }
    ;
      return $rb_ge(self, other);
    });
    
    $def(self, '$<', function $Hash_$lt$6(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_gt(other, self);
    });
    
    $def(self, '$<=', function $Hash_$lt_eq$7(other) {
      var self = this;

      
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      return $rb_ge(other, self);
    });
    
    $def(self, '$[]', function $Hash_$$$8(key) {
      var self = this;

      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    });
    
    $def(self, '$[]=', function $Hash_$$$eq$9(key, value) {
      var self = this;

      
      $deny_frozen_access(self);

      $hash_put(self, key, value);
      return value;
    
    });
    
    $def(self, '$assoc', function $$assoc(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((key)['$=='](object)) {
          return [true, [key, value]];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$clear', function $$clear() {
      var self = this;

      
      $deny_frozen_access(self);

      self.clear();
      if (self.$$keys)
        self.$$keys.clear();

      return self;
    
    });
    
    $def(self, '$clone', function $$clone() {
      var self = this;

      
      var hash = self.$class().$new();
      $hash_clone(self, hash);
      return self["$frozen?"]() ? hash.$freeze() : hash;
    
    });
    
    $def(self, '$compact', function $$compact() {
      var self = this;

      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        if (value !== nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash];
      });
    
    });
    
    $def(self, '$compact!', function $Hash_compact$excl$10() {
      var self = this;

      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        if (value === nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    
    });
    
    $def(self, '$compare_by_identity', function $$compare_by_identity() {
      var self = this;

      
      $deny_frozen_access(self);

      if (!self.$$by_identity) {
        self.$$by_identity = true;

        if (self.size !== 0)
          Opal.hash_rehash(self);
      }

      return self;
    
    });
    
    $def(self, '$compare_by_identity?', function $Hash_compare_by_identity$ques$11() {
      var self = this;

      return self.$$by_identity === true;
    });
    
    $def(self, '$default', function $Hash_default$12(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, -1);
    
    $def(self, '$default=', function $Hash_default$eq$13(object) {
      var self = this;

      
      $deny_frozen_access(self);

      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    });
    
    $def(self, '$default_proc', function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    });
    
    $def(self, '$default_proc=', function $Hash_default_proc$eq$14(default_proc) {
      var self = this;

      
      $deny_frozen_access(self);

      var proc = default_proc;

      if (proc !== nil) {
        proc = $Opal['$coerce_to!'](proc, $$$('Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          $Kernel.$raise($$$('TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    });
    
    $def(self, '$delete', function $Hash_delete$15(key) {
      var block = $Hash_delete$15.$$p || nil, self = this;

      $Hash_delete$15.$$p = null;
      
      ;
      
      $deny_frozen_access(self);
      var value = $hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    });
    
    $def(self, '$delete_if', function $$delete_if() {
      var block = $$delete_if.$$p || nil, self = this;

      $$delete_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["delete_if"], function $$16(){var self = $$16.$$s == null ? this : $$16.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$dig', function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      $post_args = $slice(arguments, 1);
      keys = $post_args;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if (!$truthy(item['$respond_to?']("dig"))) {
        $Kernel.$raise($$$('TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', $to_a(keys));
    }, -2);
    
    $def(self, '$dup', function $$dup() {
      var self = this;

      return $hash_clone(self, self.$class().$new());
    });
    
    $def(self, '$each', function $$each() {
      var block = $$each.$$p || nil, self = this;

      $$each.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each"], function $$17(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        $yield1(block, [key, value]);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_key', function $$each_key() {
      var block = $$each_key.$$p || nil, self = this;

      $$each_key.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_key"], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(key);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$each_value', function $$each_value() {
      var block = $$each_value.$$p || nil, self = this;

      $$each_value.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["each_value"], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

          return self.$size()}, {$$s: self})
      };
      
      return $hash_each(self, self, function(key, value) {
        block(value);
        return [false, self];
      });
    ;
    });
    
    $def(self, '$empty?', function $Hash_empty$ques$20() {
      var self = this;

      return self.size === 0;
    });
    
    $def(self, '$except', function $$except($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(self.$dup(), 'except!', $to_a(keys));
    }, -1);
    
    $def(self, '$except!', function $Hash_except$excl$21($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      $send(keys, 'each', [], function $$22(key){var self = $$22.$$s == null ? this : $$22.$$s;

        
        if (key == null) key = nil;
        return self.$delete(key);}, {$$s: self});
      return self;
    }, -1);
    
    $def(self, '$fetch', function $$fetch(key, defaults) {
      var block = $$fetch.$$p || nil, self = this;

      $$fetch.$$p = null;
      
      ;
      ;
      
      var value = $hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return $Kernel.$raise($$$('KeyError').$new("key not found: " + (key.$inspect()), (new Map([["key", key], ["receiver", self]]))));
    }, -2);
    
    $def(self, '$fetch_values', function $$fetch_values($a) {
      var block = $$fetch_values.$$p || nil, $post_args, keys, self = this;

      $$fetch_values.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      keys = $post_args;
      return $send(keys, 'map', [], function $$23(key){var self = $$23.$$s == null ? this : $$23.$$s;

        
        if (key == null) key = nil;
        return $send(self, 'fetch', [key], block.$to_proc());}, {$$s: self});
    }, -1);
    
    $def(self, '$flatten', function $$flatten(level) {
      var self = this;

      
      if (level == null) level = 1;
      level = $Opal['$coerce_to!'](level, $$$('Integer'), "to_int");
      
      var result = [];

      return $hash_each(self, result, function(key, value) {
        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            return [false, result];
          }

          result = result.concat((value).$flatten(level - 2));
          return [false, result];
        }

        result.push(value);
        return [false, result];
      });
    ;
    }, -1);
    
    $def(self, '$freeze', function $$freeze() {
      var self = this;

      
      if ($truthy(self['$frozen?']())) {
        return self
      };
      return $freeze(self);;
    });
    
    $def(self, '$has_key?', function $Hash_has_key$ques$24(key) {
      var self = this;

      return $hash_get(self, key) !== undefined;
    });
    
    $def(self, '$has_value?', function $Hash_has_value$ques$25(value) {
      var self = this;

      
      return $hash_each(self, false, function(key, val) {
        if ((val)['$=='](value)) {
          return [true, true];
        }
        return [false, false];
      });
    
    });
    var $hash_ids;
    
    $def(self, '$hash', function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          hash_id = self.$object_id(),
          result = $opal32_init(),
          key, item, i,
          size = self.size, ary = new Int32Array(size);

      result = $opal32_add(result, 0x4);
      result = $opal32_add(result, size);

      if (top) {
        $hash_ids = Object.create(null);
      }
      else if ($hash_ids[hash_id]) {
        return $opal32_add(result, 0x01010101);
      }

      try {
        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return $opal32_add(result, 0x01010101);
          }
        }

        $hash_ids[hash_id] = self;
        i = 0

        $hash_each(self, false, function(key, value) {
          ary[i] = [0x70414952, key, value].$hash();
          i++;
          return [false, false];
        });

        ary = ary.sort();

        for (i = 0; i < ary.length; i++) {
          result = $opal32_add(result, ary[i]);
        }

        return result;
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    });
    
    $def(self, '$index', function $$index(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((value)['$=='](object)) {
          return [true, key];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$indexes', function $$indexes($a) {
      var $post_args, args, self = this;

      
      $post_args = $slice(arguments);
      args = $post_args;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = $hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, -1);
    var inspect_ids;
    
    $def(self, '$inspect', function $$inspect() {
      var self = this;

      
      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];
    ;
      
      return (function() { try {
      
      
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        $hash_each(self, false, function(key, value) {
          value = $$('Opal').$inspect(value)
          key = $$('Opal').$inspect(key)

          result.push(key + '=>' + value);
          return [false, false];
        })

        return '{' + result.join(', ') + '}';
      ;
      return nil;
      } finally {
        if (top) inspect_ids = undefined
      }; })();;
    });
    
    $def(self, '$invert', function $$invert() {
      var self = this;

      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        $hash_put(hash, value, key);
        return [false, hash];
      });
    
    });
    
    $def(self, '$keep_if', function $$keep_if() {
      var block = $$keep_if.$$p || nil, self = this;

      $$keep_if.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["keep_if"], function $$26(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
        }
        return [false, self];
      });
    ;
    });
    
    $def(self, '$keys', function $$keys() {
      var self = this;

      return Array.from(self.keys());
    });
    
    $def(self, '$length', function $$length() {
      var self = this;

      return self.size;
    });
    
    $def(self, '$merge', function $$merge($a) {
      var block = $$merge.$$p || nil, $post_args, others, self = this;

      $$merge.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      return $send(self.$dup(), 'merge!', $to_a(others), block.$to_proc());
    }, -1);
    
    $def(self, '$merge!', function $Hash_merge$excl$27($a) {
      var block = $Hash_merge$excl$27.$$p || nil, $post_args, others, self = this;

      $Hash_merge$excl$27.$$p = null;
      
      ;
      $post_args = $slice(arguments);
      others = $post_args;
      
      $deny_frozen_access(self);

      var i, j, other;
      for (i = 0; i < others.length; ++i) {
        other = $Opal['$coerce_to!'](others[i], $$$('Hash'), "to_hash");

        if (block === nil) {
          $hash_each(other, false, function(key, value) {
            $hash_put(self, key, value);
            return [false, false];
          });
        } else {
          $hash_each(other, false, function(key, value) {
            var val = $hash_get(self, key);

            if (val === undefined) {
              $hash_put(self, key, value);
              return [false, false];
            }

            $hash_put(self, key, block(key, val, value));
            return [false, false];
          });
        }
      }

      return self;
    ;
    }, -1);
    
    $def(self, '$rassoc', function $$rassoc(object) {
      var self = this;

      
      return $hash_each(self, nil, function(key, value) {
        if ((value)['$=='](object)) {
          return [true, [key, value]];
        }
        return [false, nil];
      });
    
    });
    
    $def(self, '$rehash', function $$rehash() {
      var self = this;

      
      $deny_frozen_access(self);
      return Opal.hash_rehash(self);
    
    });
    
    $def(self, '$reject', function $$reject() {
      var block = $$reject.$$p || nil, self = this;

      $$reject.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject"], function $$28(){var self = $$28.$$s == null ? this : $$28.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash]
      });
    ;
    });
    
    $def(self, '$reject!', function $Hash_reject$excl$29() {
      var block = $Hash_reject$excl$29.$$p || nil, self = this;

      $Hash_reject$excl$29.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["reject!"], function $$30(){var self = $$30.$$s == null ? this : $$30.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$replace', function $$replace(other) {
      var self = this;

      
      $deny_frozen_access(self);;
      other = $Opal['$coerce_to!'](other, $$$('Hash'), "to_hash");
      
      self.$clear();

      $hash_each(other, false, function(key, value) {
        $hash_put(self, key, value);
        return [false, false];
      });
    ;
      if ($truthy(other.$default_proc())) {
        self['$default_proc='](other.$default_proc())
      } else {
        self['$default='](other.$default())
      };
      return self;
    });
    
    $def(self, '$select', function $$select() {
      var block = $$select.$$p || nil, self = this;

      $$select.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select"], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var hash = new Map();

      return $hash_each(self, hash, function(key, value) {
        var obj = block(key, value);

        if (obj !== false && obj !== nil) {
          $hash_put(hash, key, value);
        }
        return [false, hash];
      });
    ;
    });
    
    $def(self, '$select!', function $Hash_select$excl$32() {
      var block = $Hash_select$excl$32.$$p || nil, self = this;

      $Hash_select$excl$32.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["select!"], function $$33(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var result = nil;

      return $hash_each(self, result, function(key, value) {
        var obj = block(key, value);

        if (obj === false || obj === nil) {
          $hash_delete(self, key);
          result = self;
        }
        return [false, result];
      });
    ;
    });
    
    $def(self, '$shift', function $$shift() {
      var self = this;

      
      $deny_frozen_access(self);

      return $hash_each(self, nil, function(key, value) {
        return [true, [key, $hash_delete(self, key)]];
      });
    
    });
    
    $def(self, '$slice', function $$slice($a) {
      var $post_args, keys, self = this;

      
      $post_args = $slice(arguments);
      keys = $post_args;
      
      var result = new Map();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = $hash_get(self, key);

        if (value !== undefined) {
          $hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, -1);
    
    $def(self, '$to_a', function $$to_a() {
      var self = this;

      
      var result = [];

      return $hash_each(self, result, function(key, value) {
        result.push([key, value]);
        return [false, result];
      });
    
    });
    
    $def(self, '$to_h', function $$to_h() {
      var block = $$to_h.$$p || nil, self = this;

      $$to_h.$$p = null;
      
      ;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()
      };
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Map();

      $hash_clone(self, hash);

      return hash;
    ;
    });
    
    $def(self, '$to_hash', $return_self);
    
    $def(self, '$to_proc', function $$to_proc() {
      var self = this;

      return $send(self, 'proc', [], function $$34(key){var self = $$34.$$s == null ? this : $$34.$$s;

        
        ;
        
        if (key == null) {
          $Kernel.$raise($$$('ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, {$$arity: -1, $$s: self})
    });
    
    $def(self, '$transform_keys', function $$transform_keys(keys_hash) {
      var block = $$transform_keys.$$p || nil, self = this;

      $$transform_keys.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys"], function $$35(){var self = $$35.$$s == null ? this : $$35.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      return $hash_each(self, result, function(key, value) {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          new_key = key // key not modified
        $hash_put(result, new_key, value);
        return [false, result];
      });
    ;
    }, -1);
    
    $def(self, '$transform_keys!', function $Hash_transform_keys$excl$36(keys_hash) {
      var block = $Hash_transform_keys$excl$36.$$p || nil, self = this;

      $Hash_transform_keys$excl$36.$$p = null;
      
      ;
      if (keys_hash == null) keys_hash = nil;
      if (($not(block) && ($not(keys_hash)))) {
        return $send(self, 'enum_for', ["transform_keys!"], function $$37(){var self = $$37.$$s == null ? this : $$37.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      var modified_keys = new Map();

      return $hash_each(self, self, function(key, value) {
        var new_key;
        if (keys_hash !== nil)
          new_key = $hash_get(keys_hash, key);
        if (new_key === undefined && block && block !== nil)
          new_key = block(key);
        if (new_key === undefined)
          return [false, self]; // key not modified
        if (!$hash_get(modified_keys, key))
          $hash_delete(self, key);
        $hash_put(self, new_key, value);
        $hash_put(modified_keys, new_key, true)
        return [false, self];
      });
    ;
    }, -1);
    
    $def(self, '$transform_values', function $$transform_values() {
      var block = $$transform_values.$$p || nil, self = this;

      $$transform_values.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values"], function $$38(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$size()}, {$$s: self})
      };
      
      var result = new Map();

      return $hash_each(self, result, function(key, value) {
        $hash_put(result, key, block(value));
        return [false, result];
      });
    ;
    });
    
    $def(self, '$transform_values!', function $Hash_transform_values$excl$39() {
      var block = $Hash_transform_values$excl$39.$$p || nil, self = this;

      $Hash_transform_values$excl$39.$$p = null;
      
      ;
      if (!$truthy(block)) {
        return $send(self, 'enum_for', ["transform_values!"], function $$40(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, {$$s: self})
      };
      
      $deny_frozen_access(self);

      return $hash_each(self, self, function(key, value) {
        $hash_put(self, key, block(value));
        return [false, self];
      });
    ;
    });
    
    $def(self, '$values', function $$values() {
      var self = this;

      return Array.from(self.values());
    });
    $alias(self, "each_pair", "each");
    $alias(self, "eql?", "==");
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    $alias(self, "include?", "has_key?");
    $alias(self, "indices", "indexes");
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    $alias(self, "member?", "has_key?");
    $alias(self, "size", "length");
    $alias(self, "store", "[]=");
    $alias(self, "to_s", "inspect");
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    return $alias(self, "values_at", "indexes");
  })('::', Map, $nesting);
});
