Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $Kernel = Opal.Kernel, $klass = Opal.klass, $send = Opal.send, $slice = Opal.slice, $module = Opal.module, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('raise,warn,each,define_method,%,public,private_method_defined?,private_class_method,instance_method,instance_methods,method_defined?,private_methods');
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $Kernel.$raise($$$('NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    return $send(["<<", "capitalize!", "chomp!", "chop!", "downcase!", "gsub!", "lstrip!", "next!", "reverse!", "slice!", "squeeze!", "strip!", "sub!", "succ!", "swapcase!", "tr!", "tr_s!", "upcase!", "prepend", "[]=", "clear", "encode!", "unicode_normalize!"], 'each', [], function $String$1(method_name){var self = $String$1.$$s == null ? this : $String$1.$$s;

      
      if (method_name == null) method_name = nil;
      return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, $fwd_rest;

        
        $post_args = $slice(arguments);
        $fwd_rest = $post_args;
        return $Kernel.$raise($$$('NotImplementedError'), (ERROR)['$%'](method_name));}, -1);}, {$$s: self});
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    var ERROR = "Object tainting is not supported by Opal";
    
    $def(self, '$taint', function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    
    $def(self, '$untaint', function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    });
    return $def(self, '$tainted?', function $Kernel_tainted$ques$3() {
      
      
      handle_unsupported_feature(ERROR);
      return false;
    });
  })('::');
  (function($base, $super) {
    var self = $klass($base, $super, 'Module');

    
    
    
    $def(self, '$public', function $Module_public$4($a) {
      var $post_args, methods, self = this;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      
      if (methods.length === 0) {
        self.$$module_function = false;
        return nil;
      }
      return (methods.length === 1) ? methods[0] : methods;
    ;
    }, -1);
    
    $def(self, '$private_class_method', function $$private_class_method($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return (methods.length === 1) ? methods[0] : methods;;
    }, -1);
    
    $def(self, '$private_method_defined?', $return_val(false));
    
    $def(self, '$private_constant', function $$private_constant($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return nil;
    }, -1);
    $alias(self, "nesting", "public");
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_class_method", "private_class_method");
    $alias(self, "public_instance_method", "instance_method");
    $alias(self, "public_instance_methods", "instance_methods");
    return $alias(self, "public_method_defined?", "method_defined?");
  })('::', null);
  (function($base) {
    var self = $module($base, 'Kernel');

    
    
    
    $def(self, '$private_methods', function $$private_methods($a) {
      var $post_args, methods;

      
      $post_args = $slice(arguments);
      methods = $post_args;
      return [];
    }, -1);
    $alias(self, "protected_methods", "private_methods");
    $alias(self, "private_instance_methods", "private_methods");
    return $alias(self, "protected_instance_methods", "private_methods");
  })('::');
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$eval', function $Kernel_eval$5($a) {
      var $post_args, $fwd_rest;

      
      $post_args = $slice(arguments);
      $fwd_rest = $post_args;
      return $Kernel.$raise($$$('NotImplementedError'), "To use Kernel#eval, you must first require 'opal-parser'. " + ("See https://github.com/opal/opal/blob/" + ($$('RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, -1)
  })('::', $nesting);
  $defs(self, '$public', function $public$6($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
  return $defs(self, '$private', function $private$7($a) {
    var $post_args, methods;

    
    $post_args = $slice(arguments);
    methods = $post_args;
    return (methods.length === 1) ? methods[0] : methods;;
  }, -1);
});
