Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $thrower = Opal.thrower, nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('to_enum,size,each,<<,to_proc,include?,+,reverse_each,respond_to?,rewind,inspect');
  return (function($base, $super) {
    var self = $klass($base, $super, 'Enumerator');

    
    return (function($base, $super) {
      var self = $klass($base, $super, 'Chain');

      var $proto = self.$$prototype;

      $proto.enums = $proto.iterated = nil;
      
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, enums, self = this;

        
        $post_args = $slice(arguments);
        enums = $post_args;
        $deny_frozen_access(self);
        self.enums = enums;
        self.iterated = [];
        return (self.object = self);
      }, -1);
      
      $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        if (!(block !== nil)) {
          return $send(self, 'to_enum', ["each"].concat($to_a(args)), function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

            return self.$size()}, {$$s: self})
        };
        $send(self.enums, 'each', [], function $$2(enum$){var self = $$2.$$s == null ? this : $$2.$$s;
          if (self.iterated == null) self.iterated = nil;

          
          if (enum$ == null) enum$ = nil;
          self.iterated['$<<'](enum$);
          return $send(enum$, 'each', $to_a(args), block.$to_proc());}, {$$s: self});
        return self;
      }, -1);
      
      $def(self, '$size', function $$size($a) {try { var $t_return = $thrower('return'); 
        var $post_args, args, self = this, accum = nil;

        
        $post_args = $slice(arguments);
        args = $post_args;
        accum = 0;
        $send(self.enums, 'each', [], function $$3(enum$){var size = nil;

          
          if (enum$ == null) enum$ = nil;
          size = $send(enum$, 'size', $to_a(args));
          if ($truthy([nil, $$$($$$('Float'), 'INFINITY')]['$include?'](size))) {
            $t_return.$throw(size, $$3.$$is_lambda)
          };
          return (accum = $rb_plus(accum, size));}, {$$ret: $t_return});
        return accum;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      }, -1);
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        $send(self.iterated, 'reverse_each', [], function $$4(enum$){
          
          if (enum$ == null) enum$ = nil;
          if ($truthy(enum$['$respond_to?']("rewind"))) {
            return enum$.$rewind()
          } else {
            return nil
          };});
        self.iterated = [];
        return self;
      });
      return $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "#<Enumerator::Chain: " + (self.enums.$inspect()) + ">"
      });
    })(self, self)
  })('::', null)
});
