Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $deny_frozen_access = Opal.deny_frozen_access, $klass = Opal.klass, $truthy = Opal.truthy, $Kernel = Opal.Kernel, $def = Opal.def, $slice = Opal.slice, $send = Opal.send, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,raise,new,to_proc');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.block = nil;
      
      self.$include($$$('Enumerable'));
      
      $def(self, '$initialize', function $$initialize() {
        var block = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        ;
        $deny_frozen_access(self);
        if (!$truthy(block)) {
          $Kernel.$raise($$$('LocalJumpError'), "no block given")
        };
        return (self.block = block);
      });
      return $def(self, '$each', function $$each($a) {
        var block = $$each.$$p || nil, $post_args, args, self = this, yielder = nil;

        $$each.$$p = null;
        
        ;
        $post_args = $slice(arguments);
        args = $post_args;
        yielder = $send($$('Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e && e.$thrower_type == "breaker") {
            return e.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], null, $nesting)
});
