Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $assign_ivar_val = Opal.assign_ivar_val, $defs = Opal.defs, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $def = Opal.def, $send = Opal.send, $send2 = Opal.send2, $find_super = Opal.find_super, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,+,generate_outer_assignments,next_tmp,class,s,prepend_to_body,assign_loop_variable,transform_for_to_each_loop,updated,private,find,map,type,<<,process,attr_reader,new,to_a,result');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ForRewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', $assign_ivar_val("counter", 0));
        $defs(self, '$next_tmp', function $$next_tmp() {
          var self = this, $ret_or_1 = nil;
          if (self.counter == null) self.counter = nil;

          
          self.counter = ($truthy(($ret_or_1 = self.counter)) ? ($ret_or_1) : (0));
          self.counter = $rb_plus(self.counter, 1);
          return "$for_tmp" + (self.counter);
        });
        
        $def(self, '$on_for', function $$on_for(node) {
          var $a, self = this, loop_variable = nil, loop_range = nil, loop_body = nil, outer_assignments = nil, tmp_loop_variable = nil, get_tmp_loop_variable = nil;

          
          $a = [].concat($to_a(node)), (loop_variable = ($a[0] == null ? nil : $a[0])), (loop_range = ($a[1] == null ? nil : $a[1])), (loop_body = ($a[2] == null ? nil : $a[2])), $a;
          outer_assignments = self.$generate_outer_assignments(loop_variable, loop_body);
          tmp_loop_variable = self.$class().$next_tmp();
          get_tmp_loop_variable = self.$s("js_tmp", tmp_loop_variable);
          loop_body = self.$prepend_to_body(loop_body, self.$assign_loop_variable(loop_variable, get_tmp_loop_variable));
          node = self.$transform_for_to_each_loop(node, loop_range, tmp_loop_variable, loop_body);
          return node.$updated("begin", [].concat($to_a(outer_assignments)).concat([node]));
        });
        self.$private();
        
        $def(self, '$generate_outer_assignments', function $$generate_outer_assignments(loop_variable, loop_body) {
          var self = this, loop_local_vars = nil, body_local_vars = nil;

          
          loop_local_vars = $$('LocalVariableAssigns').$find(loop_variable);
          body_local_vars = $$('LocalVariableAssigns').$find(loop_body);
          return $send($rb_plus(loop_local_vars, body_local_vars), 'map', [], function $$1(lvar_name){var self = $$1.$$s == null ? this : $$1.$$s;

            
            if (lvar_name == null) lvar_name = nil;
            return self.$s("lvdeclare", lvar_name);}, {$$s: self});
        });
        
        $def(self, '$assign_loop_variable', function $$assign_loop_variable(loop_variable, tmp_loop_variable) {
          
          
          switch (loop_variable.$type().valueOf()) {
            case "mlhs":
              return loop_variable.$updated("masgn", [loop_variable, tmp_loop_variable])
            default:
              return loop_variable['$<<'](tmp_loop_variable)
          }
        });
        
        $def(self, '$transform_for_to_each_loop', function $$transform_for_to_each_loop(node, loop_range, tmp_loop_variable, loop_body) {
          var self = this;

          return node.$updated("send", [loop_range, "each", node.$updated("iter", [self.$s("args", self.$s("arg", tmp_loop_variable)), self.$process(loop_body)])])
        });
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'LocalVariableAssigns');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          self.$attr_reader("result");
          $defs(self, '$find', function $$find(node) {
            var self = this, processor = nil;

            
            processor = self.$new();
            processor.$process(node);
            return processor.$result().$to_a();
          });
          
          $def(self, '$initialize', function $$initialize() {
            var self = this;

            return (self.result = $$('Set').$new())
          });
          return $def(self, '$on_lvasgn', function $$on_lvasgn(node) {
            var $a, $yield = $$on_lvasgn.$$p || nil, self = this, name = nil, _ = nil;

            $$on_lvasgn.$$p = null;
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
            self.$result()['$<<'](name);
            return $send2(self, $find_super(self, 'on_lvasgn', $$on_lvasgn, false, true), 'on_lvasgn', [node], $yield);
          });
        })($nesting[0], $$('Base'), $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
