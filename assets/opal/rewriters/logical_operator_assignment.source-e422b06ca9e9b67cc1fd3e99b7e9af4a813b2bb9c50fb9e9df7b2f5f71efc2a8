Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $defs = Opal.defs, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $lambda = Opal.lambda, $eqeq = Opal.eqeq, $to_a = Opal.to_a, $slice = Opal.slice, $send = Opal.send, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,+,updated,s,==,include?,[],type,new_temp,freeze,call,fetch,error,process');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'LogicalOperatorAssignment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', function $LogicalOperatorAssignment_reset_tmp_counter$excl$1() {
          
          return $class_variable_set($nesting[0], '@@counter', 0)
        });
        $defs(self, '$new_temp', function $$new_temp() {
          var $a, $ret_or_1 = nil;

          
          $class_variable_set($nesting[0], '@@counter', ($truthy((($a = $nesting[0].$$cvars['@@counter'], $a != null) ? 'class variable' : nil)) ? (($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@counter', false))) ? ($ret_or_1) : (0))) : (0)));
          $class_variable_set($nesting[0], '@@counter', $rb_plus($class_variable_get($nesting[0], '@@counter', false), 1));
          return "$logical_op_recvr_tmp_" + ($class_variable_get($nesting[0], '@@counter', false));
        });
        $const_set($nesting[0], 'GET_SET', $lambda(function $LogicalOperatorAssignment$2(get_type, set_type){var self = $LogicalOperatorAssignment$2.$$s == null ? this : $LogicalOperatorAssignment$2.$$s;

          
          if (get_type == null) get_type = nil;
          if (set_type == null) set_type = nil;
          return $lambda(function $$3(lhs, rhs, root_type){var self = $$3.$$s == null ? this : $$3.$$s, get_node = nil, condition_node = nil, defined_node = nil;

            
            if (lhs == null) lhs = nil;
            if (rhs == null) rhs = nil;
            if (root_type == null) root_type = nil;
            get_node = lhs.$updated(get_type);
            condition_node = self.$s(root_type, get_node, rhs);
            if (($truthy(["const", "cvar"]['$include?'](get_type)) && ($eqeq(root_type, "or")))) {
              
              defined_node = self.$s("defined?", get_node);
              condition_node = self.$s("if", defined_node, self.$s("begin", condition_node), rhs);
            };
            return lhs.$updated(set_type, [].concat($to_a(lhs)).concat([condition_node]));}, {$$s: self});}, {$$s: self}));
        $const_set($nesting[0], 'LocalVariableHandler', $$('GET_SET')['$[]']("lvar", "lvasgn"));
        $const_set($nesting[0], 'InstanceVariableHandler', $$('GET_SET')['$[]']("ivar", "ivasgn"));
        $const_set($nesting[0], 'ConstantHandler', $$('GET_SET')['$[]']("const", "casgn"));
        $const_set($nesting[0], 'GlobalVariableHandler', $$('GET_SET')['$[]']("gvar", "gvasgn"));
        $const_set($nesting[0], 'ClassVariableHandler', $$('GET_SET')['$[]']("cvar", "cvasgn"));
        (function($base, $super) {
          var self = $klass($base, $super, 'SendHandler');

          
          return $defs(self, '$call', function $$call(lhs, rhs, root_type) {
            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_writer = nil, get_or_set = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
            if (($truthy(recvr) && ($eqeq(recvr.$type(), "send")))) {
              
              recvr_tmp = self.$new_temp();
              cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
              recvr = self.$s("js_tmp", recvr_tmp);
            };
            writer_method = "" + (reader_method) + "=";
            call_reader = lhs.$updated("send", [recvr, reader_method].concat($to_a(args)));
            call_writer = lhs.$updated("send", [recvr, writer_method].concat($to_a(args)).concat([rhs]));
            get_or_set = self.$s(root_type, call_reader, call_writer);
            if ($truthy(cache_recvr)) {
              return self.$s("begin", cache_recvr, get_or_set)
            } else {
              return get_or_set
            };
          })
        })($nesting[0], self);
        (function($base, $super) {
          var self = $klass($base, $super, 'ConditionalSendHandler');

          
          return $defs(self, '$call', function $$call(lhs, rhs, root_type) {
            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_or_asgn = nil;

            
            root_type = "" + (root_type) + "_asgn";
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
            recvr_tmp = self.$new_temp();
            cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
            recvr = self.$s("js_tmp", recvr_tmp);
            recvr_is_nil = self.$s("send", recvr, "nil?");
            plain_send = lhs.$updated("send", [recvr, meth].concat($to_a(args)));
            plain_or_asgn = self.$s(root_type, plain_send, rhs);
            return self.$s("begin", cache_recvr, self.$s("if", recvr_is_nil, self.$s("nil"), plain_or_asgn));
          })
        })($nesting[0], self);
        $const_set($nesting[0], 'HANDLERS', (new Map([["lvasgn", $$('LocalVariableHandler')], ["ivasgn", $$('InstanceVariableHandler')], ["casgn", $$('ConstantHandler')], ["gvasgn", $$('GlobalVariableHandler')], ["cvasgn", $$('ClassVariableHandler')], ["send", $$('SendHandler')], ["csend", $$('ConditionalSendHandler')]])).$freeze());
        
        $def(self, '$on_or_asgn', function $$on_or_asgn(node) {
          var $a, self = this, lhs = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$s: self}).$call(lhs, rhs, "or");
          return self.$process(result);
        });
        
        $def(self, '$on_and_asgn', function $$on_and_asgn(node) {
          var $a, self = this, lhs = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$s: self}).$call(lhs, rhs, "and");
          return self.$process(result);
        });
        $const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s("str", "assignment"));
        return $def(self, '$on_defined?', function $LogicalOperatorAssignment_on_defined$ques$6(node) {
          var $a, $yield = $LogicalOperatorAssignment_on_defined$ques$6.$$p || nil, self = this, inner = nil, _ = nil;

          $LogicalOperatorAssignment_on_defined$ques$6.$$p = null;
          
          $a = [].concat($to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(["or_asgn", "and_asgn"]['$include?'](inner.$type()))) {
            return $$('ASSIGNMENT_STRING_NODE')
          } else {
            return $send2(self, $find_super(self, 'on_defined?', $LogicalOperatorAssignment_on_defined$ques$6, false, true), 'on_defined?', [node], null)
          };
        });
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
