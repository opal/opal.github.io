Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $to_a = Opal.to_a, $rb_plus = Opal.rb_plus, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $return_ivar = Opal.return_ivar, $alias = Opal.alias, $eqeqeq = Opal.eqeqeq, $Opal = Opal.Opal, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,s,convert_full_pattern,raise_no_matching_pattern_error,+,process,single_case_match,private,shift,type,!,empty?,!=,==,class,new,run!,variables,pattern,map,<<,array,on_literal,first,children,to_proc,method,each,to_ast,on_array_pattern,compact,[],===');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'PatternMatching');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.depth = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          self.depth = 0;
          return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [], $yield);
        });
        
        $def(self, '$on_match_pattern', function $$on_match_pattern(node) {
          var $a, self = this, from = nil, pat = nil;

          
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), (pat = ($a[1] == null ? nil : $a[1])), $a;
          return self.$s("begin", self.$s("lvasgn", "$pmvar", from), self.$s("if", self.$convert_full_pattern(from, pat), nil, self.$raise_no_matching_pattern_error("$pmvar")));
        });
        
        $def(self, '$on_match_pattern_p', function $$on_match_pattern_p(node) {
          var $a, self = this, from = nil, pat = nil;

          
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), (pat = ($a[1] == null ? nil : $a[1])), $a;
          return self.$s("if", self.$convert_full_pattern(from, pat), self.$s("true"), self.$s("false"));
        });
        
        $def(self, '$on_case_match', function $$on_case_match(node) {
          var $a, $b, self = this, cmvar = nil, from = nil, cases = nil, els = nil;

          
          self.depth = $rb_plus(self.depth, 1);
          cmvar = "$cmvar" + (self.depth);
          $a = [].concat($to_a(node)), (from = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (cases = $slice($a, 1, $b)), (els = ($a[$b] == null ? nil : $a[$b])), $a;
          if ($truthy(els)) {
            self.$process(els)
          } else {
            els = self.$raise_no_matching_pattern_error(cmvar)
          };
          return self.$s("begin", self.$s("lvasgn", cmvar, from), $send(self, 'single_case_match', [cmvar].concat($to_a(cases)).concat([els])));
        });
        self.$private();
        
        $def(self, '$raise_no_matching_pattern_error', function $$raise_no_matching_pattern_error(from) {
          var self = this;

          return self.$s("send", nil, "raise", self.$s("const", self.$s("cbase"), "NoMatchingPatternError"), self.$s("lvar", from))
        });
        
        $def(self, '$single_case_match', function $$single_case_match(from, $a, $b) {
          var $post_args, cases, els, $c, self = this, cas = nil, pat = nil, if_guard = nil, body = nil, guard = nil;

          
          $post_args = $slice(arguments, 1);
          cases = $post_args.splice(0, $post_args.length - 1);
          
          els = $post_args.shift();if (els == null) els = nil;
          cas = cases.$shift();
          $c = [].concat($to_a(cas)), (pat = ($c[0] == null ? nil : $c[0])), (if_guard = ($c[1] == null ? nil : $c[1])), (body = ($c[2] == null ? nil : $c[2])), $c;
          pat = self.$convert_full_pattern(from, pat);
          if ($truthy(if_guard)) {
            
            $c = [].concat($to_a(if_guard)), (guard = ($c[0] == null ? nil : $c[0])), $c;
            
            switch (if_guard.$type().valueOf()) {
              case "if_guard":
                pat = self.$s("and", pat, guard)
                break;
              case "unless_guard":
                pat = self.$s("and", pat, self.$s("send", guard, "!"))
                break;
              default:
                nil
            };
          };
          return self.$s("if", pat, self.$process(body), ($not(cases['$empty?']()) ? ($send(self, 'single_case_match', [from].concat($to_a(cases)).concat([els]))) : ($neqeq(els, self.$s("empty_else")) ? (els) : nil)));
        }, -3);
        
        $def(self, '$convert_full_pattern', function $$convert_full_pattern(from, pat) {
          var self = this, converter = nil;

          
          if ($eqeq(from.$class(), $$('Symbol'))) {
            from = self.$s("lvar", from)
          };
          converter = $$('PatternConverter').$new(pat);
          converter['$run!']();
          return self.$s("masgn", $send(self, 's', ["mlhs"].concat($to_a(converter.$variables()))), self.$s("send", self.$s("const", self.$s("cbase"), "PatternMatching"), "call", from, converter.$pattern()));
        });
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'PatternConverter');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

          $proto.pat = $proto.variables = nil;
          
          
          $def(self, '$initialize', function $$initialize(pat) {
            var self = this;

            
            self.pat = pat;
            return (self.variables = []);
          });
          
          $def(self, '$run!', function $PatternConverter_run$excl$1() {
            var self = this;

            return (self.outpat = self.$process(self.pat))
          });
          
          $def(self, '$pattern', $return_ivar("outpat"));
          
          $def(self, '$variables', function $$variables() {
            var self = this;

            return $send(self.variables, 'map', [], function $$2(i){var self = $$2.$$s == null ? this : $$2.$$s;

              
              if (i == null) i = nil;
              return self.$s("lvasgn", i);}, {$$s: self})
          });
          
          $def(self, '$on_match_var', function $$on_match_var(node) {
            var $a, self = this, var$ = nil;

            
            $a = [].concat($to_a(node)), (var$ = ($a[0] == null ? nil : $a[0])), $a;
            self.variables['$<<'](var$);
            return self.$s("sym", "var");
          });
          
          $def(self, '$on_match_as', function $$on_match_as(node) {
            var $a, self = this, pat = nil, save = nil;

            
            $a = [].concat($to_a(node)), (pat = ($a[0] == null ? nil : $a[0])), (save = ($a[1] == null ? nil : $a[1])), $a;
            self.$process(save);
            return self.$array(self.$s("sym", "save"), self.$process(pat));
          });
          
          $def(self, '$on_literal', function $$on_literal(node) {
            var self = this;

            return self.$array(self.$s("sym", "lit"), node)
          });
          $alias(self, "on_int", "on_literal");
          $alias(self, "on_float", "on_literal");
          $alias(self, "on_complex", "on_literal");
          $alias(self, "on_rational", "on_literal");
          $alias(self, "on_array", "on_literal");
          $alias(self, "on_str", "on_literal");
          $alias(self, "on_dstr", "on_literal");
          $alias(self, "on_xstr", "on_literal");
          $alias(self, "on_sym", "on_literal");
          $alias(self, "on_irange", "on_literal");
          $alias(self, "on_erange", "on_literal");
          $alias(self, "on_const", "on_literal");
          $alias(self, "on_regexp", "on_literal");
          $alias(self, "on_lambda", "on_literal");
          $alias(self, "on_begin", "on_literal");
          
          $def(self, '$on_pin', function $$on_pin(node) {
            var self = this;

            return self.$on_literal(node.$children().$first())
          });
          
          $def(self, '$on_match_rest', function $$on_match_rest(node) {
            var self = this;

            if ($truthy(node.$children()['$empty?']())) {
              return self.$array(self.$s("sym", "rest"))
            } else {
              return self.$array(self.$s("sym", "rest"), self.$process(node.$children().$first()))
            }
          });
          
          $def(self, '$on_match_alt', function $$on_match_alt(node) {
            var self = this;

            return $send(self, 'array', [self.$s("sym", "any")].concat($to_a($send(node.$children(), 'map', [], self.$method("process").$to_proc()))))
          });
          
          $def(self, '$on_const_pattern', function $$on_const_pattern(node) {
            var self = this;

            return $send(self, 'array', [self.$s("sym", "all")].concat($to_a($send(node.$children(), 'map', [], self.$method("process").$to_proc()))))
          });
          
          $def(self, '$on_array_pattern', function $$on_array_pattern(node, tail) {
            var self = this, children = nil, fixed_size = nil, array_size = nil;

            
            if (tail == null) tail = false;
            children = [].concat($to_a(node));
            if ($truthy(tail)) {
              children['$<<'](self.$s("match_rest"))
            };
            fixed_size = true;
            array_size = 0;
            children = $send(children, 'each', [], function $$3(i){
              
              if (i == null) i = nil;
              
              switch (i.$type().valueOf()) {
                case "match_rest":
                  return (fixed_size = false)
                default:
                  return (array_size = $rb_plus(array_size, 1))
              };});
            return self.$array(self.$s("sym", "array"), self.$to_ast(fixed_size), self.$to_ast(array_size), self.$to_ast($send(children, 'map', [], self.$method("process").$to_proc())));
          }, -2);
          
          $def(self, '$on_array_pattern_with_tail', function $$on_array_pattern_with_tail(node) {
            var self = this;

            return self.$on_array_pattern(node, true)
          });
          
          $def(self, '$on_hash_pattern', function $$on_hash_pattern(node) {
            var self = this, children = nil, any_size = nil;

            
            children = [].concat($to_a(node));
            any_size = ($truthy(children['$empty?']()) ? (self.$to_ast(false)) : (self.$to_ast(true)));
            children = $send(children, 'map', [], function $$4(i){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (i == null) i = nil;
              
              switch (i.$type().valueOf()) {
                case "pair":
                  return self.$array(i.$children()['$[]'](0), self.$process(i.$children()['$[]'](1)))
                case "match_var":
                  return self.$array(self.$s("sym", i.$children()['$[]'](0)), self.$process(i))
                case "match_nil_pattern":
                  
                  any_size = self.$to_ast(false);
                  return nil;
                case "match_rest":
                  
                  if ($truthy(i.$children().$first())) {
                    any_size = self.$process(i.$children().$first())
                  } else {
                    any_size = self.$to_ast(true)
                  };
                  return nil;
                default:
                  return nil
              };}, {$$s: self}).$compact();
            return self.$array(self.$s("sym", "hash"), any_size, $send(self, 'array', $to_a(children)));
          });
          
          $def(self, '$on_find_pattern', function $$on_find_pattern(node) {
            var self = this, children = nil;

            
            children = [].concat($to_a(node));
            children = $send(children, 'map', [], self.$method("process").$to_proc());
            return self.$array(self.$s("sym", "find"), $send(self, 'array', $to_a(children)));
          });
          self.$private();
          
          $def(self, '$array', function $$array($a) {
            var $post_args, args, self = this;

            
            $post_args = $slice(arguments);
            args = $post_args;
            return self.$to_ast(args);
          }, -1);
          return $def(self, '$to_ast', function $$to_ast(val) {
            var self = this, $ret_or_1 = nil;

            if ($eqeqeq($$('Array'), ($ret_or_1 = val))) {
              return $send(self, 's', ["array"].concat($to_a(val)))
            } else if ($eqeqeq($$('Integer'), $ret_or_1)) {
              return self.$s("int", val)
            } else if ($eqeqeq(true, $ret_or_1)) {
              return self.$s("true")
            } else if ($eqeqeq(false, $ret_or_1)) {
              return self.$s("false")
            } else if ($eqeqeq(nil, $ret_or_1)) {
              return self.$s("nil")
            } else {
              return nil
            }
          });
        })($nesting[0], $$$($$$($Opal, 'Rewriters'), 'Base'), $nesting);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
