Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $send = Opal.send, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,==,type,!=,size,error,first,to_js_attr_call,to_js_attr_assign_call,to_native_js_call,s');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DotJsSyntax');

        
        
        
        $def(self, '$on_send', function $$on_send(node) {
          var $a, $yield = $$on_send.$$p || nil, self = this, recv = nil, meth = nil, args = nil, recv_of_recv = nil, meth_of_recv = nil, _ = nil, property = nil, value = nil;

          $$on_send.$$p = null;
          
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
          if (($truthy(recv) && ($eqeq(recv.$type(), "send")))) {
            
            $a = [].concat($to_a(recv)), (recv_of_recv = ($a[0] == null ? nil : $a[0])), (meth_of_recv = ($a[1] == null ? nil : $a[1])), (_ = ($a[2] == null ? nil : $a[2])), $a;
            if ($eqeq(meth_of_recv, "JS")) {
              
              
              switch (meth.valueOf()) {
                case "[]":
                  
                  if ($neqeq(args.$size(), 1)) {
                    self.$error(".JS[:property] syntax supports only one argument")
                  };
                  property = args.$first();
                  node = self.$to_js_attr_call(recv_of_recv, property);
                  break;
                case "[]=":
                  
                  if ($neqeq(args.$size(), 2)) {
                    self.$error(".JS[:property]= syntax supports only two arguments")
                  };
                  $a = [].concat($to_a(args)), (property = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
                  node = self.$to_js_attr_assign_call(recv_of_recv, property, value);
                  break;
                default:
                  node = self.$to_native_js_call(recv_of_recv, meth, args)
              };
              return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], null);
            } else {
              return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
            };
          } else {
            return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
          };
        });
        
        $def(self, '$to_native_js_call', function $$to_native_js_call(recv, meth, args) {
          var self = this;

          return $send(self, 's', ["jscall", recv, meth].concat($to_a(args)))
        });
        
        $def(self, '$to_js_attr_call', function $$to_js_attr_call(recv, property) {
          var self = this;

          return self.$s("jsattr", recv, property)
        });
        return $def(self, '$to_js_attr_assign_call', function $$to_js_attr_assign_call(recv, property, value) {
          var self = this;

          return self.$s("jsattrasgn", recv, property, value)
        });
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
