Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $defs = Opal.defs, $truthy = Opal.truthy, $class_variable_get = Opal.class_variable_get, $rb_plus = Opal.rb_plus, $const_set = Opal.const_set, $lambda = Opal.lambda, $to_a = Opal.to_a, $slice = Opal.slice, $eqeq = Opal.eqeq, $send = Opal.send, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,+,updated,[],==,type,new_temp,s,freeze,call,fetch,error,process');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BinaryOperatorAssignment');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$reset_tmp_counter!', function $BinaryOperatorAssignment_reset_tmp_counter$excl$1() {
          
          return $class_variable_set($nesting[0], '@@counter', 0)
        });
        $defs(self, '$new_temp', function $$new_temp() {
          var $a, $ret_or_1 = nil;

          
          $class_variable_set($nesting[0], '@@counter', ($truthy((($a = $nesting[0].$$cvars['@@counter'], $a != null) ? 'class variable' : nil)) ? (($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@counter', false))) ? ($ret_or_1) : (0))) : (0)));
          $class_variable_set($nesting[0], '@@counter', $rb_plus($class_variable_get($nesting[0], '@@counter', false), 1));
          return "$binary_op_recvr_tmp_" + ($class_variable_get($nesting[0], '@@counter', false));
        });
        $const_set($nesting[0], 'GET_SET', $lambda(function $BinaryOperatorAssignment$2(get_type, set_type){
          
          if (get_type == null) get_type = nil;
          if (set_type == null) set_type = nil;
          return $lambda(function $$3(node, lhs, operation, rhs){var get_node = nil, set_node = nil;

            
            if (node == null) node = nil;
            if (lhs == null) lhs = nil;
            if (operation == null) operation = nil;
            if (rhs == null) rhs = nil;
            get_node = lhs.$updated(get_type);
            set_node = node.$updated("send", [get_node, operation, rhs]);
            return lhs.$updated(set_type, [].concat($to_a(lhs)).concat([set_node]));});}));
        $const_set($nesting[0], 'LocalVariableHandler', $$('GET_SET')['$[]']("lvar", "lvasgn"));
        $const_set($nesting[0], 'InstanceVariableHandler', $$('GET_SET')['$[]']("ivar", "ivasgn"));
        $const_set($nesting[0], 'ConstantHandler', $$('GET_SET')['$[]']("const", "casgn"));
        $const_set($nesting[0], 'GlobalVariableHandler', $$('GET_SET')['$[]']("gvar", "gvasgn"));
        $const_set($nesting[0], 'ClassVariableHandler', $$('GET_SET')['$[]']("cvar", "cvasgn"));
        (function($base, $super) {
          var self = $klass($base, $super, 'SendHandler');

          
          return $defs(self, '$call', function $$call(node, lhs, operation, rhs) {
            var $a, self = this, recvr = nil, reader_method = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, writer_method = nil, call_reader = nil, call_op = nil, call_writer = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (reader_method = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
            if (($truthy(recvr) && ($eqeq(recvr.$type(), "send")))) {
              
              recvr_tmp = self.$new_temp();
              cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
              recvr = self.$s("js_tmp", recvr_tmp);
            };
            writer_method = "" + (reader_method) + "=";
            call_reader = lhs.$updated("send", [recvr, reader_method].concat($to_a(args)));
            call_op = node.$updated("send", [call_reader, operation, rhs]);
            call_writer = lhs.$updated("send", [recvr, writer_method].concat($to_a(args)).concat([call_op]));
            if ($truthy(cache_recvr)) {
              return node.$updated("begin", [cache_recvr, call_writer])
            } else {
              return call_writer
            };
          })
        })($nesting[0], self);
        (function($base, $super) {
          var self = $klass($base, $super, 'ConditionalSendHandler');

          
          return $defs(self, '$call', function $$call(node, lhs, operation, rhs) {
            var $a, self = this, recvr = nil, meth = nil, args = nil, recvr_tmp = nil, cache_recvr = nil, recvr_is_nil = nil, plain_send = nil, plain_op_asgn = nil;

            
            $a = [].concat($to_a(lhs)), (recvr = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
            recvr_tmp = self.$new_temp();
            cache_recvr = self.$s("lvasgn", recvr_tmp, recvr);
            recvr = self.$s("js_tmp", recvr_tmp);
            recvr_is_nil = self.$s("send", recvr, "nil?");
            plain_send = lhs.$updated("send", [recvr, meth].concat($to_a(args)));
            plain_op_asgn = node.$updated("op_asgn", [plain_send, operation, rhs]);
            return self.$s("begin", cache_recvr, self.$s("if", recvr_is_nil, self.$s("nil"), plain_op_asgn));
          })
        })($nesting[0], self);
        $const_set($nesting[0], 'HANDLERS', (new Map([["lvasgn", $$('LocalVariableHandler')], ["ivasgn", $$('InstanceVariableHandler')], ["casgn", $$('ConstantHandler')], ["gvasgn", $$('GlobalVariableHandler')], ["cvasgn", $$('ClassVariableHandler')], ["send", $$('SendHandler')], ["csend", $$('ConditionalSendHandler')]])).$freeze());
        
        $def(self, '$on_op_asgn', function $$on_op_asgn(node) {
          var $a, self = this, lhs = nil, op = nil, rhs = nil, result = nil;

          
          $a = [].concat($to_a(node)), (lhs = ($a[0] == null ? nil : $a[0])), (op = ($a[1] == null ? nil : $a[1])), (rhs = ($a[2] == null ? nil : $a[2])), $a;
          result = $send($$('HANDLERS'), 'fetch', [lhs.$type()], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;

            return self.$error("cannot handle LHS type: " + (lhs.$type()))}, {$$s: self}).$call(node, lhs, op, rhs);
          return self.$process(result);
        });
        $const_set($nesting[0], 'ASSIGNMENT_STRING_NODE', self.$s("str", "assignment"));
        return $def(self, '$on_defined?', function $BinaryOperatorAssignment_on_defined$ques$5(node) {
          var $a, $yield = $BinaryOperatorAssignment_on_defined$ques$5.$$p || nil, self = this, inner = nil, _ = nil;

          $BinaryOperatorAssignment_on_defined$ques$5.$$p = null;
          
          $a = [].concat($to_a(node)), (inner = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($eqeq(inner.$type(), "op_asgn")) {
            return $$('ASSIGNMENT_STRING_NODE')
          } else {
            return $send2(self, $find_super(self, 'on_defined?', $BinaryOperatorAssignment_on_defined$ques$5, false, true), 'on_defined?', [node], null)
          };
        });
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
