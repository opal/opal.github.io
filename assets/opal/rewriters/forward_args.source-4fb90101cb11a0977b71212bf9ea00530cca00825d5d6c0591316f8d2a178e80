Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $not = Opal.not, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $range = Opal.range, $to_a = Opal.to_a, $neqeq = Opal.neqeq, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,process,s,!,first,children,updated,==,type,last,[],!=,class');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ForwardArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$on_forward_args', function $$on_forward_args(_node) {
          var self = this;

          return self.$process(self.$s("args", self.$s("forward_arg", "$")))
        });
        
        $def(self, '$on_forwarded_restarg', function $$on_forwarded_restarg(_node) {
          var self = this;

          return self.$process(self.$s("splat", self.$s("lvar", "$fwd_rest")))
        });
        
        $def(self, '$on_forwarded_kwrestarg', function $$on_forwarded_kwrestarg(_node) {
          var self = this;

          return self.$process(self.$s("kwsplat", self.$s("lvar", "$fwd_kwrest")))
        });
        
        $def(self, '$on_block_pass', function $$on_block_pass(node) {
          var $yield = $$on_block_pass.$$p || nil, self = this;

          $$on_block_pass.$$p = null;
          if ($not(node.$children().$first())) {
            return self.$process(node.$updated(nil, [self.$s("lvar", "$fwd_block")]))
          } else {
            return $send2(self, $find_super(self, 'on_block_pass', $$on_block_pass, false, true), 'on_block_pass', [node], $yield)
          }
        });
        
        $def(self, '$on_args', function $$on_args(node) {
          var $yield = $$on_args.$$p || nil, self = this, prev_children = nil;

          $$on_args.$$p = null;
          if (($truthy(node.$children().$last()) && ($eqeq(node.$children().$last().$type(), "forward_arg")))) {
            
            prev_children = node.$children()['$[]']($range(0, -2, false));
            return $send2(self, $find_super(self, 'on_args', $$on_args, false, true), 'on_args', [node.$updated(nil, [].concat($to_a(prev_children)).concat([self.$s("restarg", "$fwd_rest"), self.$s("blockarg", "$fwd_block")]))], null);
          } else {
            return $send2(self, $find_super(self, 'on_args', $$on_args, false, true), 'on_args', [node], $yield)
          }
        });
        
        $def(self, '$on_restarg', function $$on_restarg(node) {
          var $yield = $$on_restarg.$$p || nil, self = this;

          $$on_restarg.$$p = null;
          if ($not(node.$children().$first())) {
            return node.$updated(nil, ["$fwd_rest"])
          } else {
            return $send2(self, $find_super(self, 'on_restarg', $$on_restarg, false, true), 'on_restarg', [node], $yield)
          }
        });
        
        $def(self, '$on_kwrestarg', function $$on_kwrestarg(node) {
          var $yield = $$on_kwrestarg.$$p || nil, self = this;

          $$on_kwrestarg.$$p = null;
          if ($not(node.$children().$first())) {
            return node.$updated(nil, ["$fwd_kwrest"])
          } else {
            return $send2(self, $find_super(self, 'on_kwrestarg', $$on_kwrestarg, false, true), 'on_kwrestarg', [node], $yield)
          }
        });
        
        $def(self, '$on_blockarg', function $$on_blockarg(node) {
          var $yield = $$on_blockarg.$$p || nil, self = this;

          $$on_blockarg.$$p = null;
          if ($not(node.$children().$first())) {
            return node.$updated(nil, ["$fwd_block"])
          } else {
            return $send2(self, $find_super(self, 'on_blockarg', $$on_blockarg, false, true), 'on_blockarg', [node], $yield)
          }
        });
        return $def(self, '$on_send', function $$on_send(node) {
          var $yield = $$on_send.$$p || nil, self = this, prev_children = nil;

          $$on_send.$$p = null;
          if ((($truthy(node.$children().$last()) && ($neqeq(node.$children().$last().$class(), $$('Symbol')))) && ($eqeq(node.$children().$last().$type(), "forwarded_args")))) {
            
            prev_children = node.$children()['$[]']($range(0, -2, false));
            return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node.$updated(nil, [].concat($to_a(prev_children)).concat([self.$s("splat", self.$s("lvar", "$fwd_rest")), self.$s("block_pass", self.$s("lvar", "$fwd_block"))]))], null);
          } else {
            return $send2(self, $find_super(self, 'on_send', $$on_send, false, true), 'on_send', [node], $yield)
          }
        });
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
