Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $truthy = Opal.truthy, $defs = Opal.defs, $def = Opal.def, $range = Opal.range, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $alias = Opal.alias, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,freeze,=~,!,valid_name?,class,to_sym,valid_ivar_name?,[],to_s,updated,fix_var_name,fix_ivar_name,on_restarg');
  
  self.$require("opal/rewriters/base");
  self.$require("opal/regexp_anchors");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'JsReservedWords');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'ES51_RESERVED_WORD', $regexp([$$('REGEXP_START'), "(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'ES3_RESERVED_WORD_EXCLUSIVE', $regexp([$$('REGEXP_START'), "(?:int|byte|char|goto|long|final|float|short|double|native|throws|boolean|abstract|volatile|transient|synchronized)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'PROTO_SPECIAL_PROPS', $regexp([$$('REGEXP_START'), "(?:constructor|displayName|__proto__|__parent__|__noSuchMethod__|__count__)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'PROTO_SPECIAL_METHODS', $regexp([$$('REGEXP_START'), "(?:hasOwnProperty|valueOf)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'IMMUTABLE_PROPS', $regexp([$$('REGEXP_START'), "(?:NaN|Infinity|undefined)", $$('REGEXP_END')]).$freeze());
        $const_set($nesting[0], 'BASIC_IDENTIFIER_RULES', $regexp([$$('REGEXP_START'), "[$_a-z][$_a-z\\d]*", $$('REGEXP_END')], 'i').$freeze());
        $const_set($nesting[0], 'RESERVED_FUNCTION_NAMES', $regexp([$$('REGEXP_START'), "(?:Array)", $$('REGEXP_END')]).$freeze());
        $defs(self, '$valid_name?', function $JsReservedWords_valid_name$ques$1(name) {
          var $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = $$('BASIC_IDENTIFIER_RULES')['$=~'](name)))) {
            return ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = $$('ES51_RESERVED_WORD')['$=~'](name))) ? ($ret_or_3) : ($$('ES3_RESERVED_WORD_EXCLUSIVE')['$=~'](name))))) ? ($ret_or_2) : ($$('IMMUTABLE_PROPS')['$=~'](name)))['$!']()
          } else {
            return $ret_or_1
          }
        });
        $defs(self, '$valid_ivar_name?', function $JsReservedWords_valid_ivar_name$ques$2(name) {
          var $ret_or_1 = nil;

          return ($truthy(($ret_or_1 = $$('PROTO_SPECIAL_PROPS')['$=~'](name))) ? ($ret_or_1) : ($$('PROTO_SPECIAL_METHODS')['$=~'](name)))['$!']()
        });
        
        $def(self, '$fix_var_name', function $$fix_var_name(name) {
          var self = this;

          if ($truthy(self.$class()['$valid_name?'](name))) {
            return name
          } else {
            return (("" + (name)) + "$").$to_sym()
          }
        });
        
        $def(self, '$fix_ivar_name', function $$fix_ivar_name(name) {
          var self = this;

          if ($truthy(self.$class()['$valid_ivar_name?'](name.$to_s()['$[]']($range(1, -1, false))))) {
            return name
          } else {
            return (("" + (name)) + "$").$to_sym()
          }
        });
        
        $def(self, '$on_lvar', function $$on_lvar(node) {
          var $a, $yield = $$on_lvar.$$p || nil, self = this, name = nil, _ = nil;

          $$on_lvar.$$p = null;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          node = node.$updated(nil, [self.$fix_var_name(name)]);
          return $send2(self, $find_super(self, 'on_lvar', $$on_lvar, false, true), 'on_lvar', [node], null);
        });
        
        $def(self, '$on_lvasgn', function $$on_lvasgn(node) {
          var $a, $yield = $$on_lvasgn.$$p || nil, self = this, name = nil, value = nil;

          $$on_lvasgn.$$p = null;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          node = ($truthy(value) ? (node.$updated(nil, [self.$fix_var_name(name), value])) : (node.$updated(nil, [self.$fix_var_name(name)])));
          return $send2(self, $find_super(self, 'on_lvasgn', $$on_lvasgn, false, true), 'on_lvasgn', [node], null);
        });
        
        $def(self, '$on_ivar', function $$on_ivar(node) {
          var $a, $yield = $$on_ivar.$$p || nil, self = this, name = nil, _ = nil;

          $$on_ivar.$$p = null;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          node = node.$updated(nil, [self.$fix_ivar_name(name)]);
          return $send2(self, $find_super(self, 'on_ivar', $$on_ivar, false, true), 'on_ivar', [node], null);
        });
        
        $def(self, '$on_ivasgn', function $$on_ivasgn(node) {
          var $a, $yield = $$on_ivasgn.$$p || nil, self = this, name = nil, value = nil;

          $$on_ivasgn.$$p = null;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          node = ($truthy(value) ? (node.$updated(nil, [self.$fix_ivar_name(name), value])) : (node.$updated(nil, [self.$fix_ivar_name(name)])));
          return $send2(self, $find_super(self, 'on_ivasgn', $$on_ivasgn, false, true), 'on_ivasgn', [node], null);
        });
        
        $def(self, '$on_restarg', function $$on_restarg(node) {
          var $a, self = this, name = nil, _ = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          if ($truthy(name)) {
            node = node.$updated(nil, [self.$fix_var_name(name)], (new Map([["meta", (new Map([["arg_name", name]]))]])))
          };
          return node;
        });
        $alias(self, "on_kwrestarg", "on_restarg");
        return $def(self, '$on_argument', function $$on_argument(node) {
          var $a, $yield = $$on_argument.$$p || nil, self = this, name = nil, value = nil, fixed_name = nil, new_children = nil;

          $$on_argument.$$p = null;
          
          node = $send2(self, $find_super(self, 'on_argument', $$on_argument, false, true), 'on_argument', [node], null);
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $a;
          fixed_name = self.$fix_var_name(name);
          new_children = ($truthy(value) ? ([fixed_name, value]) : ([fixed_name]));
          return node.$updated(nil, new_children, (new Map([["meta", (new Map([["arg_name", name]]))]])));
        });
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
