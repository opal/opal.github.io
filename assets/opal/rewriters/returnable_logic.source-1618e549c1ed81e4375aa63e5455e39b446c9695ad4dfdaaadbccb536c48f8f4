Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $def = Opal.def, $rb_minus = Opal.rb_minus, $assign_ivar_val = Opal.assign_ivar_val, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $slice = Opal.slice, $send = Opal.send, $eqeq = Opal.eqeq, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,+,-,children,check_control_flow!,[]=,meta,s,next_tmp,build_if_from_when,free_tmp,[],process,updated,==,count,first,delete,private,type,error,build_rule_from_parts,empty?');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'ReturnableLogic');

        var $proto = self.$$prototype;

        $proto.counter = nil;
        
        
        $def(self, '$next_tmp', function $$next_tmp() {
          var self = this, $ret_or_1 = nil;

          
          self.counter = ($truthy(($ret_or_1 = self.counter)) ? ($ret_or_1) : (0));
          self.counter = $rb_plus(self.counter, 1);
          return "$ret_or_" + (self.counter);
        });
        
        $def(self, '$free_tmp', function $$free_tmp() {
          var self = this;

          return (self.counter = $rb_minus(self.counter, 1))
        });
        
        $def(self, '$reset_tmp_counter!', $assign_ivar_val("counter", nil));
        
        $def(self, '$on_if', function $$on_if(node) {
          var $a, $yield = $$on_if.$$p || nil, self = this, test = nil;

          $$on_if.$$p = null;
          
          $a = [].concat($to_a(node.$children())), (test = ($a[0] == null ? nil : $a[0])), $a;
          self['$check_control_flow!'](test);
          if ($truthy(test)) {
            test.$meta()['$[]=']("if_test", true)
          };
          return $send2(self, $find_super(self, 'on_if', $$on_if, false, true), 'on_if', [node], $yield);
        });
        
        $def(self, '$on_case', function $$on_case(node) {
          var $a, $b, self = this, lhs = nil, whens = nil, els = nil, $ret_or_1 = nil, lhs_tmp = nil, out = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (whens = $slice($a, 1, $b)), (els = ($a[$b] == null ? nil : $a[$b])), $a;
          els = ($truthy(($ret_or_1 = els)) ? ($ret_or_1) : (self.$s("nil")));
          if ($truthy(lhs)) {
            lhs_tmp = self.$next_tmp()
          };
          out = self.$build_if_from_when(node, lhs, lhs_tmp, whens, els);
          if ($truthy(lhs)) {
            self.$free_tmp()
          };
          return out;
        });
        
        $def(self, '$on_or', function $$on_or(node) {
          var $a, self = this, lhs = nil, rhs = nil, out = nil, lhs_tmp = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          self['$check_control_flow!'](lhs);
          if ($truthy(node.$meta()['$[]']("if_test"))) {
            
            lhs.$meta()['$[]=']("if_test", ($a = ["if_test", true], $send(rhs.$meta(), '[]=', $a), $a[$a.length - 1]));
            out = self.$process(node.$updated("if", [lhs, self.$s("true"), rhs]));
          } else {
            
            lhs_tmp = self.$next_tmp();
            out = self.$process(node.$updated("if", [self.$s("lvasgn", lhs_tmp, lhs), self.$s("js_tmp", lhs_tmp), rhs]));
            self.$free_tmp();
          };
          return out;
        });
        
        $def(self, '$on_and', function $$on_and(node) {
          var $a, self = this, lhs = nil, rhs = nil, out = nil, lhs_tmp = nil;

          
          $a = [].concat($to_a(node.$children())), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
          self['$check_control_flow!'](lhs);
          if ($truthy(node.$meta()['$[]']("if_test"))) {
            
            lhs.$meta()['$[]=']("if_test", ($a = ["if_test", true], $send(rhs.$meta(), '[]=', $a), $a[$a.length - 1]));
            out = self.$process(node.$updated("if", [lhs, rhs, self.$s("false")]));
          } else {
            
            lhs_tmp = self.$next_tmp();
            out = self.$process(node.$updated("if", [self.$s("lvasgn", lhs_tmp, lhs), rhs, self.$s("js_tmp", lhs_tmp)]));
            self.$free_tmp();
          };
          return out;
        });
        
        $def(self, '$on_begin', function $$on_begin(node) {
          var $yield = $$on_begin.$$p || nil, self = this;

          $$on_begin.$$p = null;
          
          if (($truthy(node.$meta()['$[]']("if_test")) && ($eqeq(node.$children().$count(), 1)))) {
            node.$children().$first().$meta()['$[]=']("if_test", true)
          };
          node.$meta().$delete("if_test");
          return $send2(self, $find_super(self, 'on_begin', $$on_begin, false, true), 'on_begin', [node], $yield);
        });
        self.$private();
        
        $def(self, '$check_control_flow!', function $ReturnableLogic_check_control_flow$excl$1(node) {
          var self = this;

          
          switch (node.$type().valueOf()) {
            case "break":
            case "next":
            case "redo":
            case "retry":
            case "return":
              return self.$error("void value expression")
            default:
              return nil
          }
        });
        
        $def(self, '$build_if_from_when', function $$build_if_from_when(node, lhs, lhs_tmp, whens, els) {
          var $a, $b, self = this, first_when = nil, next_whens = nil, parts = nil, expr = nil, rule = nil;

          
          $a = [].concat($to_a(whens)), (first_when = ($a[0] == null ? nil : $a[0])), (next_whens = $slice($a, 1)), $a;
          $a = [].concat($to_a(first_when.$children())), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (parts = $slice($a, 0, $b)), (expr = ($a[$b] == null ? nil : $a[$b])), $a;
          rule = self.$build_rule_from_parts(node, lhs, lhs_tmp, parts);
          return first_when.$updated("if", [rule, self.$process(expr), ($truthy(next_whens['$empty?']()) ? (self.$process(els)) : (self.$build_if_from_when(nil, nil, lhs_tmp, next_whens, els)))]);
        });
        return $def(self, '$build_rule_from_parts', function $$build_rule_from_parts(node, lhs, lhs_tmp, parts) {
          var $a, self = this, first_part = nil, next_parts = nil, subrule = nil, splat_on = nil, iter_val = nil, block = nil;

          
          lhs = (($truthy(node) && ($truthy(lhs_tmp))) ? (node.$updated("lvasgn", [lhs_tmp, self.$process(lhs)])) : (self.$s("js_tmp", lhs_tmp)));
          $a = [].concat($to_a(parts)), (first_part = ($a[0] == null ? nil : $a[0])), (next_parts = $slice($a, 1)), $a;
          subrule = ($eqeq(first_part.$type(), "splat") ? (((splat_on = first_part.$children().$first()), (iter_val = self.$next_tmp()), (block = self.$s("send", self.$process(splat_on), "any?", self.$s("iter", self.$s("args", self.$s("arg", iter_val)), self.$build_rule_from_parts(nil, nil, lhs_tmp, [self.$s("lvar", iter_val)])))), (($truthy(node) && ($truthy(lhs_tmp))) ? (self.$s("begin", lhs, block)) : (block)))) : ($truthy(lhs_tmp) ? (self.$s("send", self.$process(first_part), "===", lhs)) : (self.$process(first_part))));
          if ($truthy(next_parts['$empty?']())) {
            return subrule
          } else {
            return self.$s("if", subrule, self.$s("true"), self.$build_rule_from_parts(nil, nil, lhs_tmp, next_parts))
          };
        });
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
