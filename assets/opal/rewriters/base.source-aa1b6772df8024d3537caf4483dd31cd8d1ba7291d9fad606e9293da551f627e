Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $def = Opal.def, $return_self = Opal.return_self, $return_val = Opal.return_val, $const_set = Opal.const_set, $truthy = Opal.truthy, $Opal = Opal.Opal, $defs = Opal.defs, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $send = Opal.send, $to_a = Opal.to_a, $send2 = Opal.send2, $find_super = Opal.find_super, $assign_ivar_val = Opal.assign_ivar_val, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,new,current_node,loc,process_regular_node,on_send,+,stmts_of,begin_with_stmts,nil?,include?,type,children,length,[],s,attr_accessor,current_node=,location=,raise,[]=,meta');
  
  self.$require("parser");
  self.$require("opal/ast/node");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.dynamic_cache_result = nil;
        
        (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'DummyLocation');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          
          $def(self, '$node=', function $DummyLocation_node$eq$1($a) {
            var $post_args, $fwd_rest;

            
            $post_args = $slice(arguments);
            $fwd_rest = $post_args;
            return nil;
          }, -1);
          
          $def(self, '$expression', $return_self);
          
          $def(self, '$begin_pos', $return_val(0));
          
          $def(self, '$end_pos', $return_val(0));
          
          $def(self, '$source', $return_val(""));
          
          $def(self, '$line', $return_val(0));
          
          $def(self, '$column', $return_val(0));
          return $def(self, '$last_line', function $$last_line() {
            
            return $$$($$('Float'), 'INFINITY')
          });
        })($nesting[0], null, $nesting);
        $const_set($nesting[0], 'DUMMY_LOCATION', $$('DummyLocation').$new());
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children, self = this, loc = nil;

          
          $post_args = $slice(arguments, 1);
          children = $post_args;
          loc = ($truthy(self.$current_node()) ? (self.$current_node().$loc()) : ($$('DUMMY_LOCATION')));
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, (new Map([["location", loc]])));
        }, -2);
        $defs(self, '$s', function $$s(type, $a) {
          var $post_args, children;

          
          $post_args = $slice(arguments, 1);
          children = $post_args;
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, (new Map([["location", $$('DUMMY_LOCATION')]])));
        }, -2);
        $alias(self, "on_iter", "process_regular_node");
        $alias(self, "on_zsuper", "process_regular_node");
        $alias(self, "on_jscall", "on_send");
        $alias(self, "on_jsattr", "process_regular_node");
        $alias(self, "on_jsattrasgn", "process_regular_node");
        $alias(self, "on_kwsplat", "process_regular_node");
        
        $def(self, '$prepend_to_body', function $$prepend_to_body(body, node) {
          var self = this, stmts = nil;

          
          stmts = $rb_plus(self.$stmts_of(node), self.$stmts_of(body));
          return self.$begin_with_stmts(stmts);
        });
        
        $def(self, '$append_to_body', function $$append_to_body(body, node) {
          var self = this, stmts = nil;

          
          stmts = $rb_plus(self.$stmts_of(body), self.$stmts_of(node));
          return self.$begin_with_stmts(stmts);
        });
        
        $def(self, '$stmts_of', function $$stmts_of(node) {
          
          if ($truthy(node['$nil?']())) {
            return []
          } else if ($truthy(["begin", "kwbegin"]['$include?'](node.$type()))) {
            return node.$children()
          } else {
            return [node]
          }
        });
        
        $def(self, '$begin_with_stmts', function $$begin_with_stmts(stmts) {
          var self = this;

          
          switch (stmts.$length().valueOf()) {
            case 0:
              return nil
            case 1:
              return stmts['$[]'](0)
            default:
              return $send(self, 's', ["begin"].concat($to_a(stmts)))
          }
        });
        self.$attr_accessor("current_node");
        
        $def(self, '$process', function $$process(node) {
          var $a, $yield = $$process.$$p || nil, self = this;

          $$process.$$p = null;
          return (function() { try {
          
          self['$current_node='](node);
          return $send2(self, $find_super(self, 'process', $$process, false, true), 'process', [node], $yield);
          } finally {
            ($a = [nil], $send(self, 'current_node=', $a), $a[$a.length - 1])
          }; })()
        });
        
        $def(self, '$error', function $$error(msg) {
          var self = this, error = nil;

          
          error = $$$($Opal, 'RewritingError').$new(msg);
          if ($truthy(self.$current_node())) {
            error['$location='](self.$current_node().$loc())
          };
          return self.$raise(error);
        });
        
        $def(self, '$on_top', function $$on_top(node) {
          var self = this;

          
          node = self.$process_regular_node(node);
          if ($truthy(self.dynamic_cache_result)) {
            node.$meta()['$[]=']("dynamic_cache_result", true)
          };
          return node;
        });
        return $def(self, '$dynamic!', $assign_ivar_val("dynamic_cache_result", true));
      })($nesting[0], $$$($$$($$$('Parser'), 'AST'), 'Processor'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
