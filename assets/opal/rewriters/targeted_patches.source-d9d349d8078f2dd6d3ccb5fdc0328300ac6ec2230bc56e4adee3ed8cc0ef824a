Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $range = Opal.range, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $rb_gt = Opal.rb_gt, $send = Opal.send, $not = Opal.not, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,>=,length,children,==,type,last,first,updated,[],<<,>,all?,include?,=~,to_s,!,cover?,join,map,s');
  
  self.$require("opal/rewriters/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Rewriters');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'TargetedPatches');

        
        
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, $b, $yield = $$on_def.$$p || nil, self = this, name = nil, args = nil, body = nil, calls = nil, assignment = nil, ret = nil;

          $$on_def.$$p = null;
          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (args = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          if ((($truthy(body) && ($eqeq(body.$type(), "begin"))) && ($truthy($rb_ge(body.$children().$length(), 2))))) {
            
            calls = body.$children();
            $b = calls.$last(2), $a = $to_ary($b), (assignment = ($a[0] == null ? nil : $a[0])), (ret = ($a[1] == null ? nil : $a[1])), $b;
            if ((($eqeq(assignment.$type(), "lvasgn") && ($eqeq(ret.$type(), "lvar"))) && ($eqeq(assignment.$children().$first(), ret.$children().$first())))) {
              if ($eqeq(calls.$length(), 2)) {
                return node.$updated(nil, [name, args, assignment.$children()['$[]'](1)])
              } else {
                
                calls = calls['$[]']($range(0, -3, false))['$<<'](assignment.$children()['$[]'](1));
                return node.$updated(nil, [name, args, body.$updated(nil, calls)]);
              }
            } else {
              return $send2(self, $find_super(self, 'on_def', $$on_def, false, true), 'on_def', [node], $yield)
            };
          } else {
            return $send2(self, $find_super(self, 'on_def', $$on_def, false, true), 'on_def', [node], $yield)
          };
        });
        return $def(self, '$on_array', function $$on_array(node) {
          var $yield = $$on_array.$$p || nil, self = this, children = nil, ssin_array = nil, str = nil;

          $$on_array.$$p = null;
          
          children = node.$children();
          if ($truthy($rb_gt(children.$length(), 32))) {
            
            ssin_array = $send(children, 'all?', [], function $$1(child){
              
              if (child == null) child = nil;
              if (!$truthy(["str", "sym", "int", "nil"]['$include?'](child.$type()))) {
                return false
              };
              if (($truthy(["str", "sym"]['$include?'](child.$type())) && ($truthy(child.$children().$first().$to_s()['$=~'](/^[0-9-]|^$|,/))))) {
                return false
              };
              if (($eqeq(child.$type(), "int") && ($not($range(-1000000, 1000000, false)['$cover?'](child.$children().$first()))))) {
                return false
              };
              return true;});
            if ($truthy(ssin_array)) {
              
              str = $send(children, 'map', [], function $$2(i){
                
                if (i == null) i = nil;
                return i.$children().$first().$to_s();}).$join(",");
              return node.$updated("jscall", [self.$s("js_tmp", "Opal"), "large_array_unpack", self.$s("sym", str)]);
            } else {
              return $send2(self, $find_super(self, 'on_array', $$on_array, false, true), 'on_array', [node], $yield)
            };
          } else {
            return $send2(self, $find_super(self, 'on_array', $$on_array, false, true), 'on_array', [node], $yield)
          };
        });
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
