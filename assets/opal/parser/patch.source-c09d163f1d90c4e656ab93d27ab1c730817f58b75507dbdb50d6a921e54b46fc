Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $not = Opal.not, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $thrower = Opal.thrower, $module = Opal.module, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('source,unpack,source_buffer=,source_pts=,+,to_a,lines,end_with?,<<,map,chomp,=~,diagnostic,nil?,new,type,updated,dedent,first,children,==,empty?,interrupt,compact,encoding,split,force_encoding,length,map!,each_with_index,!,each_char,<=,===,-,>,*,/,[]=,[],join,respond_to?,send,value');
  
  
  (function($base, $super) {
    var self = $klass($base, $super, 'Lexer');

    var $proto = self.$$prototype;

    $proto.source_buffer = $proto.strings = $proto.source_pts = nil;
    return $def(self, '$source_buffer=', function $Lexer_source_buffer$eq$1(source_buffer) {
      var $a, self = this, source = nil;

      
      self.source_buffer = source_buffer;
      if ($truthy(self.source_buffer)) {
        
        source = self.source_buffer.$source();
        self.source_pts = source.$unpack("U*");
      } else {
        self.source_pts = nil
      };
      if ($truthy(self.strings)) {
        
        self.strings['$source_buffer='](self.source_buffer);
        return ($a = [self.source_pts], $send(self.strings, 'source_pts=', $a), $a[$a.length - 1]);
      } else {
        return nil
      };
    })
  })($$('Parser'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Literal');

    var $proto = self.$$prototype;

    $proto.buffer_s = $proto.buffer = nil;
    
    
    Opal.udef(self, '$' + "extend_string");;
    return $def(self, '$extend_string', function $$extend_string(string, ts, te) {
      var self = this, $ret_or_1 = nil;

      
      self.buffer_s = ($truthy(($ret_or_1 = self.buffer_s)) ? ($ret_or_1) : (ts));
      self.buffer_e = te;
      return (self.buffer = $rb_plus(self.buffer, string));
    });
  })($$$($$('Parser'), 'Lexer'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Buffer');

    var $proto = self.$$prototype;

    $proto.lines = $proto.source = nil;
    return $def(self, '$source_lines', function $$source_lines() {
      var self = this, $ret_or_1 = nil, lines = nil;

      return (self.lines = ($truthy(($ret_or_1 = self.lines)) ? ($ret_or_1) : (((lines = self.source.$lines().$to_a()), ($truthy(self.source['$end_with?']("\n")) ? (lines['$<<']("")) : nil), $send(lines, 'map', [], function $$2(line){
        
        if (line == null) line = nil;
        return line.$chomp("\n");})))))
    })
  })($$$($$('Parser'), 'Source'), null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Default');

    
    
    
    $def(self, '$check_lvar_name', function $$check_lvar_name(name, loc) {
      var self = this;

      if ($truthy(name['$=~'](new RegExp('^[\\p{Ll}|_][\\p{L}\\p{Nl}\\p{Nd}_]*$', 'u')))) {
        return nil
      } else {
        return self.$diagnostic("error", "lvar_name", (new Map([["name", name]])), loc)
      }
    });
    return $def(self, '$dedent_string', function $$dedent_string(node, dedent_level) {
      var dedenter = nil, children = nil;

      
      if (!$truthy(dedent_level['$nil?']())) {
        
        dedenter = $$$($$$($$$('Parser'), 'Lexer'), 'Dedenter').$new(dedent_level);
        
        switch (node.$type().valueOf()) {
          case "str":
            node = node.$updated(nil, [dedenter.$dedent(node.$children().$first())])
            break;
          case "dstr":
          case "xstr":
            
            children = $send(node.$children(), 'map', [], function $$3(str_node){
              
              if (str_node == null) str_node = nil;
              if ($eqeq(str_node.$type(), "str")) {
                
                str_node = str_node.$updated(nil, [dedenter.$dedent(str_node.$children().$first())]);
                if ($truthy(str_node.$children().$first()['$empty?']())) {
                  return nil
                };
              } else {
                dedenter.$interrupt()
              };
              return str_node;});
            node = node.$updated(nil, children.$compact());
            break;
          default:
            nil
        };
      };
      return node;
    });
  })($$$($$('Parser'), 'Builders'), null);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dedenter');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$dedent', function $$dedent(string) {
      var self = this, original_encoding = nil, lines = nil;

      
      original_encoding = string.$encoding();
      lines = string.$force_encoding($$$($$('Encoding'), 'BINARY')).$split("\\\n");
      if ($eqeq(lines.$length(), 1)) {
        lines = [string.$force_encoding(original_encoding)]
      } else {
        $send(lines, 'map!', [], function $$4(s){
          
          if (s == null) s = nil;
          return s.$force_encoding(original_encoding);})
      };
      $send(lines, 'each_with_index', [], function $$5(line, index){var $a, self = $$5.$$s == null ? this : $$5.$$s, left_to_remove = nil, remove = nil;
        if (self.at_line_begin == null) self.at_line_begin = nil;
        if (self.dedent_level == null) self.dedent_level = nil;

        
        if (line == null) line = nil;
        if (index == null) index = nil;
        if (($eqeq(index, 0) && ($not(self.at_line_begin)))) {
          return nil
        };
        left_to_remove = self.dedent_level;
        remove = 0;
        (function(){try { var $t_break = $thrower('break'); return $send(line, 'each_char', [], function $$6(char$){var self = $$6.$$s == null ? this : $$6.$$s, $ret_or_1 = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          if (char$ == null) char$ = nil;
          if ($truthy($rb_le(left_to_remove, 0))) {
            $t_break.$throw(nil, $$6.$$is_lambda)
          };
          if ($eqeqeq(" ", ($ret_or_1 = char$))) {
            
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, 1));
          } else if ($eqeqeq("\t", $ret_or_1)) {
            
            if ($truthy($rb_gt($rb_times($$('TAB_WIDTH'), $rb_plus($rb_divide(remove, $$('TAB_WIDTH')), 1)), self.dedent_level))) {
              $t_break.$throw(nil, $$6.$$is_lambda)
            };
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, $$('TAB_WIDTH')));
          } else {
            $t_break.$throw(nil, $$6.$$is_lambda)
          };}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
        return ($a = [index, line['$[]'](Opal.Range.$new(remove, -1, false))], $send(lines, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
      string = lines.$join();
      self.at_line_begin = string['$end_with?']("\n");
      return string;
    })
  })($$$($$('Parser'), 'Lexer'), null, $nesting);;
  (function($base) {
    var self = $module($base, 'Mixin');

    
    
    
    Opal.udef(self, '$' + "process");;
    return $def(self, '$process', function $$process(node) {
      var $a, self = this, $ret_or_1 = nil, type = nil, on_handler = nil, handler = nil;
      if (self._on_handler_cache == null) self._on_handler_cache = nil;

      
      if ($truthy(node['$nil?']())) {
        return nil
      };
      self._on_handler_cache = ($truthy(($ret_or_1 = self._on_handler_cache)) ? ($ret_or_1) : ((new Map())));
      type = node.$type();
      on_handler = ($truthy(($ret_or_1 = self._on_handler_cache['$[]'](type))) ? ($ret_or_1) : (($a = [type, ((handler = "on_" + (type)), ($truthy(self['$respond_to?'](handler)) ? (nil) : ((handler = "handler_missing"))), handler)], $send(self._on_handler_cache, '[]=', $a), $a[$a.length - 1])));
      if ($truthy(($ret_or_1 = self.$send(on_handler, node)))) {
        return $ret_or_1
      } else {
        return node
      };
    });
  })($$$($$('AST'), 'Processor'));
  return (function($base, $super) {
    var self = $klass($base, $super, 'Default');

    
    
    
    Opal.udef(self, '$' + "string_value");;
    return $def(self, '$string_value', function $$string_value(token) {
      var self = this;

      return self.$value(token)
    });
  })($$$($$('Parser'), 'Builders'), null);
});
