Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $not = Opal.not, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,to_s,inspect,type,[],meta,source_map_name_for,sexp,==,class,+,parent,>,!,first,children,loc,respond_to?,dot,selector,operator,begin,line,location,column');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Fragment');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.code = $proto.scope = $proto.sexp = nil;
      
      self.$attr_reader("code");
      
      $def(self, '$initialize', function $$initialize(code, scope, sexp) {
        var self = this;

        
        if (sexp == null) sexp = nil;
        self.code = code.$to_s();
        self.sexp = sexp;
        return (self.scope = scope);
      }, -3);
      
      $def(self, '$inspect', function $$inspect() {
        var self = this;

        return "f(" + (self.code.$inspect()) + ")"
      });
      
      $def(self, '$source_map_name_for', function $$source_map_name_for(sexp) {
        var $a, self = this, scope = nil, iters = nil, level = nil, const$ = nil, name = nil;

        
        switch (sexp.$type().valueOf()) {
          case "top":
            
            switch (sexp.$meta()['$[]']("kind").valueOf()) {
              case "require":
                return "<top (required)>"
              case "eval":
                return "(eval)"
              case "main":
                return "<main>"
              default:
                return nil
            }
            break;
          case "begin":
          case "newline":
          case "js_return":
            if ($truthy(self.scope)) {
              return self.$source_map_name_for(self.scope.$sexp())
            } else {
              return nil
            }
            break;
          case "iter":
            
            scope = self.scope;
            iters = 1;
            while ($truthy(scope)) {
            if ($eqeq(scope.$class(), $$$($$('Nodes'), 'IterNode'))) {
                
                iters = $rb_plus(iters, 1);
                scope = scope.$parent();
              } else {
                break
              }
            };
            if ($truthy($rb_gt(iters, 1))) {
              level = " (" + (iters) + " levels)"
            };
            return "block" + (level) + " in " + (self.$source_map_name_for(scope.$sexp()));
          case "self":
            return "self"
          case "module":
            
            $a = [].concat($to_a(sexp)), (const$ = ($a[0] == null ? nil : $a[0])), $a;
            return "<module:" + (self.$source_map_name_for(const$)) + ">";
          case "class":
            
            $a = [].concat($to_a(sexp)), (const$ = ($a[0] == null ? nil : $a[0])), $a;
            return "<class:" + (self.$source_map_name_for(const$)) + ">";
          case "const":
            
            $a = [].concat($to_a(sexp)), (scope = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $a;
            if (($not(scope) || ($eqeq(scope.$type(), "cbase")))) {
              return name.$to_s()
            } else {
              return "" + (self.$source_map_name_for(scope)) + "::" + (name)
            };
            break;
          case "int":
            return sexp.$children().$first()
          case "def":
            return sexp.$children().$first()
          case "defs":
            return sexp.$children()['$[]'](1)
          case "send":
            return sexp.$children()['$[]'](1)
          case "lvar":
          case "lvasgn":
          case "lvdeclare":
          case "ivar":
          case "ivasgn":
          case "gvar":
          case "cvar":
          case "cvasgn":
          case "gvars":
          case "gvasgn":
          case "arg":
            return sexp.$children().$first()
          case "str":
          case "xstr":
            return self.$source_map_name_for(self.scope.$sexp())
          default:
            return nil
        }
      });
      
      $def(self, '$source_map_name', function $$source_map_name() {
        var self = this;

        
        if (!$truthy(self.sexp)) {
          return nil
        };
        return self.$source_map_name_for(self.sexp);
      });
      
      $def(self, '$location', function $$location() {
        var self = this, loc = nil, $ret_or_1 = nil;

        if ($not(self.sexp)) {
          return nil
        } else if ($eqeq(self.sexp.$type(), "send")) {
          
          loc = self.sexp.$loc();
          if ($truthy(loc['$respond_to?']("dot"))) {
            if ($truthy(($ret_or_1 = loc.$dot()))) {
              return $ret_or_1
            } else {
              return loc.$selector()
            }
          } else if ($truthy(loc['$respond_to?']("operator"))) {
            return loc.$operator()
          } else {
            return self.sexp
          };
        } else if ($eqeq(self.sexp.$type(), "iter")) {
          if ($truthy(loc['$respond_to?']("begin"))) {
            return self.sexp.$loc().$begin()
          } else {
            return self.sexp
          }
        } else {
          return self.sexp
        }
      });
      
      $def(self, '$line', function $$line() {
        var $a, self = this;

        return ($a = self.$location(), ($a === nil || $a == null) ? nil : $a.$line())
      });
      
      $def(self, '$column', function $$column() {
        var $a, self = this;

        return ($a = self.$location(), ($a === nil || $a == null) ? nil : $a.$column())
      });
      return $def(self, '$skip_source_map?', function $Fragment_skip_source_map$ques$1() {
        var self = this;

        return self.sexp['$=='](false)
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
});
