Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $def = Opal.def, $ensure_kwargs = Opal.ensure_kwargs, $kwrestargs = Opal.kwrestargs, $truthy = Opal.truthy, $defs = Opal.defs, $eqeq = Opal.eqeq, $thrower = Opal.thrower, $lambda = Opal.lambda, $range = Opal.range, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new,instance_exec,to_proc,when,helper,name,transform,[],[]=,<<,select,include?,for,arity_check?,compiler,compile_body,is_a?,each,shortcuts_for,match?,==,mid,warn,compile,define_shortcut,type,stmts,push,simple_value?,expr,to_sym,to_s,first,children,updated,length,inline_args,last');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'NodeWithArgs');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'Shortcut', $send($$('Struct'), 'new', ["name", "for", "when", "transform"], function $NodeWithArgs$1(){var self = $NodeWithArgs$1.$$s == null ? this : $NodeWithArgs$1.$$s;

          
          
          $def(self, '$match?', function $match$ques$2(node) {
            var self = this;

            return $send(node, 'instance_exec', [], self.$when().$to_proc())
          });
          return $def(self, '$compile', function $$compile(node) {
            var self = this;

            
            node.$helper(self.$name());
            return $send(node, 'instance_exec', [], self.$transform().$to_proc());
          });}, {$$s: self}));
        self.shortcuts = [];
        self.shortcuts_for = (new Map());
        $defs(self, '$define_shortcut', function $$define_shortcut(name, $kwargs) {
          var block = $$define_shortcut.$$p || nil, kwargs, self = this, $ret_or_1 = nil;
          if (self.shortcuts == null) self.shortcuts = nil;

          $$define_shortcut.$$p = null;
          
          ;
          $kwargs = $ensure_kwargs($kwargs);
          kwargs = $kwrestargs($kwargs, {});
          if ($truthy(($ret_or_1 = kwargs['$[]']("for")))) {
            $ret_or_1
          } else {
            kwargs['$[]=']("for", "def")
          };
          return self.shortcuts['$<<']($$('Shortcut').$new(name, kwargs['$[]']("for"), kwargs['$[]']("when"), block));
        }, -2);
        $defs(self, '$shortcuts_for', function $$shortcuts_for(node_type) {
          var $a, self = this, $ret_or_1 = nil;
          if (self.shortcuts_for == null) self.shortcuts_for = nil;
          if (self.shortcuts == null) self.shortcuts = nil;

          if ($truthy(($ret_or_1 = self.shortcuts_for['$[]'](node_type)))) {
            return $ret_or_1
          } else {
            return ($a = [node_type, $send(self.shortcuts, 'select', [], function $$3(shortcut){
              
              if (shortcut == null) shortcut = nil;
              return [node_type, "*"]['$include?'](shortcut.$for());})], $send(self.shortcuts_for, '[]=', $a), $a[$a.length - 1])
          }
        });
        
        $def(self, '$compile_body_or_shortcut', function $$compile_body_or_shortcut() {try { var $t_return = $thrower('return'); 
          var self = this, node_type = nil;

          
          if ($truthy(self.$compiler()['$arity_check?']())) {
            return self.$compile_body()
          };
          node_type = ($truthy(self['$is_a?']($$('DefNode'))) ? ("def") : ("iter"));
          $send($$('NodeWithArgs').$shortcuts_for(node_type), 'each', [], function $$4(shortcut){var self = $$4.$$s == null ? this : $$4.$$s, node_desc = nil;

            
            if (shortcut == null) shortcut = nil;
            if ($truthy(shortcut['$match?'](self))) {
              
              if ($truthy($$('ENV')['$[]']("OPAL_DEBUG_SHORTCUTS"))) {
                
                node_desc = ($eqeq(node_type, "def") ? ("def " + (self.$mid())) : ("iter"));
                self.$warn("* shortcut " + (shortcut.$name()) + " used for " + (node_desc));
              };
              $t_return.$throw(shortcut.$compile(self), $$4.$$is_lambda);
            } else {
              return nil
            };}, {$$s: self, $$ret: $t_return});
          return self.$compile_body();} catch($e) {
            if ($e === $t_return) return $e.$v;
            throw $e;
          } finally {$t_return.is_orphan = true;}
        });
        $send(self, 'define_shortcut', ["return_self", (new Map([["when", $lambda(function $NodeWithArgs$5(){var self = $NodeWithArgs$5.$$s == null ? this : $NodeWithArgs$5.$$s;

          return self.$stmts().$type()['$==']("self")}, {$$s: self})]]))], function $NodeWithArgs$6(){var self = $NodeWithArgs$6.$$s == null ? this : $NodeWithArgs$6.$$s;

          return self.$push("$return_self")}, {$$s: self});
        
        $def(self, '$simple_value?', function $NodeWithArgs_simple_value$ques$7(node) {
          var self = this;

          
          if (node == null) node = self.$stmts();
          return ["true", "false", "nil", "int", "float", "str", "sym"]['$include?'](node.$type());
        }, -1);
        $send(self, 'define_shortcut', ["return_val", (new Map([["for", "*"], ["when", $lambda(function $NodeWithArgs$8(){var self = $NodeWithArgs$8.$$s == null ? this : $NodeWithArgs$8.$$s;

          return self['$simple_value?']()}, {$$s: self})]]))], function $NodeWithArgs$9(){var self = $NodeWithArgs$9.$$s == null ? this : $NodeWithArgs$9.$$s;

          return self.$push("$return_val(", self.$expr(self.$stmts()), ")")}, {$$s: self});
        $send(self, 'define_shortcut', ["return_ivar", (new Map([["when", $lambda(function $NodeWithArgs$10(){var self = $NodeWithArgs$10.$$s == null ? this : $NodeWithArgs$10.$$s;

          return self.$stmts().$type()['$==']("ivar")}, {$$s: self})]]))], function $NodeWithArgs$11(){var self = $NodeWithArgs$11.$$s == null ? this : $NodeWithArgs$11.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          return self.$push("$return_ivar(", self.$expr(self.$stmts().$updated("sym", [name])), ")");}, {$$s: self});
        $send(self, 'define_shortcut', ["assign_ivar", (new Map([["when", $lambda(function $NodeWithArgs$12(){var self = $NodeWithArgs$12.$$s == null ? this : $NodeWithArgs$12.$$s, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = self.$stmts().$type()['$==']("ivasgn"))) ? (self.$inline_args().$children().$length()['$=='](1)) : ($ret_or_4)))) ? (self.$inline_args().$children().$last().$type()['$==']("arg")) : ($ret_or_3)))) ? (self.$stmts().$children().$last().$type()['$==']("lvar")) : ($ret_or_2))))) {
            return self.$stmts().$children().$last().$children().$last()['$=='](self.$inline_args().$children().$last().$children().$last())
          } else {
            return $ret_or_1
          }}, {$$s: self})]]))], function $NodeWithArgs$13(){var self = $NodeWithArgs$13.$$s == null ? this : $NodeWithArgs$13.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          name = self.$expr(self.$stmts().$updated("sym", [name]));
          return self.$push("$assign_ivar(", name, ")");}, {$$s: self});
        return $send(self, 'define_shortcut', ["assign_ivar_val", (new Map([["when", $lambda(function $NodeWithArgs$14(){var self = $NodeWithArgs$14.$$s == null ? this : $NodeWithArgs$14.$$s, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.$stmts().$type()['$==']("ivasgn")))) {
            return self['$simple_value?'](self.$stmts().$children().$last())
          } else {
            return $ret_or_1
          }}, {$$s: self})]]))], function $NodeWithArgs$15(){var self = $NodeWithArgs$15.$$s == null ? this : $NodeWithArgs$15.$$s, name = nil;

          
          name = self.$stmts().$children().$first().$to_s()['$[]']($range(1, -1, false)).$to_sym();
          name = self.$expr(self.$stmts().$updated("sym", [name]));
          return self.$push("$assign_ivar_val(", name, ", ", self.$expr(self.$stmts().$children().$last()), ")");}, {$$s: self});
      })($nesting[0], $$('ScopeNode'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
