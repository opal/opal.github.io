Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handle,thrower,value,size,children,s,first,in_while?,compile_while,iter?,scope,compile_iter,push,[],while_loop,helper,identity,==,empty_splat?,recv,nil?,>,return_val,expr,to_s');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'NextNode');

        
        
        self.$handle("next");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$thrower("next", self.$value())
        });
        return $def(self, '$value', function $$value() {
          var self = this;

          
          switch (self.$children().$size().valueOf()) {
            case 0:
              return self.$s("nil")
            case 1:
              return self.$children().$first()
            default:
              return $send(self, 's', ["array"].concat($to_a(self.$children())))
          }
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'BreakNode');

        
        
        self.$handle("break");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$thrower("break", self.$value())
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'RedoNode');

        
        
        self.$handle("redo");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$in_while?']())) {
            return self.$compile_while()
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$compile_iter()
          } else {
            return self.$push("REDO()")
          }
        });
        
        $def(self, '$compile_while', function $$compile_while() {
          var self = this;

          
          self.$push("" + (self.$while_loop()['$[]']("redo_var")) + " = true;");
          return self.$thrower("redo");
        });
        return $def(self, '$compile_iter', function $$compile_iter() {
          var self = this;

          
          self.$helper("slice");
          return self.$push("return " + (self.$scope().$identity()) + ".apply(null, $slice(arguments))");
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'SplatNode');

        
        
        self.$handle("splat");
        self.$children("value");
        
        $def(self, '$empty_splat?', function $SplatNode_empty_splat$ques$1() {
          var self = this;

          return self.$value()['$=='](self.$s("array"))
        });
        return $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self['$empty_splat?']())) {
            return self.$push("[]")
          } else {
            
            self.$helper("to_a");
            return self.$push("$to_a(", self.$recv(self.$value()), ")");
          }
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'RetryNode');

        
        
        self.$handle("retry");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$thrower("retry")
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'ReturnNode');

        
        
        self.$handle("return");
        self.$children("value");
        
        $def(self, '$return_val', function $$return_val() {
          var self = this;

          if ($truthy(self.$value()['$nil?']())) {
            return self.$s("nil")
          } else if ($truthy($rb_gt(self.$children().$size(), 1))) {
            return $send(self, 's', ["array"].concat($to_a(self.$children())))
          } else {
            return self.$value()
          }
        });
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$thrower("return", self.$return_val())
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JSReturnNode');

        
        
        self.$handle("js_return");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$push("return ");
          return self.$push(self.$expr(self.$value()));
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JSTempNode');

        
        
        self.$handle("js_tmp");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$value().$to_s())
        });
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'BlockPassNode');

        
        
        self.$handle("block_pass");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$expr(self.$s("send", self.$value(), "to_proc", self.$s("arglist"))))
        });
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
