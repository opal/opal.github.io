Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $rb_plus = Opal.rb_plus, $send = Opal.send, $slice = Opal.slice, $to_a = Opal.to_a, $eqeq = Opal.eqeq, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,valid_name?,inspect,=~,to_s,+,indent,compiler,to_proc,parser_indent,push,fragment,current_indent,js_truthy_optimize,helper,expr,type,[],handlers,include?,truthy_optimize?,==,count,record_method_call,first,children,s,[]=,meta');
  
  self.$require("opal/regexp_anchors");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Helpers');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$property', function $$property(name) {
          var self = this;

          if ($truthy(self['$valid_name?'](name))) {
            return "." + (name)
          } else {
            return "[" + (name.$inspect()) + "]"
          }
        });
        
        $def(self, '$valid_name?', function $Helpers_valid_name$ques$1(name) {
          
          return $$$($$$($$('Opal'), 'Rewriters'), 'JsReservedWords')['$valid_name?'](name)
        });
        
        $def(self, '$mid_to_jsid', function $$mid_to_jsid(mid) {
          
          if ($truthy(/\=|\+|\-|\*|\/|\!|\?|<|\>|\&|\||\^|\%|\~|\[|`/['$=~'](mid.$to_s()))) {
            return "['$" + (mid) + "']"
          } else {
            return $rb_plus(".$", mid)
          }
        });
        
        $def(self, '$indent', function $$indent() {
          var block = $$indent.$$p || nil, self = this;

          $$indent.$$p = null;
          
          ;
          return $send(self.$compiler(), 'indent', [], block.$to_proc());
        });
        
        $def(self, '$current_indent', function $$current_indent() {
          var self = this;

          return self.$compiler().$parser_indent()
        });
        
        $def(self, '$line', function $$line($a) {
          var $post_args, strs, self = this;

          
          $post_args = $slice(arguments);
          strs = $post_args;
          self.$push(self.$fragment("\n" + (self.$current_indent()), (new Map([["loc", false]]))));
          return $send(self, 'push', $to_a(strs));
        }, -1);
        
        $def(self, '$empty_line', function $$empty_line() {
          var self = this;

          return self.$push(self.$fragment("\n", (new Map([["loc", false]]))))
        });
        
        $def(self, '$js_truthy', function $$js_truthy(sexp) {
          var self = this, optimize = nil;

          
          if ($truthy((optimize = self.$js_truthy_optimize(sexp)))) {
            return optimize
          };
          self.$helper("truthy");
          return [self.$fragment("$truthy("), self.$expr(sexp), self.$fragment(")")];
        });
        return $def(self, '$js_truthy_optimize', function $$js_truthy_optimize(sexp) {
          var $a, self = this, receiver = nil, mid = nil, args = nil, receiver_handler_class = nil, $ret_or_2 = nil, allow_optimization_on_type = nil, $ret_or_3 = nil, _test = nil, true_body = nil, false_body = nil;

          
          switch (sexp.$type().valueOf()) {
            case "send":
              
              $a = [].concat($to_a(sexp)), (receiver = ($a[0] == null ? nil : $a[0])), (mid = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
              receiver_handler_class = ($truthy(($ret_or_2 = receiver)) ? (self.$compiler().$handlers()['$[]'](receiver.$type())) : ($ret_or_2));
              allow_optimization_on_type = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = $$$($$('Compiler'), 'COMPARE')['$include?'](mid.$to_s()))) ? (receiver_handler_class) : ($ret_or_3)))) ? (receiver_handler_class['$truthy_optimize?']()) : ($ret_or_2));
              if (($truthy(allow_optimization_on_type) || ($eqeq(mid, "block_given?")))) {
                return self.$expr(sexp)
              } else if ($eqeq(args.$count(), 1)) {
                
                switch (mid.valueOf()) {
                  case "==":
                    
                    self.$helper("eqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$eqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  case "===":
                    
                    self.$helper("eqeqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$eqeqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  case "!=":
                    
                    self.$helper("neqeq");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$neqeq("), self.$expr(receiver), self.$fragment(", "), self.$expr(args.$first()), self.$fragment(")")];
                  default:
                    return nil
                }
              } else if ($eqeq(args.$count(), 0)) {
                
                switch (mid.valueOf()) {
                  case "!":
                    
                    self.$helper("not");
                    self.$compiler().$record_method_call(mid);
                    return [self.$fragment("$not("), self.$expr(receiver), self.$fragment(")")];
                  default:
                    return nil
                }
              } else {
                return nil
              };
              break;
            case "begin":
              if ($eqeq(sexp.$children().$count(), 1)) {
                return self.$js_truthy_optimize(sexp.$children().$first())
              } else {
                return nil
              }
              break;
            case "if":
              
              $a = [].concat($to_a(sexp)), (_test = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
              if ($eqeq(true_body, self.$s("true"))) {
                
                sexp.$meta()['$[]=']("do_js_truthy_on_false_body", true);
                return self.$expr(sexp);
              } else if ($eqeq(false_body, self.$s("false"))) {
                
                sexp.$meta()['$[]=']("do_js_truthy_on_true_body", true);
                return self.$expr(sexp);
              } else {
                return nil
              };
              break;
            default:
              return nil
          }
        });
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
