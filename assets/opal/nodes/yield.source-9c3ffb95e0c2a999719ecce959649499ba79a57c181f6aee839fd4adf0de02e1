Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,find_yielding_scope,uses_block!,block_name,block_name=,yields_single_arg?,children,push,expr,first,wrap,s,uses_splat?,scope,def?,parent,!,==,size,any?,type,handle,compile_call');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'BaseYieldNode');

        
        
        
        $def(self, '$compile_call', function $$compile_call() {
          var self = this, yielding_scope = nil, $ret_or_1 = nil, block_name = nil;

          
          yielding_scope = self.$find_yielding_scope();
          yielding_scope['$uses_block!']();
          if ($truthy(($ret_or_1 = yielding_scope.$block_name()))) {
            $ret_or_1
          } else {
            yielding_scope['$block_name=']("$yield")
          };
          block_name = yielding_scope.$block_name();
          if ($truthy(self['$yields_single_arg?'](self.$children()))) {
            
            self.$push(self.$expr(self.$children().$first()));
            return self.$wrap("Opal.yield1(" + (block_name) + ", ", ")");
          } else {
            
            self.$push(self.$expr($send(self, 's', ["arglist"].concat($to_a(self.$children())))));
            if ($truthy(self['$uses_splat?'](self.$children()))) {
              return self.$wrap("Opal.yieldX(" + (block_name) + ", ", ")")
            } else {
              return self.$wrap("Opal.yieldX(" + (block_name) + ", [", "])")
            };
          };
        });
        
        $def(self, '$find_yielding_scope', function $$find_yielding_scope() {
          var self = this, working = nil;

          
          working = self.$scope();
          while ($truthy(working)) {
          
            if (($truthy(working.$block_name()) || ($truthy(working['$def?']())))) {
              break
            };
            working = working.$parent();
          };
          return working;
        });
        
        $def(self, '$yields_single_arg?', function $BaseYieldNode_yields_single_arg$ques$1(children) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$uses_splat?'](children)['$!']()))) {
            return children.$size()['$=='](1)
          } else {
            return $ret_or_1
          }
        });
        return $def(self, '$uses_splat?', function $BaseYieldNode_uses_splat$ques$2(children) {
          
          return $send(children, 'any?', [], function $$3(child){
            
            if (child == null) child = nil;
            return child.$type()['$==']("splat");})
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'YieldNode');

        
        
        self.$handle("yield");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$compile_call()
        });
      })($nesting[0], $$('BaseYieldNode'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'ReturnableYieldNode');

        
        
        self.$handle("returnable_yield");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$compile_call();
          return self.$wrap("return ", ";");
        });
      })($nesting[0], $$('BaseYieldNode'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
