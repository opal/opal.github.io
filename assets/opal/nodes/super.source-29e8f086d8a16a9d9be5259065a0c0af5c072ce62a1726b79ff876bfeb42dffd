Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $return_val = Opal.return_val, $to_ary = Opal.to_ary, $eqeq = Opal.eqeq, $not = Opal.not, $eqeqeq = Opal.eqeqeq, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include?,type,s,helper,push,compile_receiver,compile_method_body,compile_method_name,compile_arguments,compile_block_pass,private,def?,scope,find_parent_def,to_s,mid,def_scope,identify!,self,method_id,def_scope_identity,defined_check_param,allow_stubs,super_chain,join,map,implicit_arguments_param,super_method_invocation,iter?,super_block_invocation,raise,handle,wrap,uses_block!,compile_using_send,==,iter,block_name,implicit_arglist,!,<<,each,children,original_args,[],meta,empty?,===');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'BaseSuperNode');

        var $proto = self.$$prototype;

        $proto.sexp = $proto.def_scope = nil;
        
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $fwd_rest, $b, $c, $yield = $$initialize.$$p || nil, self = this, args = nil, rest = nil, last_child = nil;

          $$initialize.$$p = null;
          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($fwd_rest), $yield);
          args = [].concat($to_a(self.sexp));
          $b = [].concat($to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice($b, 0, $c)), (last_child = ($b[$c] == null ? nil : $b[$c])), $b;
          if (($truthy(last_child) && ($truthy(["iter", "block_pass"]['$include?'](last_child.$type()))))) {
            
            self.iter = last_child;
            args = rest;
          } else {
            self.iter = self.$s("js_tmp", "null")
          };
          self.arglist = $send(self, 's', ["arglist"].concat($to_a(args)));
          return (self.recvr = self.$s("self"));
        }, -1);
        
        $def(self, '$compile_using_send', function $$compile_using_send() {
          var self = this;

          
          self.$helper("send2");
          self.$push("$send2(");
          self.$compile_receiver();
          self.$compile_method_body();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        });
        self.$private();
        
        $def(self, '$def_scope', function $$def_scope() {
          var self = this, $ret_or_1 = nil;

          return (self.def_scope = ($truthy(($ret_or_1 = self.def_scope)) ? ($ret_or_1) : ($truthy(self.$scope()['$def?']()) ? (self.$scope()) : (self.$scope().$find_parent_def()))))
        });
        
        $def(self, '$defined_check_param', $return_val("false"));
        
        $def(self, '$implicit_arguments_param', $return_val("false"));
        
        $def(self, '$method_id', function $$method_id() {
          var self = this;

          return self.$def_scope().$mid().$to_s()
        });
        
        $def(self, '$def_scope_identity', function $$def_scope_identity() {
          var self = this;

          return self.$def_scope()['$identify!'](self.$def_scope().$mid())
        });
        
        $def(self, '$allow_stubs', $return_val("true"));
        
        $def(self, '$super_method_invocation', function $$super_method_invocation() {
          var self = this;

          
          self.$helper("find_super");
          return "$find_super(" + (self.$scope().$self()) + ", '" + (self.$method_id()) + "', " + (self.$def_scope_identity()) + ", " + (self.$defined_check_param()) + ", " + (self.$allow_stubs()) + ")";
        });
        
        $def(self, '$super_block_invocation', function $$super_block_invocation() {
          var $a, $b, self = this, chain = nil, cur_defn = nil, mid = nil, trys = nil;

          
          self.$helper("find_block_super");
          $b = self.$scope().$super_chain(), $a = $to_ary($b), (chain = ($a[0] == null ? nil : $a[0])), (cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
          trys = $send(chain, 'map', [], function $$1(c){
            
            if (c == null) c = nil;
            return "" + (c) + ".$$def";}).$join(" || ");
          return "$find_block_super(" + (self.$scope().$self()) + ", " + (mid) + ", (" + (trys) + " || " + (cur_defn) + "), " + (self.$defined_check_param()) + ", " + (self.$implicit_arguments_param()) + ")";
        });
        
        $def(self, '$compile_method_body', function $$compile_method_body() {
          var self = this;

          
          self.$push(", ");
          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$super_method_invocation())
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$push(self.$super_block_invocation())
          } else {
            return self.$raise("super must be called from method body or block")
          };
        });
        return $def(self, '$compile_method_name', function $$compile_method_name() {
          var $a, $b, self = this, _chain = nil, _cur_defn = nil, mid = nil;

          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(", '" + (self.$method_id()) + "'")
          } else if ($truthy(self.$scope()['$iter?']())) {
            
            $b = self.$scope().$super_chain(), $a = $to_ary($b), (_chain = ($a[0] == null ? nil : $a[0])), (_cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
            return self.$push(", " + (mid));
          } else {
            return nil
          }
        });
      })($nesting[0], $$('CallNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'DefinedSuperNode');

        
        
        self.$handle("defined_super");
        
        $def(self, '$allow_stubs', $return_val("false"));
        
        $def(self, '$defined_check_param', $return_val("true"));
        return $def(self, '$compile', function $$compile() {
          var self = this;

          
          self.$compile_receiver();
          self.$compile_method_body();
          return self.$wrap("((", ") != null ? \"super\" : nil)");
        });
      })($nesting[0], $$('BaseSuperNode'));
      (function($base, $super) {
        var self = $klass($base, $super, 'SuperNode');

        
        
        self.$handle("super");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $fwd_rest, $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($fwd_rest), $yield);
          if ($truthy(self.$scope()['$def?']())) {
            return self.$scope()['$uses_block!']()
          } else {
            return nil
          };
        }, -1);
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$compile_using_send()
        });
      })($nesting[0], $$('BaseSuperNode'));
      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ZsuperNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$handle("zsuper");
        
        $def(self, '$implicit_arguments_param', $return_val("true"));
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $fwd_rest, $yield = $$initialize.$$p || nil, self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($fwd_rest), $yield);
          if ($eqeq(self.$iter().$type(), "iter")) {
            return nil
          } else {
            
            self.$scope()['$uses_block!']();
            return (self.iter = self.$s("js_tmp", ($truthy(($ret_or_1 = self.$scope().$block_name())) ? ($ret_or_1) : ("$yield"))));
          };
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this, implicit_args = nil, block_pass = nil;

          
          if ($truthy(self.$def_scope())) {
            
            implicit_args = self.$implicit_arglist();
            if (($truthy(self.$block_name()) && ($not(self.$iter())))) {
              
              block_pass = self.$s("block_pass", self.$s("lvar", self.$block_name()));
              implicit_args['$<<'](block_pass);
            };
            self.arglist = $send(self, 's', ["arglist"].concat($to_a(implicit_args)));
          };
          return self.$compile_using_send();
        });
        
        $def(self, '$implicit_arglist', function $$implicit_arglist() {
          var self = this, args = nil, kwargs = nil;

          
          args = [];
          kwargs = [];
          $send(self.$def_scope().$original_args().$children(), 'each', [], function $$2(sexp){var self = $$2.$$s == null ? this : $$2.$$s, lvar_name = nil, arg_node = nil, key_name = nil;

            
            if (sexp == null) sexp = nil;
            lvar_name = sexp.$children()['$[]'](0);
            
            switch (sexp.$type().valueOf()) {
              case "arg":
              case "optarg":
                
                arg_node = self.$s("lvar", lvar_name);
                return args['$<<'](arg_node);
              case "restarg":
                
                arg_node = ($truthy(lvar_name) ? (self.$s("lvar", lvar_name)) : (self.$s("js_tmp", "$rest_arg")));
                return args['$<<'](self.$s("splat", arg_node));
              case "kwarg":
              case "kwoptarg":
                
                key_name = sexp.$meta()['$[]']("arg_name");
                return kwargs['$<<'](self.$s("pair", self.$s("sym", key_name), self.$s("lvar", lvar_name)));
              case "kwrestarg":
                
                arg_node = ($truthy(lvar_name) ? (self.$s("lvar", lvar_name)) : (self.$s("js_tmp", "$kw_rest_arg")));
                return kwargs['$<<'](self.$s("kwsplat", arg_node));
              default:
                return nil
            };}, {$$s: self});
          if (!$truthy(kwargs['$empty?']())) {
            args['$<<']($send(self, 's', ["hash"].concat($to_a(kwargs))))
          };
          return args;
        });
        return $def(self, '$block_name', function $$block_name() {
          var self = this, $ret_or_1 = nil;

          if ($eqeqeq($$$($$$($$('Opal'), 'Nodes'), 'IterNode'), ($ret_or_1 = self.$def_scope()))) {
            return self.$def_scope().$block_name()
          } else if ($eqeqeq($$$($$$($$('Opal'), 'Nodes'), 'DefNode'), $ret_or_1)) {
            return self.$def_scope().$block_name()
          } else {
            return self.$raise("Don't know what to do with super in the scope " + (self.$def_scope()))
          }
        });
      })($nesting[0], $$('SuperNode'), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
