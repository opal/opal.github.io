Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $def = Opal.def, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,handle,children,lambda_definition?,scope,is_lambda!,compile_body_or_shortcut,<,arity,[]=,self,key?,throwers,[],arity_check?,compiler,parameters_code,enable_source_location?,source_location,has_top_level_mlhs_arg?,has_trailing_comma_in_args?,==,keys,push,!,empty?,join,map,nesting,relative_access,in_scope,identify!,process,inline_args,compile_arity_check,in_closure,|,stmt,returned_body,add_temp,to_vars,line,unshift,await_encountered,block_arg,prepare_block,each,args,first,<<,updated,stmts,returns,s,any?,original_args,type,expression,loc,source,match');
  
  self.$require("opal/nodes/node_with_args");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IterNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.define_self = $proto.closure = $proto.define_nesting = $proto.define_relative_access = $proto.sexp = nil;
        
        self.$handle("iter");
        self.$children("inline_args", "stmts");
        
        $def(self, '$compile', function $$compile() {
          var $a, $b, $c, $d, self = this, blockopts = nil;

          
          if ($truthy(self.$scope()['$lambda_definition?']())) {
            self['$is_lambda!']()
          };
          self.$compile_body_or_shortcut();
          blockopts = (new Map());
          if ($truthy($rb_lt(self.$arity(), 0))) {
            blockopts['$[]=']("$$arity", self.$arity())
          };
          if ($truthy(self.define_self)) {
            blockopts['$[]=']("$$s", self.$scope().$self())
          };
          if ($truthy(($a = ($b = self.closure, ($b === nil || $b == null) ? nil : $b.$throwers()), ($a === nil || $a == null) ? nil : $a['$key?']("break")))) {
            blockopts['$[]=']("$$brk", self.closure.$throwers()['$[]']("break"))
          };
          if ($truthy(($c = ($d = self.closure, ($d === nil || $d == null) ? nil : $d.$throwers()), ($c === nil || $c == null) ? nil : $c['$key?']("return")))) {
            blockopts['$[]=']("$$ret", self.closure.$throwers()['$[]']("return"))
          };
          if ($truthy(self.$compiler()['$arity_check?']())) {
            blockopts['$[]=']("$$parameters", self.$parameters_code())
          };
          if ($truthy(self.$compiler()['$enable_source_location?']())) {
            blockopts['$[]=']("$$source_location", self.$source_location())
          };
          if ($truthy(self['$has_top_level_mlhs_arg?']())) {
            blockopts['$[]=']("$$has_top_level_mlhs_arg", "true")
          };
          if ($truthy(self['$has_trailing_comma_in_args?']())) {
            blockopts['$[]=']("$$has_trailing_comma_in_args", "true")
          };
          if ($eqeq(blockopts.$keys(), ["$$arity"])) {
            self.$push(", " + (self.$arity()))
          } else if ($not(blockopts['$empty?']())) {
            self.$push(", {", $send(blockopts, 'map', [], function $$1(k, v){
              
              if (k == null) k = nil;
              if (v == null) v = nil;
              return "" + (k) + ": " + (v);}).$join(", "), "}")
          };
          if ($truthy(self.define_nesting)) {
            self.$scope().$nesting()
          };
          if ($truthy(self.define_relative_access)) {
            return self.$scope().$relative_access()
          } else {
            return nil
          };
        });
        
        $def(self, '$compile_body', function $$compile_body() {
          var self = this, inline_params = nil, to_vars = nil, identity = nil, body_code = nil;

          
          inline_params = nil;
          to_vars = (identity = (body_code = nil));
          $send(self, 'in_scope', [], function $$2(){var self = $$2.$$s == null ? this : $$2.$$s;
            if (self.is_lambda == null) self.is_lambda = nil;

            
            identity = self.$scope()['$identify!']();
            inline_params = self.$process(self.$inline_args());
            self.$compile_arity_check();
            return $send(self, 'in_closure', [$$$($$('Closure'), 'JS_FUNCTION')['$|']($$$($$('Closure'), 'ITER'))['$|'](($truthy(self.is_lambda) ? ($$$($$('Closure'), 'LAMBDA')) : (0)))], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.define_self == null) self.define_self = nil;

              
              body_code = self.$stmt(self.$returned_body());
              if ($truthy(self.define_self)) {
                self.$add_temp("self = " + (identity) + ".$$s == null ? this : " + (identity) + ".$$s")
              };
              to_vars = self.$scope().$to_vars();
              return self.$line(body_code);}, {$$s: self});}, {$$s: self});
          self.$unshift(to_vars);
          if ($truthy(self.$await_encountered())) {
            self.$unshift("async function " + (identity) + "(", inline_params, "){")
          } else {
            self.$unshift("function " + (identity) + "(", inline_params, "){")
          };
          return self.$push("}");
        });
        
        $def(self, '$compile_block_arg', function $$compile_block_arg() {
          var self = this;

          if ($truthy(self.$block_arg())) {
            return self.$scope().$prepare_block()
          } else {
            return nil
          }
        });
        
        $def(self, '$extract_underscore_args', function $$extract_underscore_args() {
          var self = this, valid_args = nil, caught_blank_argument = nil;

          
          valid_args = [];
          caught_blank_argument = false;
          $send(self.$args().$children(), 'each', [], function $$4(arg){var arg_name = nil;

            
            if (arg == null) arg = nil;
            arg_name = arg.$children().$first();
            if ($eqeq(arg_name, "_")) {
              if ($truthy(caught_blank_argument)) {
                return nil
              } else {
                
                caught_blank_argument = true;
                return valid_args['$<<'](arg);
              }
            } else {
              return valid_args['$<<'](arg)
            };});
          return (self.sexp = self.sexp.$updated(nil, [self.$args().$updated(nil, valid_args), self.$stmts()]));
        });
        
        $def(self, '$returned_body', function $$returned_body() {
          var self = this, $ret_or_1 = nil;

          return self.$compiler().$returns(($truthy(($ret_or_1 = self.$stmts())) ? ($ret_or_1) : (self.$s("nil"))))
        });
        
        $def(self, '$has_top_level_mlhs_arg?', function $IterNode_has_top_level_mlhs_arg$ques$5() {
          var self = this;

          return $send(self.$original_args().$children(), 'any?', [], function $$6(arg){
            
            if (arg == null) arg = nil;
            return arg.$type()['$==']("mlhs");})
        });
        
        $def(self, '$has_trailing_comma_in_args?', function $IterNode_has_trailing_comma_in_args$ques$7() {
          var self = this, args_source = nil;

          if (($truthy(self.$original_args().$loc()) && ($truthy(self.$original_args().$loc().$expression())))) {
            
            args_source = self.$original_args().$loc().$expression().$source();
            return args_source.$match(/,\s*\|/);
          } else {
            return nil
          }
        });
        return $def(self, '$arity_check_node', function $$arity_check_node() {
          var self = this;

          return self.$s("iter_arity_check", self.$original_args())
        });
      })($nesting[0], $$('NodeWithArgs'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
