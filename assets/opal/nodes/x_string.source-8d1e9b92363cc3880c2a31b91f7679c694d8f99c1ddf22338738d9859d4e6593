Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $to_a = Opal.to_a, $defs = Opal.defs, $lambda = Opal.lambda, $eqeq = Opal.eqeq, $not = Opal.not, $range = Opal.range, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('handle,backtick_javascript_or_warn?,compiler,compile_javascript,compile_send,s,children,push,process,unpack_return,strip_empty_children,single_line?,compile_single_line,each,compile_child,recv?,wrap,==,size,none?,type,end_with?,source,expression,loc,dup,nil?,empty?,rstrip,any?,[],first,shift,last,pop,private,include?,self,scope,new,expr,raise,strip,=~,!,extract_last_value,expr?,warning,line');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'XStringNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.level = $proto.should_add_semicolon = $proto.returning = nil;
        
        self.$handle("xstr");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self.$compiler()['$backtick_javascript_or_warn?']())) {
            return self.$compile_javascript()
          } else {
            return self.$compile_send()
          }
        });
        
        $def(self, '$compile_send', function $$compile_send() {
          var self = this, sexp = nil;

          
          sexp = self.$s("send", nil, "`", $send(self, 's', ["dstr"].concat($to_a(self.$children()))));
          return self.$push(self.$process(sexp, self.level));
        });
        
        $def(self, '$compile_javascript', function $$compile_javascript() {
          var self = this, unpacked_children = nil, stripped_children = nil;

          
          self.should_add_semicolon = false;
          unpacked_children = self.$unpack_return(self.$children());
          stripped_children = $$('XStringNode').$strip_empty_children(unpacked_children);
          if ($truthy($$('XStringNode')['$single_line?'](stripped_children))) {
            self.$compile_single_line(stripped_children)
          } else {
            $send(unpacked_children, 'each', [], function $$1(c){var self = $$1.$$s == null ? this : $$1.$$s;

              
              if (c == null) c = nil;
              return self.$compile_child(c);}, {$$s: self})
          };
          if ($truthy(self['$recv?']())) {
            self.$wrap("(", ")")
          };
          if ($truthy(self.should_add_semicolon)) {
            return self.$push(";")
          } else {
            return nil
          };
        });
        $defs(self, '$single_line?', function $XStringNode_single_line$ques$2(children) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = children.$size()['$=='](1)))) {
            return $ret_or_1
          } else {
            return $send(children, 'none?', [], function $$3(c){var $ret_or_2 = nil;

              
              if (c == null) c = nil;
              if ($truthy(($ret_or_2 = c.$type()['$==']("str")))) {
                return c.$loc().$expression().$source()['$end_with?']("\n")
              } else {
                return $ret_or_2
              };})
          }
        });
        $defs(self, '$strip_empty_children', function $$strip_empty_children(children) {
          var empty_line = nil, $ret_or_1 = nil;

          
          children = children.$dup();
          empty_line = $lambda(function $$4(child){var $ret_or_1 = nil, $ret_or_2 = nil;

            
            if (child == null) child = nil;
            if ($truthy(($ret_or_1 = child['$nil?']()))) {
              return $ret_or_1
            } else {
              
              if ($truthy(($ret_or_2 = child.$type()['$==']("str")))) {
                return child.$loc().$expression().$source().$rstrip()['$empty?']()
              } else {
                return $ret_or_2
              };
            };});
          while ($truthy(($truthy(($ret_or_1 = children['$any?']())) ? (empty_line['$[]'](children.$first())) : ($ret_or_1)))) {
          children.$shift()
          };
          while ($truthy(($truthy(($ret_or_1 = children['$any?']())) ? (empty_line['$[]'](children.$last())) : ($ret_or_1)))) {
          children.$pop()
          };
          return children;
        });
        self.$private();
        
        $def(self, '$compile_child', function $$compile_child(child) {
          var self = this, value = nil;

          
          switch (child.$type().valueOf()) {
            case "str":
              
              value = child.$loc().$expression().$source();
              if ($truthy(value['$include?']("self"))) {
                self.$scope().$self()
              };
              return self.$push($$('Fragment').$new(value, self.$scope(), child));
            case "begin":
            case "gvar":
            case "ivar":
            case "nil":
              return self.$push(self.$expr(child))
            default:
              return self.$raise("Unsupported xstr part: " + (child.$type()))
          }
        });
        
        $def(self, '$compile_single_line', function $$compile_single_line(children) {
          var self = this, has_embeded_return = nil, first_child = nil, single_child = nil, $ret_or_1 = nil, first_value = nil, last_child = nil, last_value = nil;

          
          has_embeded_return = false;
          first_child = children.$shift();
          single_child = children['$empty?']();
          first_child = ($truthy(($ret_or_1 = first_child)) ? ($ret_or_1) : (self.$s("nil")));
          if ($eqeq(first_child.$type(), "str")) {
            
            first_value = first_child.$loc().$expression().$source().$strip();
            has_embeded_return = first_value['$=~'](/^return\b/);
          };
          if (($truthy(self.returning) && ($not(has_embeded_return)))) {
            self.$push("return ")
          };
          last_child = ($truthy(($ret_or_1 = children.$pop())) ? ($ret_or_1) : (first_child));
          if ($eqeq(last_child.$type(), "str")) {
            last_value = self.$extract_last_value(last_child)
          };
          if (!$truthy(single_child)) {
            
            self.should_add_semicolon = false;
            self.$compile_child(first_child);
            $send(children, 'each', [], function $$5(c){var self = $$5.$$s == null ? this : $$5.$$s;

              
              if (c == null) c = nil;
              return self.$compile_child(c);}, {$$s: self});
          };
          if ($eqeq(last_child.$type(), "str")) {
            return self.$push($$('Fragment').$new(last_value, self.$scope(), last_child))
          } else {
            return self.$compile_child(last_child)
          };
        });
        
        $def(self, '$extract_last_value', function $$extract_last_value(last_child) {
          var self = this, last_value = nil;

          
          last_value = last_child.$loc().$expression().$source().$rstrip();
          if ($truthy(last_value['$include?']("self"))) {
            self.$scope().$self()
          };
          if ((($truthy(self.returning) || ($truthy(self['$expr?']()))) && ($truthy(last_value['$end_with?'](";"))))) {
            
            self.$compiler().$warning("Removed semicolon ending x-string expression, interpreted as unintentional", last_child.$line());
            last_value = last_value['$[]']($range(0, -2, false));
          };
          if ($truthy(self.returning)) {
            self.should_add_semicolon = true
          };
          return last_value;
        });
        return $def(self, '$unpack_return', function $$unpack_return(children) {
          var self = this, first_child = nil;

          
          first_child = children.$first();
          self.returning = false;
          if ($eqeq(first_child.$type(), "js_return")) {
            
            self.returning = true;
            children = first_child.$children();
          };
          return children;
        });
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
