Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $eqeq = Opal.eqeq, $def = Opal.def, $truthy = Opal.truthy, $to_a = Opal.to_a, $slice = Opal.slice, $send = Opal.send, $range = Opal.range, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handle,children,type,value,push,inspect,to_s,==,[],size,compile_defined_send,wrap,compile_defined_ivar,compile_defined_super,compile_defined_yield,compile_defined_xstr,compile_defined_const,compile_defined_cvar,compile_defined_gvar,compile_defined_back_ref,compile_defined_nth_ref,compile_defined_array,respond_to?,__send__,new_temp,scope,expr,wrap_with_try_catch,mid_to_jsid,compile_defined,compile_send_recv_doesnt_raise,self,each,s,uses_block!,block_name,find_parent_def,nil?,relative_access,absolute_const,top_scope,class_variable_owner,helper,include?,each_with_index');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'DefinedNode');

        
        
        self.$handle("defined?");
        self.$children("value");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          
          switch (self.$value().$type().valueOf()) {
            case "self":
            case "nil":
            case "false":
            case "true":
              return self.$push(self.$value().$type().$to_s().$inspect())
            case "lvasgn":
            case "ivasgn":
            case "gvasgn":
            case "cvasgn":
            case "casgn":
            case "op_asgn":
            case "or_asgn":
            case "and_asgn":
              return self.$push("'assignment'")
            case "lvar":
              return self.$push("'local-variable'")
            case "begin":
              if (($eqeq(self.$value().$children().$size(), 1) && ($eqeq(self.$value().$children()['$[]'](0).$type(), "masgn")))) {
                return self.$push("'assignment'")
              } else {
                return self.$push("'expression'")
              }
              break;
            case "send":
              
              self.$compile_defined_send(self.$value());
              return self.$wrap("(", " ? 'method' : nil)");
            case "ivar":
              
              self.$compile_defined_ivar(self.$value());
              return self.$wrap("(", " ? 'instance-variable' : nil)");
            case "zsuper":
            case "super":
              return self.$compile_defined_super()
            case "yield":
              
              self.$compile_defined_yield();
              return self.$wrap("(", " ? 'yield' : nil)");
            case "xstr":
              return self.$compile_defined_xstr(self.$value())
            case "const":
              
              self.$compile_defined_const(self.$value());
              return self.$wrap("(", " ? 'constant' : nil)");
            case "cvar":
              
              self.$compile_defined_cvar(self.$value());
              return self.$wrap("(", " ? 'class variable' : nil)");
            case "gvar":
              
              self.$compile_defined_gvar(self.$value());
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "back_ref":
              
              self.$compile_defined_back_ref();
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "nth_ref":
              
              self.$compile_defined_nth_ref();
              return self.$wrap("(", " ? 'global-variable' : nil)");
            case "array":
              
              self.$compile_defined_array(self.$value());
              return self.$wrap("(", " ? 'expression' : nil)");
            default:
              return self.$push("'expression'")
          }
        });
        
        $def(self, '$compile_defined', function $$compile_defined(node) {
          var self = this, type = nil, node_tmp = nil;

          
          type = node.$type();
          if ($truthy(self['$respond_to?']("compile_defined_" + (type)))) {
            return self.$__send__("compile_defined_" + (type), node)
          } else {
            
            node_tmp = self.$scope().$new_temp();
            self.$push("(" + (node_tmp) + " = ", self.$expr(node), ")");
            return node_tmp;
          };
        });
        
        $def(self, '$wrap_with_try_catch', function $$wrap_with_try_catch(code) {
          var self = this, returning_tmp = nil;

          
          returning_tmp = self.$scope().$new_temp();
          self.$push("(" + (returning_tmp) + " = (function() { try {");
          self.$push("  return " + (code) + ";");
          self.$push("} catch ($err) {");
          self.$push("  if (Opal.rescue($err, [Opal.Exception])) {");
          self.$push("    try {");
          self.$push("      return false;");
          self.$push("    } finally { Opal.pop_exception($err); }");
          self.$push("  } else { throw $err; }");
          self.$push("}})())");
          return returning_tmp;
        });
        
        $def(self, '$compile_send_recv_doesnt_raise', function $$compile_send_recv_doesnt_raise(recv_code) {
          var self = this;

          return self.$wrap_with_try_catch(recv_code)
        });
        
        $def(self, '$compile_defined_send', function $$compile_defined_send(node) {
          var $a, self = this, recv = nil, method_name = nil, args = nil, mid = nil, recv_code = nil, recv_tmp = nil, recv_value_tmp = nil, meth_tmp = nil;

          
          $a = [].concat($to_a(node)), (recv = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (args = $slice($a, 2)), $a;
          mid = self.$mid_to_jsid(method_name.$to_s());
          if ($truthy(recv)) {
            
            recv_code = self.$compile_defined(recv);
            self.$push(" && ");
            if ($eqeq(recv.$type(), "send")) {
              
              recv_code = self.$compile_send_recv_doesnt_raise(recv_code);
              self.$push(" && ");
            };
            recv_tmp = self.$scope().$new_temp();
            self.$push("(" + (recv_tmp) + " = ", recv_code, ", " + (recv_tmp) + ") && ");
          } else {
            recv_tmp = self.$scope().$self()
          };
          recv_value_tmp = self.$scope().$new_temp();
          self.$push("(" + (recv_value_tmp) + " = " + (recv_tmp) + ") && ");
          meth_tmp = self.$scope().$new_temp();
          self.$push("(((" + (meth_tmp) + " = " + (recv_value_tmp) + (mid) + ") && !" + (meth_tmp) + ".$$stub)");
          self.$push(" || " + (recv_value_tmp) + "['$respond_to_missing?']('" + (method_name) + "'))");
          $send(args, 'each', [], function $$1(arg){var self = $$1.$$s == null ? this : $$1.$$s;

            
            if (arg == null) arg = nil;
            
            switch (arg.$type().valueOf()) {
              case "block_pass":
                return nil
              default:
                
                self.$push(" && ");
                return self.$compile_defined(arg);
            };}, {$$s: self});
          self.$wrap("(", ")");
          return "" + (meth_tmp) + "()";
        });
        
        $def(self, '$compile_defined_ivar', function $$compile_defined_ivar(node) {
          var self = this, name = nil, tmp = nil;

          
          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));
          tmp = self.$scope().$new_temp();
          self.$push("(" + (tmp) + " = " + (self.$scope().$self()) + "['" + (name) + "'], " + (tmp) + " != null && " + (tmp) + " !== nil)");
          return tmp;
        });
        
        $def(self, '$compile_defined_super', function $$compile_defined_super() {
          var self = this;

          return self.$push(self.$expr(self.$s("defined_super")))
        });
        
        $def(self, '$compile_defined_yield', function $$compile_defined_yield() {
          var self = this, block_name = nil, $ret_or_1 = nil;

          
          self.$scope()['$uses_block!']();
          block_name = ($truthy(($ret_or_1 = self.$scope().$block_name())) ? ($ret_or_1) : (self.$scope().$find_parent_def().$block_name()));
          self.$push("(" + (block_name) + " != null && " + (block_name) + " !== nil)");
          return block_name;
        });
        
        $def(self, '$compile_defined_xstr', function $$compile_defined_xstr(node) {
          var self = this;

          return self.$push("(typeof(", self.$expr(node), ") !== \"undefined\")")
        });
        
        $def(self, '$compile_defined_const', function $$compile_defined_const(node) {
          var $a, self = this, const_scope = nil, const_name = nil, const_tmp = nil, const_scope_tmp = nil;

          
          $a = [].concat($to_a(node)), (const_scope = ($a[0] == null ? nil : $a[0])), (const_name = ($a[1] == null ? nil : $a[1])), $a;
          const_tmp = self.$scope().$new_temp();
          if ($truthy(const_scope['$nil?']())) {
            self.$push("(" + (const_tmp) + " = " + (self.$scope().$relative_access()) + "('" + (const_name) + "', 'skip_raise'))")
          } else if ($eqeq(const_scope, self.$s("cbase"))) {
            self.$push("(" + (const_tmp) + " = " + (self.$top_scope().$absolute_const()) + "('::', '" + (const_name) + "', 'skip_raise'))")
          } else {
            
            const_scope_tmp = self.$compile_defined(const_scope);
            self.$push(" && (" + (const_tmp) + " = " + (self.$top_scope().$absolute_const()) + "(" + (const_scope_tmp) + ", '" + (const_name) + "', 'skip_raise'))");
          };
          return const_tmp;
        });
        
        $def(self, '$compile_defined_cvar', function $$compile_defined_cvar(node) {
          var $a, self = this, cvar_name = nil, _ = nil, cvar_tmp = nil;

          
          $a = [].concat($to_a(node)), (cvar_name = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), $a;
          cvar_tmp = self.$scope().$new_temp();
          self.$push("(" + (cvar_tmp) + " = " + (self.$class_variable_owner()) + ".$$cvars['" + (cvar_name) + "'], " + (cvar_tmp) + " != null)");
          return cvar_tmp;
        });
        
        $def(self, '$compile_defined_gvar', function $$compile_defined_gvar(node) {
          var self = this, name = nil, gvar_temp = nil;

          
          self.$helper("gvars");
          name = node.$children()['$[]'](0).$to_s()['$[]']($range(1, -1, false));
          gvar_temp = self.$scope().$new_temp();
          if ($truthy(["~", "!"]['$include?'](name))) {
            self.$push("(" + (gvar_temp) + " = ", self.$expr(node), " || true)")
          } else {
            self.$push("(" + (gvar_temp) + " = $gvars[" + (name.$inspect()) + "], " + (gvar_temp) + " != null)")
          };
          return gvar_temp;
        });
        
        $def(self, '$compile_defined_back_ref', function $$compile_defined_back_ref() {
          var self = this, back_ref_temp = nil;

          
          self.$helper("gvars");
          back_ref_temp = self.$scope().$new_temp();
          self.$push("(" + (back_ref_temp) + " = $gvars['~'], " + (back_ref_temp) + " != null && " + (back_ref_temp) + " !== nil)");
          return back_ref_temp;
        });
        
        $def(self, '$compile_defined_nth_ref', function $$compile_defined_nth_ref() {
          var self = this, nth_ref_tmp = nil;

          
          self.$helper("gvars");
          nth_ref_tmp = self.$scope().$new_temp();
          self.$push("(" + (nth_ref_tmp) + " = $gvars['~'], " + (nth_ref_tmp) + " != null && " + (nth_ref_tmp) + " != nil)");
          return nth_ref_tmp;
        });
        return $def(self, '$compile_defined_array', function $$compile_defined_array(node) {
          var self = this;

          return $send(node.$children(), 'each_with_index', [], function $$2(child, idx){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (child == null) child = nil;
            if (idx == null) idx = nil;
            if (!$eqeq(idx, 0)) {
              self.$push(" && ")
            };
            return self.$compile_defined(child);}, {$$s: self})
        });
      })($nesting[0], $$('Base'))
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
