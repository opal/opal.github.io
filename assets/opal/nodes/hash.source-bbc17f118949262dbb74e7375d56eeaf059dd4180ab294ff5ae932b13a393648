Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $send = Opal.send, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handle,attr_accessor,each,children,type,<<,[],all?,keys,include?,has_kwsplat,compile_merge,compile_hash,==,empty?,expr,s,each_with_index,push,inspect,to_s,simple_keys?,wrap,helper,value');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'HashNode');

        
        
        self.$handle("hash");
        self.$attr_accessor("has_kwsplat", "keys", "values");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $fwd_rest, $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($fwd_rest), $yield);
          self.has_kwsplat = false;
          self.keys = [];
          self.values = [];
          return $send(self.$children(), 'each', [], function $$1(child){var self = $$1.$$s == null ? this : $$1.$$s;
            if (self.keys == null) self.keys = nil;
            if (self.values == null) self.values = nil;

            
            if (child == null) child = nil;
            
            switch (child.$type().valueOf()) {
              case "kwsplat":
                return (self.has_kwsplat = true)
              case "pair":
                
                self.keys['$<<'](child.$children()['$[]'](0));
                return self.values['$<<'](child.$children()['$[]'](1));
              default:
                return nil
            };}, {$$s: self});
        }, -1);
        
        $def(self, '$simple_keys?', function $HashNode_simple_keys$ques$2() {
          var self = this;

          return $send(self.$keys(), 'all?', [], function $$3(key){
            
            if (key == null) key = nil;
            return ["sym", "str", "int"]['$include?'](key.$type());})
        });
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          if ($truthy(self.$has_kwsplat())) {
            return self.$compile_merge()
          } else {
            return self.$compile_hash()
          }
        });
        
        $def(self, '$compile_merge', function $$compile_merge() {
          var $a, self = this, result = nil, seq = nil;

          
          $a = [[], []], (result = $a[0]), (seq = $a[1]), $a;
          $send(self.$children(), 'each', [], function $$4(child){var self = $$4.$$s == null ? this : $$4.$$s;

            
            if (child == null) child = nil;
            if ($eqeq(child.$type(), "kwsplat")) {
              
              if (!$truthy(seq['$empty?']())) {
                result['$<<'](self.$expr($send(self, 's', ["hash"].concat($to_a(seq)))))
              };
              result['$<<'](self.$expr(child));
              return (seq = []);
            } else {
              return seq['$<<'](child)
            };}, {$$s: self});
          if (!$truthy(seq['$empty?']())) {
            result['$<<'](self.$expr($send(self, 's', ["hash"].concat($to_a(seq)))))
          };
          return $send(result, 'each_with_index', [], function $$5(fragment, idx){var self = $$5.$$s == null ? this : $$5.$$s;

            
            if (fragment == null) fragment = nil;
            if (idx == null) idx = nil;
            if ($eqeq(idx, 0)) {
              return self.$push(fragment)
            } else {
              return self.$push(".$merge(", fragment, ")")
            };}, {$$s: self});
        });
        return $def(self, '$compile_hash', function $$compile_hash() {
          var self = this;

          
          $send(self.$children(), 'each_with_index', [], function $$6(pair, idx){var $a, $b, self = $$6.$$s == null ? this : $$6.$$s, key = nil, value = nil;

            
            if (pair == null) pair = nil;
            if (idx == null) idx = nil;
            $b = pair.$children(), $a = $to_ary($b), (key = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;
            if (!$eqeq(idx, 0)) {
              self.$push(", ")
            };
            if ($truthy(["sym", "str"]['$include?'](key.$type()))) {
              return self.$push("[" + (key.$children()['$[]'](0).$to_s().$inspect()), ", ", self.$expr(value), "]")
            } else {
              return self.$push("[", self.$expr(key), ", ", self.$expr(value), "]")
            };}, {$$s: self});
          if ($truthy(self.$keys()['$empty?']())) {
            return self.$push("(new Map())")
          } else if ($truthy(self['$simple_keys?']())) {
            return self.$wrap("(new Map([", "]))")
          } else {
            
            self.$helper("hash_rehash");
            return self.$wrap("$hash_rehash(new Map([", "]))");
          };
        });
      })($nesting[0], $$('Base'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'KwSplatNode');

        
        
        self.$handle("kwsplat");
        self.$children("value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push("Opal.to_hash(", self.$expr(self.$value()), ")")
        });
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
