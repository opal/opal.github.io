Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $neqeq = Opal.neqeq, $thrower = Opal.thrower, $not = Opal.not, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('const_set,[]=,join,map,reject,==,&,to_proc,add_type,<<,include?,!=,type_inspect,type,class,attr_accessor,new,select_closure,closure_stack,compile_catcher,pop,last,node,push_closure,pop_closure,find,reverse,register_catcher,register_thrower,push,expr_or_nil,identify!,scope,helper,key?,throwers,[],unique_temp,compiler,parent,top_scope,add_scope_temp,|,!,generate_thrower_without_catcher,eval?,error,generate_thrower,is?,catchers,empty?,grep_v,indent,each,line,closure_is?,unshift,await_encountered,wrap');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Closure');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.catchers = $proto.throwers = $proto.type = $proto.node = nil;
        
        $const_set($nesting[0], 'NONE', 0);
        self.types = (new Map());
        $defs(self, '$add_type', function $$add_type(name, value) {
          var $a, self = this;
          if (self.types == null) self.types = nil;

          
          self.$const_set(name, value);
          return ($a = [name, value], $send(self.types, '[]=', $a), $a[$a.length - 1]);
        });
        $defs(self, '$type_inspect', function $$type_inspect(type) {
          var self = this;
          if (self.types == null) self.types = nil;

          return $send($send(self.types, 'reject', [], function $$1(_name, value){
            
            if (_name == null) _name = nil;
            if (value == null) value = nil;
            return type['$&'](value)['$=='](0);}), 'map', [], "first".$to_proc()).$join("|")
        });
        self.$add_type("JS_FUNCTION", (1)['$<<'](0));
        self.$add_type("JS_LOOP", (1)['$<<'](1));
        self.$add_type("JS_LOOP_INSIDE", (1)['$<<'](2));
        self.$add_type("DEF", (1)['$<<'](3));
        self.$add_type("LAMBDA", (1)['$<<'](4));
        self.$add_type("ITER", (1)['$<<'](5));
        self.$add_type("MODULE", (1)['$<<'](6));
        self.$add_type("LOOP", (1)['$<<'](7));
        self.$add_type("LOOP_INSIDE", (1)['$<<'](8));
        self.$add_type("SEND", (1)['$<<'](9));
        self.$add_type("TOP", (1)['$<<'](10));
        self.$add_type("RESCUE_RETRIER", (1)['$<<'](11));
        $const_set($nesting[0], 'ANY', 4294967295);
        
        $def(self, '$initialize', function $$initialize(node, type, parent) {
          var $a, self = this;

          
          $a = [node, type, parent], (self.node = $a[0]), (self.type = $a[1]), (self.parent = $a[2]), $a;
          self.catchers = [];
          return (self.throwers = (new Map()));
        });
        
        $def(self, '$register_catcher', function $$register_catcher(type) {
          var self = this;

          
          if (type == null) type = "return";
          if (!$truthy(self.catchers['$include?'](type))) {
            self.catchers['$<<'](type)
          };
          return "$t_" + (type);
        }, -1);
        
        $def(self, '$register_thrower', function $$register_thrower(type, id) {
          var $a, self = this;

          return ($a = [type, id], $send(self.throwers, '[]=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$is?', function $Closure_is$ques$2(type) {
          var self = this;

          return self.type['$&'](type)['$!='](0)
        });
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Closure " + ($$('Closure').$type_inspect(self.$type())) + " " + (self.node.$class()) + ">"
        });
        self.$attr_accessor("node", "type", "parent", "catchers", "throwers");
        (function($base, $parent_nesting) {
          var self = $module($base, 'NodeSupport');

          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          
          
          $def(self, '$push_closure', function $$push_closure(type) {
            var self = this, closure = nil;
            if (self.compiler == null) self.compiler = nil;

            
            if (type == null) type = $$('JS_FUNCTION');
            closure = $$('Closure').$new(self, type, self.$select_closure());
            self.compiler.$closure_stack()['$<<'](closure);
            return (self.closure = closure);
          }, -1);
          self.$attr_accessor("closure");
          
          $def(self, '$pop_closure', function $$pop_closure() {
            var $a, self = this, last = nil;
            if (self.compiler == null) self.compiler = nil;

            
            self.$compile_catcher();
            self.compiler.$closure_stack().$pop();
            last = self.compiler.$closure_stack().$last();
            if ($eqeq(($a = last, ($a === nil || $a == null) ? nil : $a.$node()), self)) {
              return (self.closure = last)
            } else {
              return nil
            };
          });
          
          $def(self, '$in_closure', function $$in_closure(type) {
            var $yield = $$in_closure.$$p || nil, self = this, closure = nil, out = nil;

            $$in_closure.$$p = null;
            
            if (type == null) type = $$('JS_FUNCTION');
            closure = self.$push_closure(type);
            out = Opal.yield1($yield, closure);
            self.$pop_closure();
            return out;
          }, -1);
          
          $def(self, '$select_closure', function $$select_closure($a, $b) {
            var $post_args, $kwargs, type, break_after, self = this;
            if (self.compiler == null) self.compiler = nil;

            
            $post_args = $slice(arguments);
            $kwargs = $extract_kwargs($post_args);
            $kwargs = $ensure_kwargs($kwargs);
            
            if ($post_args.length > 0) type = $post_args.shift();if (type == null) type = $$('ANY');
            
            break_after = $hash_get($kwargs, "break_after");if (break_after == null) break_after = $$('NONE');
            return (function(){try { var $t_break = $thrower('break'); return $send(self.compiler.$closure_stack().$reverse(), 'find', [], function $$3(i){
              
              if (i == null) i = nil;
              if ($neqeq(i.$type()['$&'](break_after), 0)) {
                $t_break.$throw(nil, $$3.$$is_lambda)
              };
              return i.$type()['$&'](type)['$!='](0);})} catch($e) {
              if ($e === $t_break) return $e.$v;
              throw $e;
            } finally {$t_break.is_orphan = true;}})();
          }, -1);
          
          $def(self, '$generate_thrower', function $$generate_thrower(type, closure, value) {
            var self = this, id = nil;

            
            id = closure.$register_catcher(type);
            closure.$register_thrower(type, id);
            self.$push(id, ".$throw(", self.$expr_or_nil(value), ", ", self.$scope()['$identify!'](), ".$$is_lambda)");
            return id;
          });
          
          $def(self, '$generate_thrower_without_catcher', function $$generate_thrower_without_catcher(type, closure, value) {
            var $a, self = this, id = nil, parent_scope = nil, $ret_or_1 = nil;

            
            self.$helper("thrower");
            if ($truthy(closure.$throwers()['$key?'](type))) {
              id = closure.$throwers()['$[]'](type)
            } else {
              
              id = self.$compiler().$unique_temp("t_");
              parent_scope = ($truthy(($ret_or_1 = ($a = closure.$node().$scope(), ($a === nil || $a == null) ? nil : $a.$parent()))) ? ($ret_or_1) : (self.$top_scope()));
              parent_scope.$add_scope_temp("" + (id) + " = $thrower('" + (type) + "')");
              closure.$register_thrower(type, id);
            };
            self.$push(id, ".$throw(", self.$expr_or_nil(value), ", ", self.$scope()['$identify!'](), ".$$is_lambda)");
            return id;
          });
          
          $def(self, '$thrower', function $$thrower(type, value) {
            var self = this, thrower_closure = nil, last_closure = nil, iter_closure = nil, id = nil;

            
            if (value == null) value = nil;
            
            switch (type.valueOf()) {
              case "return":
                
                thrower_closure = self.$select_closure($$('DEF'), (new Map([["break_after", $$('MODULE')['$|']($$('TOP'))]])));
                last_closure = self.$select_closure($$('JS_FUNCTION'));
                if ($not(thrower_closure)) {
                  
                  iter_closure = self.$select_closure($$('ITER'), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                  if ($truthy(iter_closure)) {
                    return self.$generate_thrower_without_catcher("return", iter_closure, value)
                  } else if ($truthy(self.$compiler()['$eval?']())) {
                    return self.$push("Opal.t_eval_return.$throw(", self.$expr_or_nil(value), ", false)")
                  } else {
                    return self.$error("Invalid return")
                  };
                } else if ($eqeq(thrower_closure, last_closure)) {
                  return self.$push("return ", self.$expr_or_nil(value))
                } else {
                  
                  id = self.$generate_thrower("return", thrower_closure, value);
                  iter_closure = self.$select_closure($$('ITER'), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                  if ($truthy(iter_closure)) {
                    return iter_closure.$register_thrower("return", id)
                  } else {
                    return nil
                  };
                };
                break;
              case "eval_return":
                
                thrower_closure = self.$select_closure($$('DEF')['$|']($$('LAMBDA')), (new Map([["break_after", $$('MODULE')['$|']($$('TOP'))]])));
                if ($truthy(thrower_closure)) {
                  return thrower_closure.$register_catcher("eval_return")
                } else {
                  return nil
                };
                break;
              case "next":
              case "redo":
                
                thrower_closure = self.$select_closure($$('ITER')['$|']($$('LOOP_INSIDE')), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                last_closure = self.$select_closure($$('JS_FUNCTION')['$|']($$('JS_LOOP_INSIDE')));
                if ($not(thrower_closure)) {
                  return self.$error("Invalid next")
                } else if ($eqeq(thrower_closure, last_closure)) {
                  if ($truthy(thrower_closure['$is?']($$('LOOP_INSIDE')))) {
                    return self.$push("continue")
                  } else if ($truthy(thrower_closure['$is?']($$('ITER')['$|']($$('LAMBDA'))))) {
                    return self.$push("return ", self.$expr_or_nil(value))
                  } else {
                    return nil
                  }
                } else {
                  return self.$generate_thrower("next", thrower_closure, value)
                };
                break;
              case "break":
                
                thrower_closure = self.$select_closure($$('SEND')['$|']($$('LAMBDA'))['$|']($$('LOOP')), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                last_closure = self.$select_closure($$('JS_FUNCTION')['$|']($$('JS_LOOP')));
                if ($not(thrower_closure)) {
                  
                  iter_closure = self.$select_closure($$('ITER'), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                  if ($truthy(iter_closure)) {
                    return self.$generate_thrower_without_catcher("break", iter_closure, value)
                  } else {
                    return self.$error("Invalid break")
                  };
                } else if ($eqeq(thrower_closure, last_closure)) {
                  if ($truthy(thrower_closure['$is?']($$('JS_FUNCTION')['$|']($$('LAMBDA'))))) {
                    return self.$push("return ", self.$expr_or_nil(value))
                  } else if ($truthy(thrower_closure['$is?']($$('LOOP')))) {
                    return self.$push("break")
                  } else {
                    return nil
                  }
                } else {
                  return self.$generate_thrower("break", thrower_closure, value)
                };
                break;
              case "retry":
                
                thrower_closure = self.$select_closure($$('RESCUE_RETRIER'), (new Map([["break_after", $$('DEF')['$|']($$('MODULE'))['$|']($$('TOP'))]])));
                last_closure = self.$select_closure($$('JS_LOOP_INSIDE'));
                if ($not(thrower_closure)) {
                  return self.$error("Invalid retry")
                } else if ($eqeq(thrower_closure, last_closure)) {
                  return self.$push("continue")
                } else {
                  return self.$generate_thrower("retry", thrower_closure, value)
                };
                break;
              default:
                return nil
            };
          }, -2);
          
          $def(self, '$closure_is?', function $NodeSupport_closure_is$ques$4(type) {
            var self = this;
            if (self.closure == null) self.closure = nil;

            return self.closure['$is?'](type)
          });
          return $def(self, '$compile_catcher', function $$compile_catcher() {
            var self = this, catchers = nil, catchers_without_eval_return = nil;
            if (self.closure == null) self.closure = nil;

            
            catchers = self.closure.$catchers();
            if ($truthy(catchers['$empty?']())) {
              return nil
            };
            self.$helper("thrower");
            catchers_without_eval_return = catchers.$grep_v("eval_return");
            self.$push("} catch($e) {");
            $send(self, 'indent', [], function $$5(){var self = $$5.$$s == null ? this : $$5.$$s;

              
              $send(catchers, 'each', [], function $$6(type){var self = $$6.$$s == null ? this : $$6.$$s;

                
                if (type == null) type = nil;
                
                switch (type.valueOf()) {
                  case "eval_return":
                    return self.$line("if ($e === Opal.t_eval_return) return $e.$v;")
                  default:
                    return self.$line("if ($e === $t_" + (type) + ") return $e.$v;")
                };}, {$$s: self});
              return self.$line("throw $e;");}, {$$s: self});
            self.$line("}");
            if (!$truthy(catchers_without_eval_return['$empty?']())) {
              $send(self, 'push', [" finally {"].concat($to_a($send(catchers_without_eval_return, 'map', [], function $$7(type){
                
                if (type == null) type = nil;
                return "$t_" + (type) + ".is_orphan = true;";}))).concat(["}"]))
            };
            if ($truthy(self['$closure_is?']($$('SEND')))) {
              self.$unshift("return ")
            };
            if (!$truthy(catchers_without_eval_return['$empty?']())) {
              self.$unshift("var ", $send(catchers_without_eval_return, 'map', [], function $$8(type){
                
                if (type == null) type = nil;
                return "$t_" + (type) + " = $thrower('" + (type) + "')";}).$join(", "), "; ")
            };
            self.$unshift("try { ");
            if ($truthy(self['$closure_is?']($$('JS_FUNCTION')))) {
              return nil
            } else if ($truthy(self.$scope().$await_encountered())) {
              return self.$wrap("(await (async function(){", "})())")
            } else {
              return self.$wrap("(function(){", "})()")
            };
          });
        })($nesting[0], $nesting);
        return (function($base) {
          var self = $module($base, 'CompilerSupport');

          
          return $def(self, '$closure_stack', function $$closure_stack() {
            var self = this, $ret_or_1 = nil;
            if (self.closure_stack == null) self.closure_stack = nil;

            return (self.closure_stack = ($truthy(($ret_or_1 = self.closure_stack)) ? ($ret_or_1) : ([])))
          })
        })($nesting[0]);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
