Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $def = Opal.def, $rb_ge = Opal.rb_ge, $not = Opal.not, $rb_plus = Opal.rb_plus, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,freeze,handle,children,with_temp,==,type,rhs,push,expr,any?,size,compile_masgn,lhs,helper,take_while,!=,drop,each_with_index,compile_assignment,empty?,shift,[],<<,dup,s,new_temp,scope,queue_temp,>=,!,updated,include?,+,last,raise');
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MassAssignNode');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'SIMPLE_ASSIGNMENT', ["lvasgn", "ivasgn", "lvar", "gvasgn", "cdecl", "casgn"].$freeze());
        self.$handle("masgn");
        self.$children("lhs", "rhs");
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return $send(self, 'with_temp', [], function $$1(array){var self = $$1.$$s == null ? this : $$1.$$s, rhs_len = nil;

            
            if (array == null) array = nil;
            if ($eqeq(self.$rhs().$type(), "array")) {
              
              self.$push("" + (array) + " = ", self.$expr(self.$rhs()));
              rhs_len = ($truthy($send(self.$rhs().$children(), 'any?', [], function $$2(c){
                
                if (c == null) c = nil;
                return c.$type()['$==']("splat");})) ? (nil) : (self.$rhs().$children().$size()));
              self.$compile_masgn(self.$lhs().$children(), array, rhs_len);
              return self.$push(", " + (array));
            } else {
              
              self.$helper("to_ary");
              return $send(self, 'with_temp', [], function $$3(retval){var self = $$3.$$s == null ? this : $$3.$$s;

                
                if (retval == null) retval = nil;
                self.$push("" + (retval) + " = ", self.$expr(self.$rhs()));
                self.$push(", " + (array) + " = $to_ary(" + (retval) + ")");
                self.$compile_masgn(self.$lhs().$children(), array);
                return self.$push(", " + (retval));}, {$$s: self});
            };}, {$$s: self})
        });
        
        $def(self, '$compile_masgn', function $$compile_masgn(lhs_items, array, len) {
          var self = this, pre_splat = nil, post_splat = nil, splat = nil, part = nil, tmp = nil;

          
          if (len == null) len = nil;
          pre_splat = $send(lhs_items, 'take_while', [], function $$4(child){
            
            if (child == null) child = nil;
            return child.$type()['$!=']("splat");});
          post_splat = lhs_items.$drop(pre_splat.$size());
          $send(pre_splat, 'each_with_index', [], function $$5(child, idx){var self = $$5.$$s == null ? this : $$5.$$s;

            
            if (child == null) child = nil;
            if (idx == null) idx = nil;
            return self.$compile_assignment(child, array, idx, len);}, {$$s: self});
          if ($truthy(post_splat['$empty?']())) {
            return nil
          } else {
            
            splat = post_splat.$shift();
            if ($truthy(post_splat['$empty?']())) {
              if ($truthy((part = splat.$children()['$[]'](0)))) {
                
                self.$helper("slice");
                part = part.$dup()['$<<'](self.$s("js_tmp", "$slice(" + (array) + ", " + (pre_splat.$size()) + ")"));
                self.$push(", ");
                return self.$push(self.$expr(part));
              } else {
                return nil
              }
            } else {
              
              tmp = self.$scope().$new_temp();
              self.$push(", " + (tmp) + " = " + (array) + ".length - " + (post_splat.$size()));
              self.$push(", " + (tmp) + " = (" + (tmp) + " < " + (pre_splat.$size()) + ") ? " + (pre_splat.$size()) + " : " + (tmp));
              if ($truthy((part = splat.$children()['$[]'](0)))) {
                
                self.$helper("slice");
                part = part.$dup()['$<<'](self.$s("js_tmp", "$slice(" + (array) + ", " + (pre_splat.$size()) + ", " + (tmp) + ")"));
                self.$push(", ");
                self.$push(self.$expr(part));
              };
              $send(post_splat, 'each_with_index', [], function $$6(child, idx){var self = $$6.$$s == null ? this : $$6.$$s;

                
                if (child == null) child = nil;
                if (idx == null) idx = nil;
                if ($eqeq(idx, 0)) {
                  return self.$compile_assignment(child, array, tmp)
                } else {
                  return self.$compile_assignment(child, array, "" + (tmp) + " + " + (idx))
                };}, {$$s: self});
              return self.$scope().$queue_temp(tmp);
            };
          };
        }, -3);
        return $def(self, '$compile_assignment', function $$compile_assignment(child, array, idx, len) {
          var self = this, assign = nil, part = nil, tmp = nil;

          
          if (len == null) len = nil;
          assign = (($not(len) || ($truthy($rb_ge(idx, len)))) ? (self.$s("js_tmp", "(" + (array) + "[" + (idx) + "] == null ? nil : " + (array) + "[" + (idx) + "])")) : (self.$s("js_tmp", "" + (array) + "[" + (idx) + "]")));
          part = child.$updated();
          if ($truthy($$('SIMPLE_ASSIGNMENT')['$include?'](child.$type()))) {
            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))
          } else if ($eqeq(child.$type(), "send")) {
            part = part.$updated(nil, $rb_plus(part.$children(), [assign]))
          } else if ($eqeq(child.$type(), "attrasgn")) {
            part.$last()['$<<'](assign)
          } else if ($eqeq(child.$type(), "mlhs")) {
            
            self.$helper("to_ary");
            tmp = self.$scope().$new_temp();
            self.$push(", (" + (tmp) + " = $to_ary(" + (assign.$children()['$[]'](0)) + ")");
            self.$compile_masgn(child.$children(), tmp);
            self.$push(")");
            self.$scope().$queue_temp(tmp);
            return nil;
          } else {
            self.$raise("Bad child node in masgn LHS: " + (child) + ". LHS: " + (self.$lhs()))
          };
          self.$push(", ");
          return self.$push(self.$expr(part));
        }, -4);
      })($nesting[0], $$('Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
