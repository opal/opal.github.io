Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $send = Opal.send, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,handle,children,push,recv,recvr,expr,property,value,<<,default_compile,meth,receiver_sexp,method_jsid,compile_arguments,iter,s,lhs,rhs,==,type,first,extract_names,empty?,generate_names_definition,generate_names_assignments,stmt?,handle_statement,handle_non_statement,process,private,map,flatten,scan,to_proc');
  
  self.$require("opal/nodes/base");
  self.$require("opal/nodes/call");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super) {
        var self = $klass($base, $super, 'JsAttrNode');

        
        
        self.$handle("jsattr");
        self.$children("recvr", "property");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$recv(self.$recvr()), "[", self.$expr(self.$property()), "]")
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JsAttrAsgnNode');

        
        
        self.$handle("jsattrasgn");
        self.$children("recvr", "property", "value");
        return $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$push(self.$recv(self.$recvr()), "[", self.$expr(self.$property()), "] = ", self.$expr(self.$value()))
        });
      })($nesting[0], $$('Base'));
      (function($base, $super) {
        var self = $klass($base, $super, 'JsCallNode');

        var $proto = self.$$prototype;

        $proto.iter = $proto.arglist = nil;
        
        self.$handle("jscall");
        
        $def(self, '$initialize', function $$initialize($a) {
          var $post_args, $fwd_rest, $yield = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          $post_args = $slice(arguments);
          $fwd_rest = $post_args;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a($fwd_rest), $yield);
          if ($truthy(self.iter)) {
            self.arglist = self.arglist['$<<'](self.iter)
          };
          return (self.iter = nil);
        }, -1);
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$default_compile()
        });
        
        $def(self, '$method_jsid', function $$method_jsid() {
          var self = this;

          return "." + (self.$meth())
        });
        return $def(self, '$compile_using_send', function $$compile_using_send() {
          var self = this;

          
          self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), ".apply(null");
          self.$compile_arguments();
          if ($truthy(self.$iter())) {
            self.$push(".concat(", self.$expr(self.$iter()), ")")
          };
          return self.$push(")");
        });
      })($nesting[0], $$('CallNode'));
      return (function($base, $super) {
        var self = $klass($base, $super, 'Match3Node');

        var $proto = self.$$prototype;

        $proto.level = nil;
        
        self.$handle("match_with_lvasgn");
        self.$children("lhs", "rhs");
        
        $def(self, '$compile', function $$compile() {
          var self = this, sexp = nil, names = nil, names_def = nil, names_assignments = nil;

          
          sexp = self.$s("send", self.$lhs(), "=~", self.$rhs());
          if (($eqeq(self.$lhs().$type(), "regexp") && ($eqeq(self.$lhs().$children().$first().$type(), "str")))) {
            
            names = self.$extract_names(self.$lhs());
            if (!$truthy(names['$empty?']())) {
              
              names_def = self.$generate_names_definition();
              names_assignments = self.$generate_names_assignments(names);
              sexp = ($truthy(self['$stmt?']()) ? (self.$handle_statement(sexp, names_def, names_assignments)) : (self.$handle_non_statement(sexp, names_def, names_assignments)));
            };
          };
          return self.$push(self.$process(sexp, self.level));
        });
        self.$private();
        
        $def(self, '$extract_names', function $$extract_names(regexp_node) {
          var re = nil;

          
          re = regexp_node.$children().$first().$children().$first();
          return $send(re.$scan(/\(\?<([^>]*)>/).$flatten(), 'map', [], "to_sym".$to_proc());
        });
        
        $def(self, '$generate_names_definition', function $$generate_names_definition() {
          var self = this;

          return self.$s("lvasgn", "$m3names", self.$s("if", self.$s("gvar", "$~"), self.$s("send", self.$s("gvar", "$~"), "named_captures"), self.$s("hash")))
        });
        
        $def(self, '$generate_names_assignments', function $$generate_names_assignments(names) {
          var self = this;

          return $send(names, 'map', [], function $$1(name){var self = $$1.$$s == null ? this : $$1.$$s;

            
            if (name == null) name = nil;
            return self.$s("lvasgn", name, self.$s("send", self.$s("lvar", "$m3names"), "[]", self.$s("sym", name)));}, {$$s: self})
        });
        
        $def(self, '$handle_statement', function $$handle_statement(sexp, names_def, names_assignments) {
          var self = this;

          return $send(self, 's', ["begin", sexp, names_def].concat($to_a(names_assignments)))
        });
        return $def(self, '$handle_non_statement', function $$handle_non_statement(sexp, names_def, names_assignments) {
          var self = this;

          return $send(self, 's', ["begin", self.$s("lvasgn", "$m3tmp", sexp), names_def].concat($to_a(names_assignments)).concat([self.$s("lvar", "$m3tmp")]))
        });
      })($nesting[0], $$('Base'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
