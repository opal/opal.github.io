Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $return_val = Opal.return_val, $def = Opal.def, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $Opal = Opal.Opal, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,include,each,[]=,handlers,each_with_index,define_method,[],children,attr_reader,type,top_scope,top_scope=,compile,raise,is_a?,fragment,<<,reverse_each,unshift,push,new,scope,error,loc,==,process,expr,!=,add_scope_local,to_sym,add_scope_ivar,add_scope_gvar,add_scope_temp,helper,with_temp,to_proc,in_while?,instance_variable_get,has_rescue_else?,in_ensure,in_ensure?,in_resbody,in_resbody?,in_rescue,!,class_scope?,sclass?,+,parent,nesting,class_variable_owner_nesting_level,comments,compiler,expression,respond_to?,name,source_buffer,start_with?,end_with?,line');
  
  self.$require("opal/nodes/helpers");
  self.$require("opal/nodes/closure");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.compiler = $proto.sexp = $proto.fragments = $proto.level = nil;
        
        self.$include($$('Helpers'));
        self.$include($$$($$('Closure'), 'NodeSupport'));
        $defs(self, '$handlers', function $$handlers() {
          var self = this, $ret_or_1 = nil;
          if (self.handlers == null) self.handlers = nil;

          return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ((new Map()))))
        });
        $defs(self, '$handle', function $$handle($a) {
          var $post_args, types, self = this;

          
          $post_args = $slice(arguments);
          types = $post_args;
          return $send(types, 'each', [], function $$1(type){var $b, self = $$1.$$s == null ? this : $$1.$$s;

            
            if (type == null) type = nil;
            return ($b = [type, self], $send($$('Base').$handlers(), '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
        }, -1);
        $defs(self, '$children', function $$children($a) {
          var $post_args, names, self = this;

          
          $post_args = $slice(arguments);
          names = $post_args;
          return $send(names, 'each_with_index', [], function $$2(name, idx){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (name == null) name = nil;
            if (idx == null) idx = nil;
            return $send(self, 'define_method', [name], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if (self.sexp == null) self.sexp = nil;

              return self.sexp.$children()['$[]'](idx)}, {$$s: self});}, {$$s: self});
        }, -1);
        $defs(self, '$truthy_optimize?', $return_val(false));
        self.$attr_reader("compiler", "type", "sexp");
        
        $def(self, '$initialize', function $$initialize(sexp, level, compiler) {
          var $a, self = this, $ret_or_1 = nil;

          
          self.sexp = sexp;
          self.type = sexp.$type();
          self.level = level;
          self.compiler = compiler;
          if ($truthy(($ret_or_1 = self.compiler.$top_scope()))) {
            return $ret_or_1
          } else {
            return ($a = [self], $send(self.compiler, 'top_scope=', $a), $a[$a.length - 1])
          };
        });
        
        $def(self, '$children', function $$children() {
          var self = this;

          return self.sexp.$children()
        });
        
        $def(self, '$compile_to_fragments', function $$compile_to_fragments() {
          var $a, self = this;

          
          if ($truthy((($a = self['fragments'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
            return self.fragments
          };
          self.fragments = [];
          self.$compile();
          return self.fragments;
        });
        
        $def(self, '$compile', function $$compile() {
          var self = this;

          return self.$raise("Not Implemented")
        });
        
        $def(self, '$push', function $$push($a) {
          var $post_args, strs, self = this;

          
          $post_args = $slice(arguments);
          strs = $post_args;
          return $send(strs, 'each', [], function $$4(str){var self = $$4.$$s == null ? this : $$4.$$s;
            if (self.fragments == null) self.fragments = nil;

            
            if (str == null) str = nil;
            if ($truthy(str['$is_a?']($$('String')))) {
              str = self.$fragment(str)
            };
            return self.fragments['$<<'](str);}, {$$s: self});
        }, -1);
        
        $def(self, '$unshift', function $$unshift($a) {
          var $post_args, strs, self = this;

          
          $post_args = $slice(arguments);
          strs = $post_args;
          return $send(strs, 'reverse_each', [], function $$5(str){var self = $$5.$$s == null ? this : $$5.$$s;
            if (self.fragments == null) self.fragments = nil;

            
            if (str == null) str = nil;
            if ($truthy(str['$is_a?']($$('String')))) {
              str = self.$fragment(str)
            };
            return self.fragments.$unshift(str);}, {$$s: self});
        }, -1);
        
        $def(self, '$wrap', function $$wrap(pre, post) {
          var self = this;

          
          self.$unshift(pre);
          return self.$push(post);
        });
        
        $def(self, '$fragment', function $$fragment(str, $kwargs) {
          var loc, self = this, $ret_or_1 = nil;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          loc = $hash_get($kwargs, "loc");if (loc == null) loc = true;
          return $$$($$('Opal'), 'Fragment').$new(str, self.$scope(), ($truthy(($ret_or_1 = loc)) ? (self.sexp) : ($ret_or_1)));
        }, -2);
        
        $def(self, '$error', function $$error(msg) {
          var self = this;

          return self.compiler.$error(msg)
        });
        
        $def(self, '$scope', function $$scope() {
          var self = this;

          return self.compiler.$scope()
        });
        
        $def(self, '$top_scope', function $$top_scope() {
          var self = this;

          return self.compiler.$top_scope()
        });
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children, self = this;

          
          $post_args = $slice(arguments, 1);
          children = $post_args;
          return $$$($$$($Opal, 'AST'), 'Node').$new(type, children, (new Map([["location", self.sexp.$loc()]])));
        }, -2);
        
        $def(self, '$expr?', function $Base_expr$ques$6() {
          var self = this;

          return self.level['$==']("expr")
        });
        
        $def(self, '$recv?', function $Base_recv$ques$7() {
          var self = this;

          return self.level['$==']("recv")
        });
        
        $def(self, '$stmt?', function $Base_stmt$ques$8() {
          var self = this;

          return self.level['$==']("stmt")
        });
        
        $def(self, '$process', function $$process(sexp, level) {
          var self = this;

          
          if (level == null) level = "expr";
          return self.compiler.$process(sexp, level);
        }, -2);
        
        $def(self, '$expr', function $$expr(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "expr")
        });
        
        $def(self, '$recv', function $$recv(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "recv")
        });
        
        $def(self, '$stmt', function $$stmt(sexp) {
          var self = this;

          return self.compiler.$process(sexp, "stmt")
        });
        
        $def(self, '$expr_or_nil', function $$expr_or_nil(sexp) {
          var self = this;

          if ($truthy(sexp)) {
            return self.$expr(sexp)
          } else {
            return "nil"
          }
        });
        
        $def(self, '$expr_or_empty', function $$expr_or_empty(sexp) {
          var self = this;

          if (($truthy(sexp) && ($neqeq(sexp.$type(), "nil")))) {
            return self.$expr(sexp)
          } else {
            return ""
          }
        });
        
        $def(self, '$add_local', function $$add_local(name) {
          var self = this;

          return self.$scope().$add_scope_local(name.$to_sym())
        });
        
        $def(self, '$add_ivar', function $$add_ivar(name) {
          var self = this;

          return self.$scope().$add_scope_ivar(name)
        });
        
        $def(self, '$add_gvar', function $$add_gvar(name) {
          var self = this;

          return self.$scope().$add_scope_gvar(name)
        });
        
        $def(self, '$add_temp', function $$add_temp(temp) {
          var self = this;

          return self.$scope().$add_scope_temp(temp)
        });
        
        $def(self, '$helper', function $$helper(name) {
          var self = this;

          return self.compiler.$helper(name)
        });
        
        $def(self, '$with_temp', function $$with_temp() {
          var block = $$with_temp.$$p || nil, self = this;

          $$with_temp.$$p = null;
          
          ;
          return $send(self.compiler, 'with_temp', [], block.$to_proc());
        });
        
        $def(self, '$in_while?', function $Base_in_while$ques$9() {
          var self = this;

          return self.compiler['$in_while?']()
        });
        
        $def(self, '$while_loop', function $$while_loop() {
          var self = this;

          return self.compiler.$instance_variable_get("@while_loop")
        });
        
        $def(self, '$has_rescue_else?', function $Base_has_rescue_else$ques$10() {
          var self = this;

          return self.$scope()['$has_rescue_else?']()
        });
        
        $def(self, '$in_ensure', function $$in_ensure() {
          var block = $$in_ensure.$$p || nil, self = this;

          $$in_ensure.$$p = null;
          
          ;
          return $send(self.$scope(), 'in_ensure', [], block.$to_proc());
        });
        
        $def(self, '$in_ensure?', function $Base_in_ensure$ques$11() {
          var self = this;

          return self.$scope()['$in_ensure?']()
        });
        
        $def(self, '$in_resbody', function $$in_resbody() {
          var block = $$in_resbody.$$p || nil, self = this;

          $$in_resbody.$$p = null;
          
          ;
          return $send(self.$scope(), 'in_resbody', [], block.$to_proc());
        });
        
        $def(self, '$in_resbody?', function $Base_in_resbody$ques$12() {
          var self = this;

          return self.$scope()['$in_resbody?']()
        });
        
        $def(self, '$in_rescue', function $$in_rescue(node) {
          var block = $$in_rescue.$$p || nil, self = this;

          $$in_rescue.$$p = null;
          
          ;
          return $send(self.$scope(), 'in_rescue', [node], block.$to_proc());
        });
        
        $def(self, '$class_variable_owner_nesting_level', function $$class_variable_owner_nesting_level() {
          var self = this, cvar_scope = nil, nesting_level = nil, $ret_or_1 = nil;

          
          cvar_scope = self.$scope();
          nesting_level = 0;
          while ($truthy(($truthy(($ret_or_1 = cvar_scope)) ? (cvar_scope['$class_scope?']()['$!']()) : ($ret_or_1)))) {
          
            if ($truthy(cvar_scope['$sclass?']())) {
              nesting_level = $rb_plus(nesting_level, 1)
            };
            cvar_scope = cvar_scope.$parent();
          };
          return nesting_level;
        });
        
        $def(self, '$class_variable_owner', function $$class_variable_owner() {
          var self = this;

          if ($truthy(self.$scope())) {
            return "" + (self.$scope().$nesting()) + "[" + (self.$class_variable_owner_nesting_level()) + "]"
          } else {
            return "Opal.Object"
          }
        });
        
        $def(self, '$comments', function $$comments() {
          var self = this;

          return self.$compiler().$comments()['$[]'](self.sexp.$loc())
        });
        return $def(self, '$source_location', function $$source_location() {
          var self = this, expr = nil, file = nil, line = nil;

          
          expr = self.sexp.$loc().$expression();
          if ($truthy(expr['$respond_to?']("source_buffer"))) {
            
            file = expr.$source_buffer().$name();
            if ($truthy(file['$start_with?']("corelib/"))) {
              file = "<internal:" + (file) + ">"
            };
            if ($truthy(file['$end_with?'](".js"))) {
              file = "<js:" + (file) + ">"
            };
          } else {
            file = "(eval)"
          };
          line = self.sexp.$loc().$line();
          return "['" + (file) + "', " + (line) + "]";
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
