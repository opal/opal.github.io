Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $defs = Opal.defs, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $truthy = Opal.truthy, $not = Opal.not, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $Opal = Opal.Opal, $to_ary = Opal.to_ary, $alias = Opal.alias, $regexp = Opal.regexp, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $slice = Opal.slice, $rb_plus = Opal.rb_plus, $to_a = Opal.to_a, $eqeq = Opal.eqeq, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,compile,new,include,freeze,join,dirname,first,split,basename,to_s,cleanpath,Pathname,fetch,define_method,option_value,key?,[],!,include?,raise,inspect,[]=,compiler_option,===,backtick_javascript?,warning,attr_reader,attr_accessor,parse,re_raise_with_location,flatten,process,end_with?,code,last,<<,fragment,s,map,to_proc,file,source=,default_parser,tokenize,requirable?,eval?,tap,meta,location,children,associate_locations,eof,magic_comments,to_sym,strip,async_await,async_await_before_typecasting,async_await_set_to_regexp,to_a,gsub,escape,location=,opal_location_from_error,path=,label,label=,lines,-,to_i,line,message,set_backtrace,backtrace,add_opal_location_to_error,warn,empty?,+,start_with?,helpers,new_temp,queue_temp,push_while,pop_while,in_while?,nil?,scope,handlers,type,compile_to_fragments,error,returns,updated,backtick_javascript_or_warn?,==,uses_block!,block_name,find_parent_def,cache,source_map');
  
  self.$require("corelib/string/unpack");
  self.$require("set");
  self.$require("opal/parser");
  self.$require("opal/fragment");
  self.$require("opal/nodes");
  self.$require("opal/eof_content");
  self.$require("opal/errors");
  self.$require("opal/magic_comments");
  self.$require("opal/nodes/closure");
  self.$require("opal/source_map");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$compile', function $$compile(source, options) {
      
      
      if (options == null) options = (new Map());
      return $$('Compiler').$new(source, options).$compile();
    }, -2);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Compiler');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.option_values = $proto.options = $proto.magic_comments = $proto.backtick_javascript_warned = $proto.fragments = $proto.buffer = $proto.source = $proto.source_map = $proto.result = $proto.helpers = $proto.method_calls = $proto.async_await = $proto.unique = $proto.indent = $proto.scope = $proto.case_stmt = $proto.handlers = $proto.requires = $proto.required_trees = $proto.autoloads = nil;
      
      self.$include($$$($$$($$('Nodes'), 'Closure'), 'CompilerSupport'));
      $const_set($nesting[0], 'INDENT', "  ");
      $const_set($nesting[0], 'COMPARE', ["<", ">", "<=", ">="].$freeze());
      $defs(self, '$module_name', function $$module_name(path) {
        var self = this;

        
        path = $$('File').$join($$('File').$dirname(path), $$('File').$basename(path).$split(".").$first());
        return self.$Pathname(path).$cleanpath().$to_s();
      });
      $defs(self, '$compiler_option', function $$compiler_option(name, config) {
        var self = this, method_name = nil;

        
        if (config == null) config = (new Map());
        method_name = config.$fetch("as", name);
        return $send(self, 'define_method', [method_name], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

          return self.$option_value(name, config)}, {$$s: self});
      }, -2);
      
      $def(self, '$option_value', function $$option_value(name, config) {
        var $a, self = this, default_value = nil, valid_values = nil, magic_comment = nil, value = nil;

        
        if ($truthy(self.option_values['$key?'](name))) {
          return self.option_values['$[]'](name)
        };
        default_value = config['$[]']("default");
        valid_values = config['$[]']("valid_values");
        magic_comment = config['$[]']("magic_comment");
        value = self.options.$fetch(name, default_value);
        if (($truthy(magic_comment) && ($truthy(self.magic_comments['$key?'](name))))) {
          value = self.magic_comments.$fetch(name)
        };
        if (($truthy(valid_values) && ($not(valid_values['$include?'](value))))) {
          self.$raise($$('ArgumentError'), "" + ("invalid value " + (value.$inspect()) + " for option " + (name.$inspect()) + " ") + ("(valid values: " + (valid_values.$inspect()) + ")"))
        };
        return ($a = [name, value], $send(self.option_values, '[]=', $a), $a[$a.length - 1]);
      });
      self.$compiler_option("file", (new Map([["default", "(file)"]])));
      self.$compiler_option("method_missing", (new Map([["default", true], ["as", "method_missing?"]])));
      self.$compiler_option("arity_check", (new Map([["default", false], ["as", "arity_check?"]])));
      self.$compiler_option("freezing", (new Map([["default", true], ["as", "freezing?"]])));
      self.$compiler_option("irb", (new Map([["default", false], ["as", "irb?"]])));
      self.$compiler_option("dynamic_require_severity", (new Map([["default", "ignore"], ["valid_values", ["error", "warning", "ignore"]]])));
      self.$compiler_option("requirable", (new Map([["default", false], ["as", "requirable?"]])));
      self.$compiler_option("load", (new Map([["default", false], ["as", "load?"]])));
      self.$compiler_option("esm", (new Map([["default", false], ["as", "esm?"]])));
      self.$compiler_option("no_export", (new Map([["default", false], ["as", "no_export?"]])));
      self.$compiler_option("inline_operators", (new Map([["default", true], ["as", "inline_operators?"]])));
      self.$compiler_option("eval", (new Map([["default", false], ["as", "eval?"]])));
      self.$compiler_option("enable_source_location", (new Map([["default", false], ["as", "enable_source_location?"]])));
      self.$compiler_option("enable_file_source_embed", (new Map([["default", false], ["as", "enable_file_source_embed?"]])));
      self.$compiler_option("use_strict", (new Map([["default", false], ["as", "use_strict?"], ["magic_comment", true]])));
      self.$compiler_option("parse_comments", (new Map([["default", false], ["as", "parse_comments?"]])));
      self.$compiler_option("backtick_javascript", (new Map([["default", nil], ["as", "backtick_javascript?"], ["magic_comment", true]])));
      
      $def(self, '$backtick_javascript_or_warn?', function $Compiler_backtick_javascript_or_warn$ques$2() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($eqeqeq(true, ($ret_or_1 = self['$backtick_javascript?']()))) {
          return true
        } else if ($eqeqeq(nil, $ret_or_1)) {
          
          self.backtick_javascript_warned = ($truthy(($ret_or_2 = self.backtick_javascript_warned)) ? ($ret_or_2) : ((self.$warning("Backtick operator usage interpreted as intent to embed JavaScript; this code will " + "break in Opal 2.0; add a magic comment: `# backtick_javascript: true`"), true)));
          return true;
        } else if ($eqeqeq(false, $ret_or_1)) {
          return false
        } else {
          return nil
        }
      });
      self.$compiler_option("scope_variables", (new Map([["default", []]])));
      self.$compiler_option("await", (new Map([["default", false], ["as", "async_await"], ["magic_comment", true]])));
      self.$attr_reader("result");
      self.$attr_reader("fragments");
      self.$attr_accessor("scope");
      self.$attr_accessor("top_scope");
      self.$attr_reader("case_stmt");
      self.$attr_reader("eof_content");
      self.$attr_reader("comments");
      self.$attr_reader("method_calls");
      self.$attr_reader("magic_comments");
      self.$attr_reader("source");
      self.$attr_accessor("dynamic_cache_result");
      
      $def(self, '$initialize', function $$initialize(source, options) {
        var self = this;

        
        if (options == null) options = (new Map());
        self.source = source;
        self.indent = "";
        self.unique = 0;
        self.options = options;
        self.comments = $$('Hash').$new([]);
        self.case_stmt = nil;
        self.method_calls = $$('Set').$new();
        self.option_values = (new Map());
        self.magic_comments = (new Map());
        return (self.dynamic_cache_result = false);
      }, -2);
      
      $def(self, '$compile', function $$compile() {
        var self = this;

        
        self.$parse();
        self.fragments = $send(self, 're_raise_with_location', [], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
          if (self.sexp == null) self.sexp = nil;

          return self.$process(self.sexp).$flatten()}, {$$s: self});
        if (!$truthy(self.fragments.$last().$code()['$end_with?']("\n"))) {
          self.fragments['$<<'](self.$fragment("\n", nil, self.$s("newline")))
        };
        return (self.result = $send(self.fragments, 'map', [], "code".$to_proc()).$join(""));
      });
      
      $def(self, '$parse', function $$parse() {
        var $a, $b, self = this, sexp = nil, comments = nil, tokens = nil, kind = nil, first_node = nil;

        
        self.buffer = $$$($$$($Opal, 'Parser'), 'SourceBuffer').$new(self.$file(), 1);
        self.buffer['$source='](self.source);
        self.parser = $$$($$('Opal'), 'Parser').$default_parser();
        $b = $send(self, 're_raise_with_location', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s;
          if (self.parser == null) self.parser = nil;
          if (self.buffer == null) self.buffer = nil;

          return self.parser.$tokenize(self.buffer)}, {$$s: self}), $a = $to_ary($b), (sexp = ($a[0] == null ? nil : $a[0])), (comments = ($a[1] == null ? nil : $a[1])), (tokens = ($a[2] == null ? nil : $a[2])), $b;
        kind = ($truthy(self['$requirable?']()) ? ("require") : ($truthy(self['$eval?']()) ? ("eval") : ("main")));
        self.sexp = $send(sexp, 'tap', [], function $$5(i){var $c;

          
          if (i == null) i = nil;
          return ($c = ["kind", kind], $send(i.$meta(), '[]=', $c), $c[$c.length - 1]);});
        if ($truthy(sexp.$children().$first().$location())) {
          first_node = sexp.$children().$first()
        };
        self.comments = $$$($$$($$$('Parser'), 'Source'), 'Comment').$associate_locations(first_node, comments);
        self.magic_comments = $$('MagicComments').$parse(first_node, comments);
        return (self.eof_content = $$('EofContent').$new(tokens, self.source).$eof());
      });
      
      $def(self, '$source_map', function $$source_map() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_map))) {
          return $ret_or_1
        } else {
          return $$$($$$($Opal, 'SourceMap'), 'File').$new(self.fragments, self.$file(), self.source, self.result)
        }
      });
      
      $def(self, '$helpers', function $$helpers() {
        var self = this, $ret_or_1 = nil;

        return (self.helpers = ($truthy(($ret_or_1 = self.helpers)) ? ($ret_or_1) : ($$('Set').$new($send(self.$magic_comments()['$[]']("helpers").$to_s().$split(","), 'map', [], function $$6(h){
          
          if (h == null) h = nil;
          return h.$strip().$to_sym();})))))
      });
      
      $def(self, '$record_method_call', function $$record_method_call(mid) {
        var self = this;

        return self.method_calls['$<<'](mid)
      });
      $alias(self, "async_await_before_typecasting", "async_await");
      
      $def(self, '$async_await', function $$async_await() {
        var $a, self = this, original = nil, $ret_or_1 = nil;

        if ($truthy((($a = self['async_await'], $a != null && $a !== nil) ? 'instance-variable' : nil))) {
          return self.async_await
        } else {
          
          original = self.$async_await_before_typecasting();
          return (self.async_await = ($eqeqeq($$('String'), ($ret_or_1 = original)) ? (self.$async_await_set_to_regexp($send(original.$split(","), 'map', [], function $$7(h){
            
            if (h == null) h = nil;
            return h.$strip().$to_sym();}))) : (($eqeqeq($$('Array'), $ret_or_1) || ($eqeqeq($$('Set'), $ret_or_1))) ? (self.$async_await_set_to_regexp($send(original.$to_a(), 'map', [], "to_sym".$to_proc()))) : (($eqeqeq($$('Regexp'), $ret_or_1) || (($eqeqeq(true, $ret_or_1) || ($eqeqeq(false, $ret_or_1))))) ? (original) : (self.$raise("A value of await compiler option can be either " + "a Set, an Array, a String or a Boolean."))))));
        }
      });
      
      $def(self, '$async_await_set_to_regexp', function $$async_await_set_to_regexp(set) {
        
        
        set = $send(set, 'map', [], function $$8(name){
          
          if (name == null) name = nil;
          return $$('Regexp').$escape(name.$to_s()).$gsub("\\*", ".*?");});
        set = set.$join("|");
        return $regexp(["^(", set, ")$"]);
      });
      
      $def(self, '$error', function $$error(msg, line) {
        var self = this, error = nil;

        
        if (line == null) line = nil;
        error = $$$($Opal, 'SyntaxError').$new(msg);
        error['$location=']($$$($$('Opal'), 'OpalBacktraceLocation').$new(self.$file(), line));
        return self.$raise(error);
      }, -2);
      
      $def(self, '$re_raise_with_location', function $$re_raise_with_location() {
        var $yield = $$re_raise_with_location.$$p || nil, self = this, error = nil, opal_location = nil, $ret_or_1 = nil, new_error = nil;

        $$re_raise_with_location.$$p = null;
        try {
          return Opal.yieldX($yield, []);
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError'), $$$($Opal, 'SyntaxError')])) {(error = $err)
            try {
              
              opal_location = $Opal.$opal_location_from_error(error);
              opal_location['$path='](self.$file());
              if ($truthy(($ret_or_1 = opal_location.$label()))) {
                $ret_or_1
              } else {
                opal_location['$label='](self.source.$lines()['$[]']($rb_minus(opal_location.$line().$to_i(), 1)).$strip())
              };
              new_error = $$$($Opal, 'SyntaxError').$new(error.$message());
              new_error.$set_backtrace(error.$backtrace());
              $Opal.$add_opal_location_to_error(opal_location, new_error);
              return self.$raise(new_error);
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        }
      });
      
      $def(self, '$warning', function $$warning(msg, line) {
        var self = this;

        
        if (line == null) line = nil;
        return self.$warn("warning: " + (msg) + " -- " + (self.$file()) + ":" + (line));
      }, -2);
      
      $def(self, '$parser_indent', $return_ivar("indent"));
      
      $def(self, '$s', function $$s(type, $a) {
        var $post_args, children;

        
        $post_args = $slice(arguments, 1);
        children = $post_args;
        return $$$($$$($Opal, 'AST'), 'Node').$new(type, children);
      }, -2);
      
      $def(self, '$fragment', function $$fragment(str, scope, sexp) {
        
        
        if (sexp == null) sexp = nil;
        return $$('Fragment').$new(str, scope, sexp);
      }, -3);
      
      $def(self, '$unique_temp', function $$unique_temp(name) {
        var self = this, unique = nil;

        
        name = name.$to_s();
        if (($truthy(name) && ($not(name['$empty?']())))) {
          name = name.$to_s().$gsub("<=>", "$lt_eq_gt").$gsub("===", "$eq_eq_eq").$gsub("==", "$eq_eq").$gsub("=~", "$eq_tilde").$gsub("!~", "$excl_tilde").$gsub("!=", "$not_eq").$gsub("<=", "$lt_eq").$gsub(">=", "$gt_eq").$gsub("=", "$eq").$gsub("?", "$ques").$gsub("!", "$excl").$gsub("/", "$slash").$gsub("%", "$percent").$gsub("+", "$plus").$gsub("-", "$minus").$gsub("<", "$lt").$gsub(">", "$gt").$gsub(/[^\w\$]/, "$")
        };
        unique = (self.unique = $rb_plus(self.unique, 1));
        return "" + (($truthy(name['$start_with?']("$")) ? (nil) : ("$"))) + (name) + "$" + (unique);
      });
      
      $def(self, '$helper', function $$helper(name) {
        var self = this;

        return self.$helpers()['$<<'](name)
      });
      
      $def(self, '$indent', function $$indent() {
        var $yield = $$indent.$$p || nil, self = this, indent = nil, res = nil;

        $$indent.$$p = null;
        
        indent = self.indent;
        self.indent = $rb_plus(self.indent, $$('INDENT'));
        self.space = "\n" + (self.indent);
        res = Opal.yieldX($yield, []);
        self.indent = indent;
        self.space = "\n" + (self.indent);
        return res;
      });
      
      $def(self, '$with_temp', function $$with_temp() {
        var $yield = $$with_temp.$$p || nil, self = this, tmp = nil, res = nil;

        $$with_temp.$$p = null;
        
        tmp = self.scope.$new_temp();
        res = Opal.yield1($yield, tmp);
        self.scope.$queue_temp(tmp);
        return res;
      });
      
      $def(self, '$in_while', function $$in_while() {
        var $yield = $$in_while.$$p || nil, self = this, result = nil;

        $$in_while.$$p = null;
        
        if (!($yield !== nil)) {
          return nil
        };
        self.while_loop = self.scope.$push_while();
        result = Opal.yieldX($yield, []);
        self.scope.$pop_while();
        return result;
      });
      
      $def(self, '$in_case', function $$in_case() {
        var $yield = $$in_case.$$p || nil, self = this, old = nil;

        $$in_case.$$p = null;
        
        if (!($yield !== nil)) {
          return nil
        };
        old = self.case_stmt;
        self.case_stmt = (new Map());
        Opal.yieldX($yield, []);
        return (self.case_stmt = old);
      });
      
      $def(self, '$in_while?', function $Compiler_in_while$ques$9() {
        var self = this;

        return self.scope['$in_while?']()
      });
      
      $def(self, '$process', function $$process(sexp, level) {
        var self = this, handler = nil;

        
        if (level == null) level = "expr";
        if ($truthy(sexp['$nil?']())) {
          return self.$fragment("", self.$scope())
        };
        if ($truthy((handler = self.$handlers()['$[]'](sexp.$type())))) {
          return handler.$new(sexp, level, self).$compile_to_fragments()
        } else {
          return self.$error("Unsupported sexp: " + (sexp.$type()))
        };
      }, -2);
      
      $def(self, '$handlers', function $$handlers() {
        var self = this, $ret_or_1 = nil;

        return (self.handlers = ($truthy(($ret_or_1 = self.handlers)) ? ($ret_or_1) : ($$$($$$($$('Opal'), 'Nodes'), 'Base').$handlers())))
      });
      
      $def(self, '$requires', function $$requires() {
        var self = this, $ret_or_1 = nil;

        return (self.requires = ($truthy(($ret_or_1 = self.requires)) ? ($ret_or_1) : ([])))
      });
      
      $def(self, '$required_trees', function $$required_trees() {
        var self = this, $ret_or_1 = nil;

        return (self.required_trees = ($truthy(($ret_or_1 = self.required_trees)) ? ($ret_or_1) : ([])))
      });
      
      $def(self, '$autoloads', function $$autoloads() {
        var self = this, $ret_or_1 = nil;

        return (self.autoloads = ($truthy(($ret_or_1 = self.autoloads)) ? ($ret_or_1) : ([])))
      });
      
      $def(self, '$returns', function $$returns(sexp) {
        var $a, $b, self = this, when_sexp = nil, then_sexp = nil, body_sexp = nil, resbodies = nil, else_sexp = nil, klass = nil, lvar = nil, body = nil, rescue_sexp = nil, ensure_body = nil, rest = nil, last = nil, cond = nil, true_body = nil, false_body = nil;

        
        if (!$truthy(sexp)) {
          return self.$returns(self.$s("nil"))
        };
        
        switch (sexp.$type().valueOf()) {
          case "undef":
            return self.$returns(sexp.$updated("begin", [sexp, self.$s("nil")]))
          case "break":
          case "next":
          case "redo":
          case "retry":
            return sexp
          case "yield":
            return sexp.$updated("returnable_yield", nil)
          case "when":
            
            $a = [].concat($to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (when_sexp = $slice($a, 0, $b)), (then_sexp = ($a[$b] == null ? nil : $a[$b])), $a;
            return sexp.$updated(nil, [].concat($to_a(when_sexp)).concat([self.$returns(then_sexp)]));
          case "rescue":
            
            $a = [].concat($to_a(sexp)), (body_sexp = ($a[0] == null ? nil : $a[0])), $b = $a.length - 1, $b = ($b < 1) ? 1 : $b, (resbodies = $slice($a, 1, $b)), (else_sexp = ($a[$b] == null ? nil : $a[$b])), $a;
            resbodies = $send(resbodies, 'map', [], function $$10(resbody){var self = $$10.$$s == null ? this : $$10.$$s;

              
              if (resbody == null) resbody = nil;
              return self.$returns(resbody);}, {$$s: self});
            if ($truthy(else_sexp)) {
              else_sexp = self.$returns(else_sexp)
            };
            return sexp.$updated(nil, [self.$returns(body_sexp)].concat($to_a(resbodies)).concat([else_sexp]));
          case "resbody":
            
            $a = [].concat($to_a(sexp)), (klass = ($a[0] == null ? nil : $a[0])), (lvar = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
            return sexp.$updated(nil, [klass, lvar, self.$returns(body)]);
          case "ensure":
            
            $a = [].concat($to_a(sexp)), (rescue_sexp = ($a[0] == null ? nil : $a[0])), (ensure_body = ($a[1] == null ? nil : $a[1])), $a;
            sexp = sexp.$updated(nil, [self.$returns(rescue_sexp), ensure_body]);
            return sexp.$updated("js_return", [sexp]);
          case "begin":
          case "kwbegin":
            
            $a = [].concat($to_a(sexp)), $b = $a.length - 1, $b = ($b < 0) ? 0 : $b, (rest = $slice($a, 0, $b)), (last = ($a[$b] == null ? nil : $a[$b])), $a;
            return sexp.$updated(nil, [].concat($to_a(rest)).concat([self.$returns(last)]));
          case "while":
          case "until":
          case "while_post":
          case "until_post":
            return sexp
          case "return":
          case "js_return":
          case "returnable_yield":
            return sexp
          case "xstr":
            if ($truthy(self['$backtick_javascript_or_warn?']())) {
              return sexp.$updated(nil, [$send(self, 's', ["js_return"].concat($to_a(sexp.$children())))])
            } else {
              return sexp
            }
            break;
          case "if":
            
            $a = [].concat($to_a(sexp)), (cond = ($a[0] == null ? nil : $a[0])), (true_body = ($a[1] == null ? nil : $a[1])), (false_body = ($a[2] == null ? nil : $a[2])), $a;
            return $send(sexp.$updated(nil, [cond, self.$returns(true_body), self.$returns(false_body)]), 'tap', [], function $$11(s){var $c;

              
              if (s == null) s = nil;
              return ($c = ["returning", true], $send(s.$meta(), '[]=', $c), $c[$c.length - 1]);});
          default:
            if (($eqeq(sexp.$type(), "send") && ($eqeq(sexp.$children()['$[]'](1), "debugger")))) {
              return sexp.$updated("begin", [sexp, self.$s("js_return", self.$s("nil"))])
            } else {
              return sexp.$updated("js_return", [sexp])
            }
        };
      });
      
      $def(self, '$handle_block_given_call', function $$handle_block_given_call(sexp) {
        var self = this, scope = nil;

        
        self.scope['$uses_block!']();
        if ($truthy(self.scope.$block_name())) {
          return self.$fragment("(" + (self.scope.$block_name()) + " !== nil)", self.$scope(), sexp)
        } else if (($truthy((scope = self.scope.$find_parent_def())) && ($truthy(scope.$block_name())))) {
          return self.$fragment("(" + (scope.$block_name()) + " !== nil)", scope, sexp)
        } else {
          return self.$fragment("false", scope, sexp)
        };
      });
      
      $def(self, '$marshal_dump', function $$marshal_dump() {
        var self = this, $ret_or_1 = nil;

        return [self.options, self.option_values, (self.source_map = ($truthy(($ret_or_1 = self.source_map)) ? ($ret_or_1) : (self.$source_map().$cache()))), self.magic_comments, self.result, self.required_trees, self.requires, self.autoloads]
      });
      return $def(self, '$marshal_load', function $$marshal_load(src) {
        var $a, $b, self = this;

        return $b = src, $a = $to_ary($b), (self.options = ($a[0] == null ? nil : $a[0])), (self.option_values = ($a[1] == null ? nil : $a[1])), (self.source_map = ($a[2] == null ? nil : $a[2])), (self.magic_comments = ($a[3] == null ? nil : $a[3])), (self.result = ($a[4] == null ? nil : $a[4])), (self.required_trees = ($a[5] == null ? nil : $a[5])), (self.requires = ($a[6] == null ? nil : $a[6])), (self.autoloads = ($a[7] == null ? nil : $a[7])), $b
      });
    })($nesting[0], null, $nesting);
  })($nesting[0], $nesting);
});
