Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $slice = Opal.slice, $truthy = Opal.truthy, $const_set = Opal.const_set, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $range = Opal.range, self = Opal.top, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('require,instance_exec,to_proc,new,match,inspect,attr_accessor,nil?,+,type,children,!=,length,all?,times,[],==,is_a?,first,===,include?,<<,captures');
  
  self.$require("ast");
  self.$require("parser/ast/node");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Matcher');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.root = $proto.captures = nil;
        
        
        $def(self, '$initialize', function $$initialize() {
          var block = $$initialize.$$p || nil, self = this;

          $$initialize.$$p = null;
          
          ;
          return (self.root = $send(self, 'instance_exec', [], block.$to_proc()));
        });
        
        $def(self, '$s', function $$s(type, $a) {
          var $post_args, children;

          
          $post_args = $slice(arguments, 1);
          children = $post_args;
          return $$('Node').$new(type, children);
        }, -2);
        
        $def(self, '$cap', function $$cap(capture) {
          
          return $$('Node').$new("capture", [capture])
        });
        
        $def(self, '$match', function $$match(ast) {
          var self = this, $ret_or_1 = nil;

          
          self.captures = [];
          if ($truthy(($ret_or_1 = self.root.$match(ast, self)))) {
            $ret_or_1
          } else {
            
            return false;
          };
          return self.captures;
        });
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Opal::AST::Matcher: " + (self.root.$inspect()) + ">"
        });
        self.$attr_accessor("captures");
        return $const_set($nesting[0], 'Node', $send($$('Struct'), 'new', ["type", "children"], function $Matcher$1(){var self = $Matcher$1.$$s == null ? this : $Matcher$1.$$s;

          
          
          $def(self, '$match', function $$match(ast, matcher) {
            var self = this, ast_parts = nil, self_parts = nil;

            
            if ($truthy(ast['$nil?']())) {
              return false
            };
            ast_parts = $rb_plus([ast.$type()], ast.$children());
            self_parts = $rb_plus([self.$type()], self.$children());
            if ($neqeq(ast_parts.$length(), self_parts.$length())) {
              return false
            };
            return $send(ast_parts.$length().$times(), 'all?', [], function $$2(i){var ast_elem = nil, self_elem = nil, capture = nil, res = nil, $ret_or_1 = nil;

              
              if (i == null) i = nil;
              ast_elem = ast_parts['$[]'](i);
              self_elem = self_parts['$[]'](i);
              if (($truthy(self_elem['$is_a?']($$('Node'))) && ($eqeq(self_elem.$type(), "capture")))) {
                
                capture = true;
                self_elem = self_elem.$children().$first();
              };
              res = ($eqeqeq($$('Node'), ($ret_or_1 = self_elem)) ? (self_elem.$match(ast_elem, matcher)) : ($eqeqeq($$('Array'), $ret_or_1) ? (self_elem['$include?'](ast_elem)) : ($eqeqeq("*", $ret_or_1) || (self_elem['$=='](ast_elem)))));
              if ($truthy(capture)) {
                matcher.$captures()['$<<'](ast_elem)
              };
              return res;});
          });
          return $def(self, '$inspect', function $$inspect() {
            var self = this;

            if ($eqeq(self.$type(), "capture")) {
              return "{" + (self.$children().$first().$inspect()) + "}"
            } else {
              return "s(" + (self.$type().$inspect()) + ", " + (self.$children().$inspect()['$[]']($range(1, -2, false))) + ")"
            }
          });}, {$$s: self}));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
});
