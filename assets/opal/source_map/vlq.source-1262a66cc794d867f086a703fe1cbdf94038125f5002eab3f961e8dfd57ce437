Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $const_set = Opal.const_set, $rb_minus = Opal.rb_minus, $send = Opal.send, $range = Opal.range, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $thrower = Opal.thrower, $defs = Opal.defs, $eqeq = Opal.eqeq, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('<<,-,split,inject,[]=,[],each,<,+,-@,loop,&,>>,>,|,join,any?,shift,raise,==,map,encode,each_with_index,decode');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'VLQ');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'VLQ_BASE_SHIFT', 5);
    $const_set($nesting[0], 'VLQ_BASE', (1)['$<<']($$('VLQ_BASE_SHIFT')));
    $const_set($nesting[0], 'VLQ_BASE_MASK', $rb_minus($$('VLQ_BASE'), 1));
    $const_set($nesting[0], 'VLQ_CONTINUATION_BIT', $$('VLQ_BASE'));
    $const_set($nesting[0], 'BASE64_DIGITS', "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".$split(""));
    $const_set($nesting[0], 'BASE64_VALUES', $send($range(0, 64, true), 'inject', [(new Map())], function $VLQ$1(h, i){
      
      if (h == null) h = nil;
      if (i == null) i = nil;
      h['$[]=']($$('BASE64_DIGITS')['$[]'](i), i);
      return h;}));
    $defs(self, '$encode', function $$encode(ary) {
      var self = this, result = nil;

      
      result = [];
      $send(ary, 'each', [], function $$2(n){var self = $$2.$$s == null ? this : $$2.$$s, vlq = nil;

        
        if (n == null) n = nil;
        vlq = ($truthy($rb_lt(n, 0)) ? ($rb_plus(n['$-@']()['$<<'](1), 1)) : (n['$<<'](1)));
        return (function(){try { var $t_break = $thrower('break'); return $send(self, 'loop', [], function $$3(){var digit = nil;

          
          digit = vlq['$&']($$('VLQ_BASE_MASK'));
          vlq = vlq['$>>']($$('VLQ_BASE_SHIFT'));
          if ($truthy($rb_gt(vlq, 0))) {
            digit = digit['$|']($$('VLQ_CONTINUATION_BIT'))
          };
          result['$<<']($$('BASE64_DIGITS')['$[]'](digit));
          if ($truthy($rb_gt(vlq, 0))) {
            return nil
          } else {
            $t_break.$throw(nil, $$3.$$is_lambda)
          };})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();}, {$$s: self});
      return result.$join();
    });
    $defs(self, '$decode', function $$decode(str) {
      var self = this, result = nil, chars = nil, vlq = nil, shift = nil, continuation = nil, char$ = nil, digit = nil;

      
      result = [];
      chars = str.$split("");
      while ($truthy(chars['$any?']())) {
      
        vlq = 0;
        shift = 0;
        continuation = true;
        while ($truthy(continuation)) {
        
          char$ = chars.$shift();
          if (!$truthy(char$)) {
            self.$raise($$('ArgumentError'))
          };
          digit = $$('BASE64_VALUES')['$[]'](char$);
          if ($eqeq(digit['$&']($$('VLQ_CONTINUATION_BIT')), 0)) {
            continuation = false
          };
          digit = digit['$&']($$('VLQ_BASE_MASK'));
          vlq = $rb_plus(vlq, digit['$<<'](shift));
          shift = $rb_plus(shift, $$('VLQ_BASE_SHIFT'));
        };
        result['$<<'](($eqeq(vlq['$&'](1), 1) ? (vlq['$>>'](1)['$-@']()) : (vlq['$>>'](1))));
      };
      return result;
    });
    $defs(self, '$encode_mappings', function $$encode_mappings(ary) {
      var self = this;

      return $send(ary, 'map', [], function $$4(group){var self = $$4.$$s == null ? this : $$4.$$s;

        
        if (group == null) group = nil;
        return $send(group, 'map', [], function $$5(segment){var self = $$5.$$s == null ? this : $$5.$$s;

          
          if (segment == null) segment = nil;
          return self.$encode(segment);}, {$$s: self}).$join(",");}, {$$s: self}).$join(";")
    });
    return $defs(self, '$decode_mappings', function $$decode_mappings(str) {
      var self = this, mappings = nil;

      
      mappings = [];
      $send(str.$split(";"), 'each_with_index', [], function $$6(group, index){var self = $$6.$$s == null ? this : $$6.$$s;

        
        if (group == null) group = nil;
        if (index == null) index = nil;
        mappings['$[]='](index, []);
        return $send(group.$split(","), 'each', [], function $$7(segment){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (segment == null) segment = nil;
          return mappings['$[]'](index)['$<<'](self.$decode(segment));}, {$$s: self});}, {$$s: self});
      return mappings;
    });
  })($$$($$('Opal'), 'SourceMap'), $nesting)
});
