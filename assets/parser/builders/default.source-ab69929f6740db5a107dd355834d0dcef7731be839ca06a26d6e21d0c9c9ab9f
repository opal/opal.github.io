Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $assign_ivar_val = Opal.assign_ivar_val, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $neqeq = Opal.neqeq, $to_ary = Opal.to_ary, $rb_ge = Opal.rb_ge, $range = Opal.range, $rb_minus = Opal.rb_minus, $slice = Opal.slice, $rb_plus = Opal.rb_plus, $rb_gt = Opal.rb_gt, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_accessor,n0,token_map,numeric,n,value,new,loc,private,+@,-@,updated,join,expression,string_value,delimited_string_map,unquoted_map,collapse_string_parts?,nil?,first,children,string_map,prefix_string_map,to_sym,collection_map,empty?,==,version,diagnostic,!,type,dedent,map,interrupt,compact,uniq,sort,each_char,to_proc,static_regexp,message,<<,regexp_map,unary_op_map,binary_op_map,!=,%,size,last,each_slice,pair_keyword_map,pair_quoted_map,symbol_compose,adjust,=~,pair_keyword,accessible,each,eql?,>=,add?,range_map,variable_map,name,source_buffer,dup,line,emit_encoding,class,any?,end_with?,to_s,try_declare_numparam,declared?,static_env,var_send_map,top,current_arg_stack,parser,constant_map,in_def,context,[],check_assignment_to_numparam,check_reserved_for_numparam,declare,with_expression,with_operator,join_exprs,module_definition_map,definition_map,endless_definition_map,validate_definee,keyword_map,check_duplicate_args,validate_no_forward_arg_after_restarg,length,emit_forward_arg,forward_arg,arg_prefix_map,kwarg_map,emit_procarg0,emit_arg_inside_procarg0,location,resize,-,end,call_type_for_dot,emit_kwargs,rewrite_hash_args_to_kwargs,send_map,emit_lambda,expr_map,keyword,include?,block_map,array,+,emit_index,index_map,send_index_map,send_binary_op_map,static_regexp_node,names,send_unary_op_map,check_condition,condition_map,keyword_mod_map,ternary_map,for_map,>,count,rescue_body_map,eh_keyword_map,push,none?,one?,begin,guard_map,check_lvar_name,check_duplicate_pattern_variable,match_hash_var_from_str,match_var,check_duplicate_pattern_key,static_string,pair_quoted,match_hash_var,<=,===,check_duplicate_arg,is_a?,[]=,arg_name_collides?,<,in_dynamic_block?,has_numparams?,max_numparam_stack,start_with?,pattern_variables,pattern_hash_keys,with,begin_pos,end_pos,encode,valid_encoding?,process,diagnostics,send,kwargs?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Default');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.parser = $proto.emit_file_line_as_literals = nil;
      
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_lambda")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_lambda = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_procarg0")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_procarg0 = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_encoding")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_encoding = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_index")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_index = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_arg_inside_procarg0")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_arg_inside_procarg0 = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_forward_arg")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_forward_arg = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_kwargs")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_kwargs = false;
      (function(self, $parent_nesting) {
        
        return self.$attr_accessor("emit_match_pattern")
      })(Opal.get_singleton_class(self), $nesting);
      self.emit_match_pattern = false;
      (function(self, $parent_nesting) {
        
        return $def(self, '$modernize', function $$modernize() {
          var self = this;

          
          self.emit_lambda = true;
          self.emit_procarg0 = true;
          self.emit_encoding = true;
          self.emit_index = true;
          self.emit_arg_inside_procarg0 = true;
          self.emit_forward_arg = true;
          self.emit_kwargs = true;
          return (self.emit_match_pattern = true);
        })
      })(Opal.get_singleton_class(self), $nesting);
      self.$attr_accessor("parser");
      self.$attr_accessor("emit_file_line_as_literals");
      
      $def(self, '$initialize', $assign_ivar_val("emit_file_line_as_literals", true));
      
      $def(self, '$nil', function $$nil(nil_t) {
        var self = this;

        return self.$n0("nil", self.$token_map(nil_t))
      });
      
      $def(self, '$true', function $Default_true$1(true_t) {
        var self = this;

        return self.$n0("true", self.$token_map(true_t))
      });
      
      $def(self, '$false', function $Default_false$2(false_t) {
        var self = this;

        return self.$n0("false", self.$token_map(false_t))
      });
      
      $def(self, '$integer', function $$integer(integer_t) {
        var self = this;

        return self.$numeric("int", integer_t)
      });
      
      $def(self, '$float', function $Default_float$3(float_t) {
        var self = this;

        return self.$numeric("float", float_t)
      });
      
      $def(self, '$rational', function $$rational(rational_t) {
        var self = this;

        return self.$numeric("rational", rational_t)
      });
      
      $def(self, '$complex', function $$complex(complex_t) {
        var self = this;

        return self.$numeric("complex", complex_t)
      });
      
      $def(self, '$numeric', function $$numeric(kind, token) {
        var self = this;

        return self.$n(kind, [self.$value(token)], $$$($$$($$('Source'), 'Map'), 'Operator').$new(nil, self.$loc(token)))
      });
      self.$private("numeric");
      
      $def(self, '$unary_num', function $$unary_num(unary_t, numeric) {
        var $a, self = this, value = nil, operator_loc = nil;

        
        $a = [].concat($to_a(numeric)), (value = ($a[0] == null ? nil : $a[0])), $a;
        operator_loc = self.$loc(unary_t);
        
        switch (self.$value(unary_t).valueOf()) {
          case "+":
            value = value['$+@']()
            break;
          case "-":
            value = value['$-@']()
            break;
          default:
            nil
        };
        return numeric.$updated(nil, [value], (new Map([["location", $$$($$$($$('Source'), 'Map'), 'Operator').$new(operator_loc, operator_loc.$join(numeric.$loc().$expression()))]])));
      });
      
      $def(self, '$__LINE__', function $$__LINE__(__LINE__t) {
        var self = this;

        return self.$n0("__LINE__", self.$token_map(__LINE__t))
      });
      
      $def(self, '$string', function $$string(string_t) {
        var self = this;

        return self.$n("str", [self.$string_value(string_t)], self.$delimited_string_map(string_t))
      });
      
      $def(self, '$string_internal', function $$string_internal(string_t) {
        var self = this;

        return self.$n("str", [self.$string_value(string_t)], self.$unquoted_map(string_t))
      });
      
      $def(self, '$string_compose', function $$string_compose(begin_t, parts, end_t) {
        var self = this;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          if (($truthy(begin_t['$nil?']()) && ($truthy(end_t['$nil?']())))) {
            return parts.$first()
          } else {
            return self.$n("str", parts.$first().$children(), self.$string_map(begin_t, parts, end_t))
          }
        } else {
          return self.$n("dstr", [].concat($to_a(parts)), self.$string_map(begin_t, parts, end_t))
        }
      });
      
      $def(self, '$character', function $$character(char_t) {
        var self = this;

        return self.$n("str", [self.$string_value(char_t)], self.$prefix_string_map(char_t))
      });
      
      $def(self, '$__FILE__', function $$__FILE__(__FILE__t) {
        var self = this;

        return self.$n0("__FILE__", self.$token_map(__FILE__t))
      });
      
      $def(self, '$symbol', function $$symbol(symbol_t) {
        var self = this;

        return self.$n("sym", [self.$string_value(symbol_t).$to_sym()], self.$prefix_string_map(symbol_t))
      });
      
      $def(self, '$symbol_internal', function $$symbol_internal(symbol_t) {
        var self = this;

        return self.$n("sym", [self.$string_value(symbol_t).$to_sym()], self.$unquoted_map(symbol_t))
      });
      
      $def(self, '$symbol_compose', function $$symbol_compose(begin_t, parts, end_t) {
        var self = this, str = nil;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          
          str = parts.$first();
          return self.$n("sym", [str.$children().$first().$to_sym()], self.$collection_map(begin_t, str.$loc().$expression(), end_t));
        } else if (($eqeq(self.parser.$version(), 18) && ($truthy(parts['$empty?']())))) {
          return self.$diagnostic("error", "empty_symbol", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        } else {
          return self.$n("dsym", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t))
        }
      });
      
      $def(self, '$xstring_compose', function $$xstring_compose(begin_t, parts, end_t) {
        var self = this;

        return self.$n("xstr", [].concat($to_a(parts)), self.$string_map(begin_t, parts, end_t))
      });
      
      $def(self, '$dedent_string', function $$dedent_string(node, dedent_level) {
        var dedenter = nil, str = nil, children = nil;

        
        if ($not(dedent_level['$nil?']())) {
          
          dedenter = $$$($$('Lexer'), 'Dedenter').$new(dedent_level);
          
          switch (node.$type().valueOf()) {
            case "str":
              
              str = node.$children().$first();
              dedenter.$dedent(str);
              break;
            case "dstr":
            case "xstr":
              
              children = $send(node.$children(), 'map', [], function $$4(str_node){
                
                if (str_node == null) str_node = nil;
                if ($eqeq(str_node.$type(), "str")) {
                  
                  str = str_node.$children().$first();
                  dedenter.$dedent(str);
                  if ($truthy(str['$empty?']())) {
                    return nil
                  };
                } else {
                  dedenter.$interrupt()
                };
                return str_node;});
              node = node.$updated(nil, children.$compact());
              break;
            default:
              nil
          };
        };
        return node;
      });
      
      $def(self, '$regexp_options', function $$regexp_options(regopt_t) {
        var self = this, options = nil;

        
        options = $send(self.$value(regopt_t).$each_char().$sort().$uniq(), 'map', [], "to_sym".$to_proc());
        return self.$n("regopt", options, self.$token_map(regopt_t));
      });
      
      $def(self, '$regexp_compose', function $$regexp_compose(begin_t, parts, end_t, options) {
        var self = this, e = nil;

        
        
        try {
          self.$static_regexp(parts, options)
        } catch ($err) {
          if (Opal.rescue($err, [$$('RegexpError')])) {(e = $err)
            try {
              self.$diagnostic("error", "invalid_regexp", (new Map([["message", e.$message()]])), self.$loc(begin_t).$join(self.$loc(end_t)))
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };;
        return self.$n("regexp", parts['$<<'](options), self.$regexp_map(begin_t, end_t, options));
      });
      
      $def(self, '$array', function $$array(begin_t, elements, end_t) {
        var self = this;

        return self.$n("array", elements, self.$collection_map(begin_t, elements, end_t))
      });
      
      $def(self, '$splat', function $$splat(star_t, arg) {
        var self = this;

        
        if (arg == null) arg = nil;
        if ($truthy(arg['$nil?']())) {
          return self.$n0("splat", self.$unary_op_map(star_t))
        } else {
          return self.$n("splat", [arg], self.$unary_op_map(star_t, arg))
        };
      }, -2);
      
      $def(self, '$word', function $$word(parts) {
        var self = this;

        if ($truthy(self['$collapse_string_parts?'](parts))) {
          return parts.$first()
        } else {
          return self.$n("dstr", [].concat($to_a(parts)), self.$collection_map(nil, parts, nil))
        }
      });
      
      $def(self, '$words_compose', function $$words_compose(begin_t, parts, end_t) {
        var self = this;

        return self.$n("array", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t))
      });
      
      $def(self, '$symbols_compose', function $$symbols_compose(begin_t, parts, end_t) {
        var self = this;

        
        parts = $send(parts, 'map', [], function $$5(part){var $a, value = nil;

          
          if (part == null) part = nil;
          
          switch (part.$type().valueOf()) {
            case "str":
              
              $a = [].concat($to_a(part)), (value = ($a[0] == null ? nil : $a[0])), $a;
              return part.$updated("sym", [value.$to_sym()]);
            case "dstr":
              return part.$updated("dsym")
            default:
              return part
          };});
        return self.$n("array", [].concat($to_a(parts)), self.$collection_map(begin_t, parts, end_t));
      });
      
      $def(self, '$pair', function $$pair(key, assoc_t, value) {
        var self = this;

        return self.$n("pair", [key, value], self.$binary_op_map(key, assoc_t, value))
      });
      
      $def(self, '$pair_list_18', function $$pair_list_18(list) {
        var self = this;

        if ($neqeq(list.$size()['$%'](2), 0)) {
          return self.$diagnostic("error", "odd_hash", nil, list.$last().$loc().$expression())
        } else {
          return $send(list.$each_slice(2), 'map', [], function $$6(key, value){var self = $$6.$$s == null ? this : $$6.$$s;

            
            if (key == null) key = nil;
            if (value == null) value = nil;
            return self.$n("pair", [key, value], self.$binary_op_map(key, nil, value));}, {$$s: self})
        }
      });
      
      $def(self, '$pair_keyword', function $$pair_keyword(key_t, value) {
        var $a, $b, self = this, key_map = nil, pair_map = nil, key = nil;

        
        $b = self.$pair_keyword_map(key_t, value), $a = $to_ary($b), (key_map = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;
        key = self.$n("sym", [self.$value(key_t).$to_sym()], key_map);
        return self.$n("pair", [key, value], pair_map);
      });
      
      $def(self, '$pair_quoted', function $$pair_quoted(begin_t, parts, end_t, value) {
        var $a, $b, self = this, pair_map = nil, key = nil;

        
        $b = self.$pair_quoted_map(begin_t, end_t, value), $a = $to_ary($b), (end_t = ($a[0] == null ? nil : $a[0])), (pair_map = ($a[1] == null ? nil : $a[1])), $b;
        key = self.$symbol_compose(begin_t, parts, end_t);
        return self.$n("pair", [key, value], pair_map);
      });
      
      $def(self, '$pair_label', function $$pair_label(key_t) {
        var self = this, key_l = nil, value_l = nil, label = nil, value = nil;

        
        key_l = self.$loc(key_t);
        value_l = key_l.$adjust((new Map([["end_pos", -1]])));
        label = self.$value(key_t);
        value = ($truthy(label['$=~'](/^[[:lower:]]/)) ? (self.$n("ident", [label.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Variable').$new(value_l))) : (self.$n("const", [nil, label.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Constant').$new(nil, value_l, value_l))));
        return self.$pair_keyword(key_t, self.$accessible(value));
      });
      
      $def(self, '$kwsplat', function $$kwsplat(dstar_t, arg) {
        var self = this;

        return self.$n("kwsplat", [arg], self.$unary_op_map(dstar_t, arg))
      });
      
      $def(self, '$associate', function $$associate(begin_t, pairs, end_t) {
        var self = this, key_set = nil;

        
        key_set = $$('Set').$new();
        $send(pairs, 'each', [], function $$7(pair){var $a, self = $$7.$$s == null ? this : $$7.$$s, key = nil;
          if (self.parser == null) self.parser = nil;

          
          if (pair == null) pair = nil;
          if (!$truthy(pair.$type()['$eql?']("pair"))) {
            return nil
          };
          $a = [].concat($to_a(pair)), (key = ($a[0] == null ? nil : $a[0])), $a;
          
          switch (key.$type().valueOf()) {
            case "sym":
            case "str":
            case "int":
            case "float":
              
              break;
            case "rational":
            case "complex":
            case "regexp":
              if (!$truthy($rb_ge(self.parser.$version(), 31))) {
                return nil
              }
              break;
            default:
              return nil
          };
          if ($truthy(key_set['$add?'](key))) {
            return nil
          } else {
            return self.$diagnostic("warning", "duplicate_hash_key", nil, key.$loc().$expression())
          };}, {$$s: self});
        return self.$n("hash", [].concat($to_a(pairs)), self.$collection_map(begin_t, pairs, end_t));
      });
      
      $def(self, '$range_inclusive', function $$range_inclusive(lhs, dot2_t, rhs) {
        var self = this;

        return self.$n("irange", [lhs, rhs], self.$range_map(lhs, dot2_t, rhs))
      });
      
      $def(self, '$range_exclusive', function $$range_exclusive(lhs, dot3_t, rhs) {
        var self = this;

        return self.$n("erange", [lhs, rhs], self.$range_map(lhs, dot3_t, rhs))
      });
      
      $def(self, '$self', function $$self(token) {
        var self = this;

        return self.$n0("self", self.$token_map(token))
      });
      
      $def(self, '$ident', function $$ident(token) {
        var self = this;

        return self.$n("ident", [self.$value(token).$to_sym()], self.$variable_map(token))
      });
      
      $def(self, '$ivar', function $$ivar(token) {
        var self = this;

        return self.$n("ivar", [self.$value(token).$to_sym()], self.$variable_map(token))
      });
      
      $def(self, '$gvar', function $$gvar(token) {
        var self = this;

        return self.$n("gvar", [self.$value(token).$to_sym()], self.$variable_map(token))
      });
      
      $def(self, '$cvar', function $$cvar(token) {
        var self = this;

        return self.$n("cvar", [self.$value(token).$to_sym()], self.$variable_map(token))
      });
      
      $def(self, '$back_ref', function $$back_ref(token) {
        var self = this;

        return self.$n("back_ref", [self.$value(token).$to_sym()], self.$token_map(token))
      });
      
      $def(self, '$nth_ref', function $$nth_ref(token) {
        var self = this;

        return self.$n("nth_ref", [self.$value(token)], self.$token_map(token))
      });
      
      $def(self, '$accessible', function $$accessible(node) {
        var $a, self = this, name = nil;

        
        switch (node.$type().valueOf()) {
          case "__FILE__":
            if ($truthy(self.emit_file_line_as_literals)) {
              return self.$n("str", [node.$loc().$expression().$source_buffer().$name()], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "__LINE__":
            if ($truthy(self.emit_file_line_as_literals)) {
              return self.$n("int", [node.$loc().$expression().$line()], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "__ENCODING__":
            if ($not(self.$class().$emit_encoding())) {
              return self.$n("const", [self.$n("const", [nil, "Encoding"], nil), "UTF_8"], node.$loc().$dup())
            } else {
              return node
            }
            break;
          case "ident":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            if ($truthy($send(["?", "!"], 'any?', [], function $$8(c){
              
              if (c == null) c = nil;
              return name.$to_s()['$end_with?'](c);}))) {
              self.$diagnostic("error", "invalid_id_to_get", (new Map([["identifier", name.$to_s()]])), node.$loc().$expression())
            };
            if (($truthy($rb_ge(self.parser.$version(), 27)) && ($truthy(self.parser.$try_declare_numparam(node))))) {
              return node.$updated("lvar")
            };
            if (!$truthy(self.parser.$static_env()['$declared?'](name))) {
              return self.$n("send", [nil, name], self.$var_send_map(node))
            };
            if ($eqeq(name.$to_s(), self.$parser().$current_arg_stack().$top())) {
              self.$diagnostic("error", "circular_argument_reference", (new Map([["var_name", name.$to_s()]])), node.$loc().$expression())
            };
            return node.$updated("lvar");
          default:
            return node
        }
      });
      
      $def(self, '$const', function $Default_const$9(name_t) {
        var self = this;

        return self.$n("const", [nil, self.$value(name_t).$to_sym()], self.$constant_map(nil, nil, name_t))
      });
      
      $def(self, '$const_global', function $$const_global(t_colon3, name_t) {
        var self = this, cbase = nil;

        
        cbase = self.$n0("cbase", self.$token_map(t_colon3));
        return self.$n("const", [cbase, self.$value(name_t).$to_sym()], self.$constant_map(cbase, t_colon3, name_t));
      });
      
      $def(self, '$const_fetch', function $$const_fetch(scope, t_colon2, name_t) {
        var self = this;

        return self.$n("const", [scope, self.$value(name_t).$to_sym()], self.$constant_map(scope, t_colon2, name_t))
      });
      
      $def(self, '$__ENCODING__', function $$__ENCODING__(__ENCODING__t) {
        var self = this;

        return self.$n0("__ENCODING__", self.$token_map(__ENCODING__t))
      });
      
      $def(self, '$assignable', function $$assignable(node) {
        var $a, self = this, name = nil, var_name = nil, name_loc = nil;

        
        switch (node.$type().valueOf()) {
          case "cvar":
            return node.$updated("cvasgn")
          case "ivar":
            return node.$updated("ivasgn")
          case "gvar":
            return node.$updated("gvasgn")
          case "const":
            
            if ($truthy(self.parser.$context().$in_def())) {
              self.$diagnostic("error", "dynamic_const", nil, node.$loc().$expression())
            };
            return node.$updated("casgn");
          case "ident":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            var_name = node.$children()['$[]'](0).$to_s();
            name_loc = node.$loc().$expression();
            self.$check_assignment_to_numparam(var_name, name_loc);
            self.$check_reserved_for_numparam(var_name, name_loc);
            self.parser.$static_env().$declare(name);
            return node.$updated("lvasgn");
          case "match_var":
            
            $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), $a;
            var_name = node.$children()['$[]'](0).$to_s();
            name_loc = node.$loc().$expression();
            self.$check_assignment_to_numparam(var_name, name_loc);
            self.$check_reserved_for_numparam(var_name, name_loc);
            return node;
          case "nil":
          case "self":
          case "true":
          case "false":
          case "__FILE__":
          case "__LINE__":
          case "__ENCODING__":
            return self.$diagnostic("error", "invalid_assignment", nil, node.$loc().$expression())
          case "back_ref":
          case "nth_ref":
            return self.$diagnostic("error", "backref_assignment", nil, node.$loc().$expression())
          default:
            return nil
        }
      });
      
      $def(self, '$const_op_assignable', function $$const_op_assignable(node) {
        
        return node.$updated("casgn")
      });
      
      $def(self, '$assign', function $$assign(lhs, eql_t, rhs) {
        var self = this;

        return lhs['$<<'](rhs).$updated(nil, nil, (new Map([["location", lhs.$loc().$with_operator(self.$loc(eql_t)).$with_expression(self.$join_exprs(lhs, rhs))]])))
      });
      
      $def(self, '$op_assign', function $$op_assign(lhs, op_t, rhs) {
        var self = this, operator = nil, source_map = nil;

        
        switch (lhs.$type().valueOf()) {
          case "gvasgn":
          case "ivasgn":
          case "lvasgn":
          case "cvasgn":
          case "casgn":
          case "send":
          case "csend":
          case "index":
            
            operator = self.$value(op_t)['$[]']($range(0, -1, false)).$to_sym();
            source_map = lhs.$loc().$with_operator(self.$loc(op_t)).$with_expression(self.$join_exprs(lhs, rhs));
            if ($eqeq(lhs.$type(), "index")) {
              lhs = lhs.$updated("indexasgn")
            };
            
            switch (operator.valueOf()) {
              case "&&":
                return self.$n("and_asgn", [lhs, rhs], source_map)
              case "||":
                return self.$n("or_asgn", [lhs, rhs], source_map)
              default:
                return self.$n("op_asgn", [lhs, operator, rhs], source_map)
            };
            break;
          case "back_ref":
          case "nth_ref":
            return self.$diagnostic("error", "backref_assignment", nil, lhs.$loc().$expression())
          default:
            return nil
        }
      });
      
      $def(self, '$multi_lhs', function $$multi_lhs(begin_t, items, end_t) {
        var self = this;

        return self.$n("mlhs", [].concat($to_a(items)), self.$collection_map(begin_t, items, end_t))
      });
      
      $def(self, '$multi_assign', function $$multi_assign(lhs, eql_t, rhs) {
        var self = this;

        return self.$n("masgn", [lhs, rhs], self.$binary_op_map(lhs, eql_t, rhs))
      });
      
      $def(self, '$def_class', function $$def_class(class_t, name, lt_t, superclass, body, end_t) {
        var self = this;

        return self.$n("class", [name, superclass, body], self.$module_definition_map(class_t, name, lt_t, end_t))
      });
      
      $def(self, '$def_sclass', function $$def_sclass(class_t, lshft_t, expr, body, end_t) {
        var self = this;

        return self.$n("sclass", [expr, body], self.$module_definition_map(class_t, nil, lshft_t, end_t))
      });
      
      $def(self, '$def_module', function $$def_module(module_t, name, body, end_t) {
        var self = this;

        return self.$n("module", [name, body], self.$module_definition_map(module_t, name, nil, end_t))
      });
      
      $def(self, '$def_method', function $$def_method(def_t, name_t, args, body, end_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("def", [self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, nil, name_t, end_t));
      });
      
      $def(self, '$def_endless_method', function $$def_endless_method(def_t, name_t, args, assignment_t, body) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("def", [self.$value(name_t).$to_sym(), args, body], self.$endless_definition_map(def_t, nil, name_t, assignment_t, body));
      });
      
      $def(self, '$def_singleton', function $$def_singleton(def_t, definee, dot_t, name_t, args, body, end_t) {
        var self = this;

        
        self.$validate_definee(definee);
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("defs", [definee, self.$value(name_t).$to_sym(), args, body], self.$definition_map(def_t, dot_t, name_t, end_t));
      });
      
      $def(self, '$def_endless_singleton', function $$def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body) {
        var self = this;

        
        self.$validate_definee(definee);
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("defs", [definee, self.$value(name_t).$to_sym(), args, body], self.$endless_definition_map(def_t, dot_t, name_t, assignment_t, body));
      });
      
      $def(self, '$undef_method', function $$undef_method(undef_t, names) {
        var self = this;

        return self.$n("undef", [].concat($to_a(names)), self.$keyword_map(undef_t, nil, names, nil))
      });
      
      $def(self, '$alias', function $$alias(alias_t, to, from) {
        var self = this;

        return self.$n("alias", [to, from], self.$keyword_map(alias_t, nil, [to, from], nil))
      });
      
      $def(self, '$args', function $$args(begin_t, args, end_t, check_args) {
        var self = this, map = nil;

        
        if (check_args == null) check_args = true;
        if ($truthy(check_args)) {
          args = self.$check_duplicate_args(args)
        };
        self.$validate_no_forward_arg_after_restarg(args);
        map = self.$collection_map(begin_t, args, end_t);
        if ((($not(self.$class().$emit_forward_arg()) && ($eqeq(args.$length(), 1))) && ($eqeq(args['$[]'](0).$type(), "forward_arg")))) {
          return self.$n("forward_args", [], map)
        } else {
          return self.$n("args", args, map)
        };
      }, -4);
      
      $def(self, '$numargs', function $$numargs(max_numparam) {
        var self = this;

        return self.$n("numargs", [max_numparam], nil)
      });
      
      $def(self, '$forward_only_args', function $$forward_only_args(begin_t, dots_t, end_t) {
        var self = this, arg = nil;

        if ($truthy(self.$class().$emit_forward_arg())) {
          
          arg = self.$forward_arg(dots_t);
          return self.$n("args", [arg], self.$collection_map(begin_t, [arg], end_t));
        } else {
          return self.$n("forward_args", [], self.$collection_map(begin_t, self.$token_map(dots_t), end_t))
        }
      });
      
      $def(self, '$forward_arg', function $$forward_arg(dots_t) {
        var self = this;

        return self.$n("forward_arg", [], self.$token_map(dots_t))
      });
      
      $def(self, '$arg', function $$arg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("arg", [self.$value(name_t).$to_sym()], self.$variable_map(name_t));
      });
      
      $def(self, '$optarg', function $$optarg(name_t, eql_t, value) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("optarg", [self.$value(name_t).$to_sym(), value], self.$variable_map(name_t).$with_operator(self.$loc(eql_t)).$with_expression(self.$loc(name_t).$join(value.$loc().$expression())));
      });
      
      $def(self, '$restarg', function $$restarg(star_t, name_t) {
        var self = this;

        
        if (name_t == null) name_t = nil;
        if ($truthy(name_t)) {
          
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
          return self.$n("restarg", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(star_t, name_t));
        } else {
          return self.$n0("restarg", self.$arg_prefix_map(star_t))
        };
      }, -2);
      
      $def(self, '$kwarg', function $$kwarg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("kwarg", [self.$value(name_t).$to_sym()], self.$kwarg_map(name_t));
      });
      
      $def(self, '$kwoptarg', function $$kwoptarg(name_t, value) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("kwoptarg", [self.$value(name_t).$to_sym(), value], self.$kwarg_map(name_t, value));
      });
      
      $def(self, '$kwrestarg', function $$kwrestarg(dstar_t, name_t) {
        var self = this;

        
        if (name_t == null) name_t = nil;
        if ($truthy(name_t)) {
          
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
          return self.$n("kwrestarg", [self.$value(name_t).$to_sym()], self.$arg_prefix_map(dstar_t, name_t));
        } else {
          return self.$n0("kwrestarg", self.$arg_prefix_map(dstar_t))
        };
      }, -2);
      
      $def(self, '$kwnilarg', function $$kwnilarg(dstar_t, nil_t) {
        var self = this;

        return self.$n0("kwnilarg", self.$arg_prefix_map(dstar_t, nil_t))
      });
      
      $def(self, '$shadowarg', function $$shadowarg(name_t) {
        var self = this;

        
        self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t));
        return self.$n("shadowarg", [self.$value(name_t).$to_sym()], self.$variable_map(name_t));
      });
      
      $def(self, '$blockarg', function $$blockarg(amper_t, name_t) {
        var self = this, arg_name = nil;

        
        if ($not(name_t['$nil?']())) {
          self.$check_reserved_for_numparam(self.$value(name_t), self.$loc(name_t))
        };
        arg_name = ($truthy(name_t) ? (self.$value(name_t).$to_sym()) : (nil));
        return self.$n("blockarg", [arg_name], self.$arg_prefix_map(amper_t, name_t));
      });
      
      $def(self, '$procarg0', function $$procarg0(arg) {
        var self = this;

        if ($truthy(self.$class().$emit_procarg0())) {
          if (($eqeq(arg.$type(), "arg") && ($truthy(self.$class().$emit_arg_inside_procarg0())))) {
            return self.$n("procarg0", [arg], $$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, arg.$location().$expression()))
          } else {
            return arg.$updated("procarg0")
          }
        } else {
          return arg
        }
      });
      
      $def(self, '$arg_expr', function $$arg_expr(expr) {
        var self = this;

        if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("arg")
        } else {
          return self.$n("arg_expr", [expr], expr.$loc().$dup())
        }
      });
      
      $def(self, '$restarg_expr', function $$restarg_expr(star_t, expr) {
        var self = this;

        
        if (expr == null) expr = nil;
        if ($truthy(expr['$nil?']())) {
          return self.$n0("restarg", self.$token_map(star_t))
        } else if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("restarg")
        } else {
          return self.$n("restarg_expr", [expr], expr.$loc().$dup())
        };
      }, -2);
      
      $def(self, '$blockarg_expr', function $$blockarg_expr(amper_t, expr) {
        var self = this;

        if ($eqeq(expr.$type(), "lvasgn")) {
          return expr.$updated("blockarg")
        } else {
          return self.$n("blockarg_expr", [expr], expr.$loc().$dup())
        }
      });
      
      $def(self, '$objc_kwarg', function $$objc_kwarg(kwname_t, assoc_t, name_t) {
        var self = this, kwname_l = nil, operator_l = nil;

        
        kwname_l = self.$loc(kwname_t);
        if ($truthy(assoc_t['$nil?']())) {
          
          kwname_l = kwname_l.$resize($rb_minus(kwname_l.$size(), 1));
          operator_l = kwname_l.$end().$resize(1);
        } else {
          operator_l = self.$loc(assoc_t)
        };
        return self.$n("objc_kwarg", [self.$value(kwname_t).$to_sym(), self.$value(name_t).$to_sym()], $$$($$$($$('Source'), 'Map'), 'ObjcKwarg').$new(kwname_l, operator_l, self.$loc(name_t), kwname_l.$join(self.$loc(name_t))));
      });
      
      $def(self, '$objc_restarg', function $$objc_restarg(star_t, name) {
        var self = this;

        
        if (name == null) name = nil;
        if ($truthy(name['$nil?']())) {
          return self.$n0("restarg", self.$arg_prefix_map(star_t))
        } else if ($eqeq(name.$type(), "arg")) {
          return name.$updated("restarg", nil, (new Map([["location", name.$loc().$with_operator(self.$loc(star_t))]])))
        } else {
          return self.$n("objc_restarg", [name], self.$unary_op_map(star_t, name))
        };
      }, -2);
      
      $def(self, '$call_type_for_dot', function $$call_type_for_dot(dot_t) {
        var self = this;

        if (($not(dot_t['$nil?']()) && ($eqeq(self.$value(dot_t), "anddot")))) {
          return "csend"
        } else {
          return "send"
        }
      });
      
      $def(self, '$forwarded_args', function $$forwarded_args(dots_t) {
        var self = this;

        return self.$n("forwarded_args", [], self.$token_map(dots_t))
      });
      
      $def(self, '$forwarded_restarg', function $$forwarded_restarg(star_t) {
        var self = this;

        return self.$n("forwarded_restarg", [], self.$token_map(star_t))
      });
      
      $def(self, '$forwarded_kwrestarg', function $$forwarded_kwrestarg(dstar_t) {
        var self = this;

        return self.$n("forwarded_kwrestarg", [], self.$token_map(dstar_t))
      });
      
      $def(self, '$call_method', function $$call_method(receiver, dot_t, selector_t, lparen_t, args, rparen_t) {
        var self = this, type = nil;

        
        if (lparen_t == null) lparen_t = nil;
        if (args == null) args = [];
        if (rparen_t == null) rparen_t = nil;
        type = self.$call_type_for_dot(dot_t);
        if ($truthy(self.$class().$emit_kwargs())) {
          self.$rewrite_hash_args_to_kwargs(args)
        };
        if ($truthy(selector_t['$nil?']())) {
          return self.$n(type, [receiver, "call"].concat($to_a(args)), self.$send_map(receiver, dot_t, nil, lparen_t, args, rparen_t))
        } else {
          return self.$n(type, [receiver, self.$value(selector_t).$to_sym()].concat($to_a(args)), self.$send_map(receiver, dot_t, selector_t, lparen_t, args, rparen_t))
        };
      }, -4);
      
      $def(self, '$call_lambda', function $$call_lambda(lambda_t) {
        var self = this;

        if ($truthy(self.$class().$emit_lambda())) {
          return self.$n0("lambda", self.$expr_map(self.$loc(lambda_t)))
        } else {
          return self.$n("send", [nil, "lambda"], self.$send_map(nil, nil, lambda_t))
        }
      });
      
      $def(self, '$block', function $$block(method_call, begin_t, args, body, end_t) {
        var $a, self = this, _receiver = nil, _selector = nil, call_args = nil, last_arg = nil, block_type = nil, actual_send = nil, block = nil;

        
        $a = [].concat($to_a(method_call)), (_receiver = ($a[0] == null ? nil : $a[0])), (_selector = ($a[1] == null ? nil : $a[1])), (call_args = $slice($a, 2)), $a;
        if ($eqeq(method_call.$type(), "yield")) {
          self.$diagnostic("error", "block_given_to_yield", nil, method_call.$loc().$keyword(), [self.$loc(begin_t)])
        };
        last_arg = call_args.$last();
        if (($truthy(last_arg) && (($eqeq(last_arg.$type(), "block_pass") || ($eqeq(last_arg.$type(), "forwarded_args")))))) {
          self.$diagnostic("error", "block_and_blockarg", nil, last_arg.$loc().$expression(), [self.$loc(begin_t)])
        };
        if ($eqeq(args.$type(), "numargs")) {
          
          block_type = "numblock";
          args = args.$children()['$[]'](0);
        } else {
          block_type = "block"
        };
        if ($truthy(["send", "csend", "index", "super", "zsuper", "lambda"]['$include?'](method_call.$type()))) {
          return self.$n(block_type, [method_call, args, body], self.$block_map(method_call.$loc().$expression(), begin_t, end_t))
        } else {
          
          $a = [].concat($to_a(method_call)), (actual_send = ($a[0] == null ? nil : $a[0])), $a;
          block = self.$n(block_type, [actual_send, args, body], self.$block_map(actual_send.$loc().$expression(), begin_t, end_t));
          return self.$n(method_call.$type(), [block], method_call.$loc().$with_expression(self.$join_exprs(method_call, block)));
        };
      });
      
      $def(self, '$block_pass', function $$block_pass(amper_t, arg) {
        var self = this;

        return self.$n("block_pass", [arg], self.$unary_op_map(amper_t, arg))
      });
      
      $def(self, '$objc_varargs', function $$objc_varargs(pair, rest_of_varargs) {
        var $a, self = this, value = nil, first_vararg = nil, vararg_array = nil;

        
        $a = [].concat($to_a(pair)), (value = ($a[0] == null ? nil : $a[0])), (first_vararg = ($a[1] == null ? nil : $a[1])), $a;
        vararg_array = self.$array(nil, [first_vararg].concat($to_a(rest_of_varargs)), nil).$updated("objc_varargs");
        return pair.$updated(nil, [value, vararg_array], (new Map([["location", pair.$loc().$with_expression(pair.$loc().$expression().$join(vararg_array.$loc().$expression()))]])));
      });
      
      $def(self, '$attr_asgn', function $$attr_asgn(receiver, dot_t, selector_t) {
        var self = this, method_name = nil, type = nil;

        
        method_name = $rb_plus(self.$value(selector_t), "=").$to_sym();
        type = self.$call_type_for_dot(dot_t);
        return self.$n(type, [receiver, method_name], self.$send_map(receiver, dot_t, selector_t));
      });
      
      $def(self, '$index', function $$index(receiver, lbrack_t, indexes, rbrack_t) {
        var self = this;

        
        if ($truthy(self.$class().$emit_kwargs())) {
          self.$rewrite_hash_args_to_kwargs(indexes)
        };
        if ($truthy(self.$class().$emit_index())) {
          return self.$n("index", [receiver].concat($to_a(indexes)), self.$index_map(receiver, lbrack_t, rbrack_t))
        } else {
          return self.$n("send", [receiver, "[]"].concat($to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))
        };
      });
      
      $def(self, '$index_asgn', function $$index_asgn(receiver, lbrack_t, indexes, rbrack_t) {
        var self = this;

        if ($truthy(self.$class().$emit_index())) {
          return self.$n("indexasgn", [receiver].concat($to_a(indexes)), self.$index_map(receiver, lbrack_t, rbrack_t))
        } else {
          return self.$n("send", [receiver, "[]="].concat($to_a(indexes)), self.$send_index_map(receiver, lbrack_t, rbrack_t))
        }
      });
      
      $def(self, '$binary_op', function $$binary_op(receiver, operator_t, arg) {
        var self = this, source_map = nil, operator = nil, method_call = nil;

        
        source_map = self.$send_binary_op_map(receiver, operator_t, arg);
        if ($eqeq(self.parser.$version(), 18)) {
          
          operator = self.$value(operator_t);
          if ($eqeq(operator, "!=")) {
            method_call = self.$n("send", [receiver, "==", arg], source_map)
          } else if ($eqeq(operator, "!~")) {
            method_call = self.$n("send", [receiver, "=~", arg], source_map)
          };
          if ($truthy(["!=", "!~"]['$include?'](operator))) {
            return self.$n("not", [method_call], self.$expr_map(source_map.$expression()))
          };
        };
        return self.$n("send", [receiver, self.$value(operator_t).$to_sym(), arg], source_map);
      });
      
      $def(self, '$match_op', function $$match_op(receiver, match_t, arg) {
        var self = this, source_map = nil, regexp = nil;

        
        source_map = self.$send_binary_op_map(receiver, match_t, arg);
        if ($truthy((regexp = self.$static_regexp_node(receiver)))) {
          
          $send(regexp.$names(), 'each', [], function $$10(name){var self = $$10.$$s == null ? this : $$10.$$s;
            if (self.parser == null) self.parser = nil;

            
            if (name == null) name = nil;
            return self.parser.$static_env().$declare(name);}, {$$s: self});
          return self.$n("match_with_lvasgn", [receiver, arg], source_map);
        } else {
          return self.$n("send", [receiver, "=~", arg], source_map)
        };
      });
      
      $def(self, '$unary_op', function $$unary_op(op_t, receiver) {
        var self = this, method = nil;

        
        
        switch (self.$value(op_t).valueOf()) {
          case "+":
          case "-":
            method = $rb_plus(self.$value(op_t), "@")
            break;
          default:
            method = self.$value(op_t)
        };
        return self.$n("send", [receiver, method.$to_sym()], self.$send_unary_op_map(op_t, receiver));
      });
      
      $def(self, '$not_op', function $$not_op(not_t, begin_t, receiver, end_t) {
        var self = this, nil_node = nil;

        
        if (begin_t == null) begin_t = nil;
        if (receiver == null) receiver = nil;
        if (end_t == null) end_t = nil;
        if ($eqeq(self.parser.$version(), 18)) {
          return self.$n("not", [self.$check_condition(receiver)], self.$unary_op_map(not_t, receiver))
        } else if ($truthy(receiver['$nil?']())) {
          
          nil_node = self.$n0("begin", self.$collection_map(begin_t, nil, end_t));
          return self.$n("send", [nil_node, "!"], self.$send_unary_op_map(not_t, nil_node));
        } else {
          return self.$n("send", [self.$check_condition(receiver), "!"], self.$send_map(nil, nil, not_t, begin_t, [receiver], end_t))
        };
      }, -2);
      
      $def(self, '$logical_op', function $$logical_op(type, lhs, op_t, rhs) {
        var self = this;

        return self.$n(type, [lhs, rhs], self.$binary_op_map(lhs, op_t, rhs))
      });
      
      $def(self, '$condition', function $$condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t) {
        var self = this;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$condition_map(cond_t, cond, then_t, if_true, else_t, if_false, end_t))
      });
      
      $def(self, '$condition_mod', function $$condition_mod(if_true, if_false, cond_t, cond) {
        var self = this, $ret_or_1 = nil;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$keyword_mod_map(($truthy(($ret_or_1 = if_true)) ? ($ret_or_1) : (if_false)), cond_t, cond))
      });
      
      $def(self, '$ternary', function $$ternary(cond, question_t, if_true, colon_t, if_false) {
        var self = this;

        return self.$n("if", [self.$check_condition(cond), if_true, if_false], self.$ternary_map(cond, question_t, if_true, colon_t, if_false))
      });
      
      $def(self, '$when', function $$when(when_t, patterns, then_t, body) {
        var self = this, children = nil;

        
        children = patterns['$<<'](body);
        return self.$n("when", children, self.$keyword_map(when_t, then_t, children, nil));
      });
      
      $def(self, '$case', function $Default_case$11(case_t, expr, when_bodies, else_t, else_body, end_t) {
        var self = this;

        return self.$n("case", [expr].concat($to_a(when_bodies['$<<'](else_body))), self.$condition_map(case_t, expr, nil, nil, else_t, else_body, end_t))
      });
      
      $def(self, '$loop', function $$loop(type, keyword_t, cond, do_t, body, end_t) {
        var self = this;

        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_map(keyword_t, do_t, nil, end_t))
      });
      
      $def(self, '$loop_mod', function $$loop_mod(type, body, keyword_t, cond) {
        var self = this;

        
        if ($eqeq(body.$type(), "kwbegin")) {
          type = "" + (type) + "_post"
        };
        return self.$n(type, [self.$check_condition(cond), body], self.$keyword_mod_map(body, keyword_t, cond));
      });
      
      $def(self, '$for', function $Default_for$12(for_t, iterator, in_t, iteratee, do_t, body, end_t) {
        var self = this;

        return self.$n("for", [iterator, iteratee, body], self.$for_map(for_t, in_t, do_t, end_t))
      });
      
      $def(self, '$keyword_cmd', function $$keyword_cmd(type, keyword_t, lparen_t, args, rparen_t) {
        var self = this, last_arg = nil;

        
        if (lparen_t == null) lparen_t = nil;
        if (args == null) args = [];
        if (rparen_t == null) rparen_t = nil;
        if (($eqeq(type, "yield") && ($truthy($rb_gt(args.$count(), 0))))) {
          
          last_arg = args.$last();
          if ($eqeq(last_arg.$type(), "block_pass")) {
            self.$diagnostic("error", "block_given_to_yield", nil, self.$loc(keyword_t), [last_arg.$loc().$expression()])
          };
        };
        if (($truthy(["yield", "super"]['$include?'](type)) && ($truthy(self.$class().$emit_kwargs())))) {
          self.$rewrite_hash_args_to_kwargs(args)
        };
        return self.$n(type, args, self.$keyword_map(keyword_t, lparen_t, args, rparen_t));
      }, -3);
      
      $def(self, '$preexe', function $$preexe(preexe_t, lbrace_t, compstmt, rbrace_t) {
        var self = this;

        return self.$n("preexe", [compstmt], self.$keyword_map(preexe_t, lbrace_t, [], rbrace_t))
      });
      
      $def(self, '$postexe', function $$postexe(postexe_t, lbrace_t, compstmt, rbrace_t) {
        var self = this;

        return self.$n("postexe", [compstmt], self.$keyword_map(postexe_t, lbrace_t, [], rbrace_t))
      });
      
      $def(self, '$rescue_body', function $$rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt) {
        var self = this;

        return self.$n("resbody", [exc_list, exc_var, compound_stmt], self.$rescue_body_map(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt))
      });
      
      $def(self, '$begin_body', function $$begin_body(compound_stmt, rescue_bodies, else_t, else_, ensure_t, ensure_) {
        var self = this, statements = nil;

        
        if (rescue_bodies == null) rescue_bodies = [];
        if (else_t == null) else_t = nil;
        if (else_ == null) else_ = nil;
        if (ensure_t == null) ensure_t = nil;
        if (ensure_ == null) ensure_ = nil;
        if ($truthy(rescue_bodies['$any?']())) {
          if ($truthy(else_t)) {
            compound_stmt = self.$n("rescue", [compound_stmt].concat($to_a($rb_plus(rescue_bodies, [else_]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, else_t, else_))
          } else {
            compound_stmt = self.$n("rescue", [compound_stmt].concat($to_a($rb_plus(rescue_bodies, [nil]))), self.$eh_keyword_map(compound_stmt, nil, rescue_bodies, nil, nil))
          }
        } else if ($truthy(else_t)) {
          
          statements = [];
          if ($not(compound_stmt['$nil?']())) {
            if ($eqeq(compound_stmt.$type(), "begin")) {
              statements = $rb_plus(statements, compound_stmt.$children())
            } else {
              statements.$push(compound_stmt)
            }
          };
          statements.$push(self.$n("begin", [else_], self.$collection_map(else_t, [else_], nil)));
          compound_stmt = self.$n("begin", statements, self.$collection_map(nil, statements, nil));
        };
        if ($truthy(ensure_t)) {
          compound_stmt = self.$n("ensure", [compound_stmt, ensure_], self.$eh_keyword_map(compound_stmt, ensure_t, [ensure_], nil, nil))
        };
        return compound_stmt;
      }, -2);
      
      $def(self, '$compstmt', function $$compstmt(statements) {
        var self = this;

        if ($truthy(statements['$none?']())) {
          return nil
        } else if ($truthy(statements['$one?']())) {
          return statements.$first()
        } else {
          return self.$n("begin", statements, self.$collection_map(nil, statements, nil))
        }
      });
      
      $def(self, '$begin', function $$begin(begin_t, body, end_t) {
        var self = this;

        if ($truthy(body['$nil?']())) {
          return self.$n0("begin", self.$collection_map(begin_t, nil, end_t))
        } else if (($eqeq(body.$type(), "mlhs") || ((($eqeq(body.$type(), "begin") && ($truthy(body.$loc().$begin()['$nil?']()))) && ($truthy(body.$loc().$end()['$nil?']())))))) {
          return self.$n(body.$type(), body.$children(), self.$collection_map(begin_t, body.$children(), end_t))
        } else {
          return self.$n("begin", [body], self.$collection_map(begin_t, [body], end_t))
        }
      });
      
      $def(self, '$begin_keyword', function $$begin_keyword(begin_t, body, end_t) {
        var self = this;

        if ($truthy(body['$nil?']())) {
          return self.$n0("kwbegin", self.$collection_map(begin_t, nil, end_t))
        } else if ((($eqeq(body.$type(), "begin") && ($truthy(body.$loc().$begin()['$nil?']()))) && ($truthy(body.$loc().$end()['$nil?']())))) {
          return self.$n("kwbegin", body.$children(), self.$collection_map(begin_t, body.$children(), end_t))
        } else {
          return self.$n("kwbegin", [body], self.$collection_map(begin_t, [body], end_t))
        }
      });
      
      $def(self, '$case_match', function $$case_match(case_t, expr, in_bodies, else_t, else_body, end_t) {
        var self = this;

        
        if (($truthy(else_t) && ($not(else_body)))) {
          else_body = self.$n("empty_else", nil, self.$token_map(else_t))
        };
        return self.$n("case_match", [expr].concat($to_a(in_bodies['$<<'](else_body))), self.$condition_map(case_t, expr, nil, nil, else_t, else_body, end_t));
      });
      
      $def(self, '$in_match', function $$in_match(lhs, in_t, rhs) {
        var self = this;

        return self.$n("in_match", [lhs, rhs], self.$binary_op_map(lhs, in_t, rhs))
      });
      
      $def(self, '$match_pattern', function $$match_pattern(lhs, match_t, rhs) {
        var self = this;

        return self.$n("match_pattern", [lhs, rhs], self.$binary_op_map(lhs, match_t, rhs))
      });
      
      $def(self, '$match_pattern_p', function $$match_pattern_p(lhs, match_t, rhs) {
        var self = this;

        return self.$n("match_pattern_p", [lhs, rhs], self.$binary_op_map(lhs, match_t, rhs))
      });
      
      $def(self, '$in_pattern', function $$in_pattern(in_t, pattern, guard, then_t, body) {
        var self = this, children = nil;

        
        children = [pattern, guard, body];
        return self.$n("in_pattern", children, self.$keyword_map(in_t, then_t, children.$compact(), nil));
      });
      
      $def(self, '$if_guard', function $$if_guard(if_t, if_body) {
        var self = this;

        return self.$n("if_guard", [if_body], self.$guard_map(if_t, if_body))
      });
      
      $def(self, '$unless_guard', function $$unless_guard(unless_t, unless_body) {
        var self = this;

        return self.$n("unless_guard", [unless_body], self.$guard_map(unless_t, unless_body))
      });
      
      $def(self, '$match_var', function $$match_var(name_t) {
        var self = this, name = nil, name_l = nil;

        
        name = self.$value(name_t).$to_sym();
        name_l = self.$loc(name_t);
        self.$check_lvar_name(name, name_l);
        self.$check_duplicate_pattern_variable(name, name_l);
        self.parser.$static_env().$declare(name);
        return self.$n("match_var", [name], self.$variable_map(name_t));
      });
      
      $def(self, '$match_hash_var', function $$match_hash_var(name_t) {
        var self = this, name = nil, expr_l = nil, name_l = nil;

        
        name = self.$value(name_t).$to_sym();
        expr_l = self.$loc(name_t);
        name_l = expr_l.$adjust((new Map([["end_pos", -1]])));
        self.$check_lvar_name(name, name_l);
        self.$check_duplicate_pattern_variable(name, name_l);
        self.parser.$static_env().$declare(name);
        return self.$n("match_var", [name], $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_l, expr_l));
      });
      
      $def(self, '$match_hash_var_from_str', function $$match_hash_var_from_str(begin_t, strings, end_t) {
        var $a, self = this, string = nil, name = nil, name_l = nil, begin_l = nil, end_l = nil, expr_l = nil;

        
        if ($truthy($rb_gt(strings.$length(), 1))) {
          self.$diagnostic("error", "pm_interp_in_var_name", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        };
        string = strings['$[]'](0);
        
        switch (string.$type().valueOf()) {
          case "str":
            
            $a = [].concat($to_a(string)), (name = ($a[0] == null ? nil : $a[0])), $a;
            name_l = string.$loc().$expression();
            self.$check_lvar_name(name, name_l);
            self.$check_duplicate_pattern_variable(name, name_l);
            self.parser.$static_env().$declare(name);
            if ($truthy((begin_l = string.$loc().$begin()))) {
              name_l = name_l.$adjust((new Map([["begin_pos", begin_l.$length()]])))
            };
            if ($truthy((end_l = string.$loc().$end()))) {
              name_l = name_l.$adjust((new Map([["end_pos", end_l.$length()['$-@']()]])))
            };
            expr_l = self.$loc(begin_t).$join(string.$loc().$expression()).$join(self.$loc(end_t));
            return self.$n("match_var", [name.$to_sym()], $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_l, expr_l));
          case "begin":
            return self.$match_hash_var_from_str(begin_t, string.$children(), end_t)
          default:
            return self.$diagnostic("error", "pm_interp_in_var_name", nil, self.$loc(begin_t).$join(self.$loc(end_t)))
        };
      });
      
      $def(self, '$match_rest', function $$match_rest(star_t, name_t) {
        var self = this, name = nil;

        
        if (name_t == null) name_t = nil;
        if ($truthy(name_t['$nil?']())) {
          return self.$n0("match_rest", self.$unary_op_map(star_t))
        } else {
          
          name = self.$match_var(name_t);
          return self.$n("match_rest", [name], self.$unary_op_map(star_t, name));
        };
      }, -2);
      
      $def(self, '$hash_pattern', function $$hash_pattern(lbrace_t, kwargs, rbrace_t) {
        var self = this, args = nil;

        
        args = self.$check_duplicate_args(kwargs);
        return self.$n("hash_pattern", args, self.$collection_map(lbrace_t, args, rbrace_t));
      });
      
      $def(self, '$array_pattern', function $$array_pattern(lbrack_t, elements, rbrack_t) {
        var self = this, trailing_comma = nil, node_elements = nil, node_type = nil;

        
        if ($truthy(elements['$nil?']())) {
          return self.$n("array_pattern", nil, self.$collection_map(lbrack_t, [], rbrack_t))
        };
        trailing_comma = false;
        node_elements = $send(elements, 'map', [], function $$13(element){
          
          if (element == null) element = nil;
          if ($eqeq(element.$type(), "match_with_trailing_comma")) {
            
            trailing_comma = true;
            return element.$children().$first();
          } else {
            
            trailing_comma = false;
            return element;
          };});
        node_type = ($truthy(trailing_comma) ? ("array_pattern_with_tail") : ("array_pattern"));
        return self.$n(node_type, node_elements, self.$collection_map(lbrack_t, elements, rbrack_t));
      });
      
      $def(self, '$find_pattern', function $$find_pattern(lbrack_t, elements, rbrack_t) {
        var self = this;

        return self.$n("find_pattern", elements, self.$collection_map(lbrack_t, elements, rbrack_t))
      });
      
      $def(self, '$match_with_trailing_comma', function $$match_with_trailing_comma(match, comma_t) {
        var self = this;

        return self.$n("match_with_trailing_comma", [match], self.$expr_map(match.$loc().$expression().$join(self.$loc(comma_t))))
      });
      
      $def(self, '$const_pattern', function $$const_pattern(const$, ldelim_t, pattern, rdelim_t) {
        var self = this;

        return self.$n("const_pattern", [const$, pattern], $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(ldelim_t), self.$loc(rdelim_t), const$.$loc().$expression().$join(self.$loc(rdelim_t))))
      });
      
      $def(self, '$pin', function $$pin(pin_t, var$) {
        var self = this;

        return self.$n("pin", [var$], self.$send_unary_op_map(pin_t, var$))
      });
      
      $def(self, '$match_alt', function $$match_alt(left, pipe_t, right) {
        var self = this, source_map = nil;

        
        source_map = self.$binary_op_map(left, pipe_t, right);
        return self.$n("match_alt", [left, right], source_map);
      });
      
      $def(self, '$match_as', function $$match_as(value, assoc_t, as) {
        var self = this, source_map = nil;

        
        source_map = self.$binary_op_map(value, assoc_t, as);
        return self.$n("match_as", [value, as], source_map);
      });
      
      $def(self, '$match_nil_pattern', function $$match_nil_pattern(dstar_t, nil_t) {
        var self = this;

        return self.$n0("match_nil_pattern", self.$arg_prefix_map(dstar_t, nil_t))
      });
      
      $def(self, '$match_pair', function $$match_pair(label_type, label, value) {
        var $a, $b, self = this, begin_t = nil, parts = nil, end_t = nil, label_loc = nil, var_name = nil;

        if ($eqeq(label_type, "label")) {
          
          self.$check_duplicate_pattern_key(label['$[]'](0), label['$[]'](1));
          return self.$pair_keyword(label, value);
        } else {
          
          $b = label, $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (parts = ($a[1] == null ? nil : $a[1])), (end_t = ($a[2] == null ? nil : $a[2])), $b;
          label_loc = self.$loc(begin_t).$join(self.$loc(end_t));
          if ($truthy((var_name = self.$static_string(parts)))) {
            self.$check_duplicate_pattern_key(var_name, label_loc)
          } else {
            self.$diagnostic("error", "pm_interp_in_var_name", nil, label_loc)
          };
          return self.$pair_quoted(begin_t, parts, end_t, value);
        }
      });
      
      $def(self, '$match_label', function $$match_label(label_type, label) {
        var $a, $b, self = this, begin_t = nil, strings = nil, end_t = nil;

        if ($eqeq(label_type, "label")) {
          return self.$match_hash_var(label)
        } else {
          
          $b = label, $a = $to_ary($b), (begin_t = ($a[0] == null ? nil : $a[0])), (strings = ($a[1] == null ? nil : $a[1])), (end_t = ($a[2] == null ? nil : $a[2])), $b;
          return self.$match_hash_var_from_str(begin_t, strings, end_t);
        }
      });
      self.$private();
      
      $def(self, '$check_condition', function $$check_condition(cond) {
        var $a, self = this, lhs = nil, rhs = nil, type = nil, $ret_or_2 = nil, lhs_condition = nil, rhs_condition = nil;

        
        switch (cond.$type().valueOf()) {
          case "masgn":
            if ($truthy($rb_le(self.parser.$version(), 23))) {
              return self.$diagnostic("error", "masgn_as_condition", nil, cond.$loc().$expression())
            } else {
              return cond
            }
            break;
          case "begin":
            if ($eqeq(cond.$children().$count(), 1)) {
              return cond.$updated(nil, [self.$check_condition(cond.$children().$last())])
            } else {
              return cond
            }
            break;
          case "and":
          case "or":
            
            $a = [].concat($to_a(cond)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
            if ($eqeq(self.parser.$version(), 18)) {
              return cond
            } else {
              return cond.$updated(cond.$type(), [self.$check_condition(lhs), self.$check_condition(rhs)])
            };
            break;
          case "irange":
          case "erange":
            
            $a = [].concat($to_a(cond)), (lhs = ($a[0] == null ? nil : $a[0])), (rhs = ($a[1] == null ? nil : $a[1])), $a;
            type = ($eqeqeq("irange", ($ret_or_2 = cond.$type())) ? ("iflipflop") : ($eqeqeq("erange", $ret_or_2) ? ("eflipflop") : (nil)));
            if (!$truthy(lhs['$nil?']())) {
              lhs_condition = self.$check_condition(lhs)
            };
            if (!$truthy(rhs['$nil?']())) {
              rhs_condition = self.$check_condition(rhs)
            };
            return cond.$updated(type, [lhs_condition, rhs_condition]);
          case "regexp":
            return self.$n("match_current_line", [cond], self.$expr_map(cond.$loc().$expression()))
          default:
            return cond
        }
      });
      
      $def(self, '$check_duplicate_args', function $$check_duplicate_args(args, map) {
        var self = this;

        
        if (map == null) map = (new Map());
        return $send(args, 'each', [], function $$14(this_arg){var self = $$14.$$s == null ? this : $$14.$$s;

          
          if (this_arg == null) this_arg = nil;
          
          switch (this_arg.$type().valueOf()) {
            case "arg":
            case "optarg":
            case "restarg":
            case "blockarg":
            case "kwarg":
            case "kwoptarg":
            case "kwrestarg":
            case "shadowarg":
              return self.$check_duplicate_arg(this_arg, map)
            case "procarg0":
              if ($truthy(this_arg.$children()['$[]'](0)['$is_a?']($$('Symbol')))) {
                return self.$check_duplicate_arg(this_arg, map)
              } else {
                return self.$check_duplicate_args(this_arg.$children(), map)
              }
              break;
            case "mlhs":
              return self.$check_duplicate_args(this_arg.$children(), map)
            default:
              return nil
          };}, {$$s: self});
      }, -2);
      
      $def(self, '$check_duplicate_arg', function $$check_duplicate_arg(this_arg, map) {
        var $a, self = this, this_name = nil, that_arg = nil, that_name = nil;

        
        if (map == null) map = (new Map());
        $a = [].concat($to_a(this_arg)), (this_name = ($a[0] == null ? nil : $a[0])), $a;
        that_arg = map['$[]'](this_name);
        $a = [].concat($to_a(that_arg)), (that_name = ($a[0] == null ? nil : $a[0])), $a;
        if ($truthy(that_arg['$nil?']())) {
          return ($a = [this_name, this_arg], $send(map, '[]=', $a), $a[$a.length - 1])
        } else if ($truthy(self['$arg_name_collides?'](this_name, that_name))) {
          return self.$diagnostic("error", "duplicate_argument", nil, this_arg.$loc().$name(), [that_arg.$loc().$name()])
        } else {
          return nil
        };
      }, -2);
      
      $def(self, '$validate_no_forward_arg_after_restarg', function $$validate_no_forward_arg_after_restarg(args) {
        var self = this, restarg = nil, forward_arg = nil;

        
        restarg = nil;
        forward_arg = nil;
        $send(args, 'each', [], function $$15(arg){
          
          if (arg == null) arg = nil;
          
          switch (arg.$type().valueOf()) {
            case "restarg":
              return (restarg = arg)
            case "forward_arg":
              return (forward_arg = arg)
            default:
              return nil
          };});
        if (($not(forward_arg['$nil?']()) && ($not(restarg['$nil?']())))) {
          return self.$diagnostic("error", "forward_arg_after_restarg", nil, forward_arg.$loc().$expression(), [restarg.$loc().$expression()])
        } else {
          return nil
        };
      });
      
      $def(self, '$check_assignment_to_numparam', function $$check_assignment_to_numparam(name, loc) {
        var self = this, assigning_to_numparam = nil, $ret_or_1 = nil, $ret_or_2 = nil;

        
        if ($truthy($rb_lt(self.parser.$version(), 27))) {
          return nil
        };
        assigning_to_numparam = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.parser.$context()['$in_dynamic_block?']())) ? (name['$=~'](/^_([1-9])$/)) : ($ret_or_2)))) ? (self.parser.$max_numparam_stack()['$has_numparams?']()) : ($ret_or_1));
        if ($truthy(assigning_to_numparam)) {
          return self.$diagnostic("error", "cant_assign_to_numparam", (new Map([["name", name]])), loc)
        } else {
          return nil
        };
      });
      
      $def(self, '$check_reserved_for_numparam', function $$check_reserved_for_numparam(name, loc) {
        var self = this;

        
        if ($truthy($rb_lt(self.parser.$version(), 30))) {
          return nil
        };
        if ($truthy(name['$=~'](/^_([1-9])$/))) {
          return self.$diagnostic("error", "reserved_for_numparam", (new Map([["name", name]])), loc)
        } else {
          return nil
        };
      });
      
      $def(self, '$arg_name_collides?', function $Default_arg_name_collides$ques$16(this_name, that_name) {
        var self = this, $ret_or_2 = nil, $ret_or_3 = nil;

        
        switch (self.parser.$version().valueOf()) {
          case 18:
            return this_name['$=='](that_name)
          case 19:
            if ($truthy(($ret_or_2 = this_name['$!=']("_")))) {
              return this_name['$=='](that_name)
            } else {
              return $ret_or_2
            }
            break;
          default:
            if ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = this_name)) ? (this_name['$[]'](0)['$!=']("_")) : ($ret_or_3))))) {
              return this_name['$=='](that_name)
            } else {
              return $ret_or_2
            }
        }
      });
      
      $def(self, '$check_lvar_name', function $$check_lvar_name(name, loc) {
        var self = this;

        if ($truthy(name['$=~'](/^[[[:lower:]]_][[[:alnum:]]_]*$/))) {
          return nil
        } else {
          return self.$diagnostic("error", "lvar_name", (new Map([["name", name]])), loc)
        }
      });
      
      $def(self, '$check_duplicate_pattern_variable', function $$check_duplicate_pattern_variable(name, loc) {
        var self = this;

        
        if ($truthy(name.$to_s()['$start_with?']("_"))) {
          return nil
        };
        if ($truthy(self.parser.$pattern_variables()['$declared?'](name))) {
          self.$diagnostic("error", "duplicate_variable_name", (new Map([["name", name.$to_s()]])), loc)
        };
        return self.parser.$pattern_variables().$declare(name);
      });
      
      $def(self, '$check_duplicate_pattern_key', function $$check_duplicate_pattern_key(name, loc) {
        var self = this;

        
        if ($truthy(self.parser.$pattern_hash_keys()['$declared?'](name))) {
          self.$diagnostic("error", "duplicate_pattern_key", (new Map([["name", name.$to_s()]])), loc)
        };
        return self.parser.$pattern_hash_keys().$declare(name);
      });
      
      $def(self, '$n', function $$n(type, children, source_map) {
        
        return $$$($$('AST'), 'Node').$new(type, children, (new Map([["location", source_map]])))
      });
      
      $def(self, '$n0', function $$n0(type, source_map) {
        var self = this;

        return self.$n(type, [], source_map)
      });
      
      $def(self, '$join_exprs', function $$join_exprs(left_expr, right_expr) {
        
        return left_expr.$loc().$expression().$join(right_expr.$loc().$expression())
      });
      
      $def(self, '$token_map', function $$token_map(token) {
        var self = this;

        return $$$($$('Source'), 'Map').$new(self.$loc(token))
      });
      
      $def(self, '$delimited_string_map', function $$delimited_string_map(string_t) {
        var self = this, str_range = nil, begin_l = nil, end_l = nil;

        
        str_range = self.$loc(string_t);
        begin_l = str_range.$with((new Map([["end_pos", $rb_plus(str_range.$begin_pos(), 1)]])));
        end_l = str_range.$with((new Map([["begin_pos", $rb_minus(str_range.$end_pos(), 1)]])));
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(begin_l, end_l, self.$loc(string_t));
      });
      
      $def(self, '$prefix_string_map', function $$prefix_string_map(symbol) {
        var self = this, str_range = nil, begin_l = nil;

        
        str_range = self.$loc(symbol);
        begin_l = str_range.$with((new Map([["end_pos", $rb_plus(str_range.$begin_pos(), 1)]])));
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(begin_l, nil, self.$loc(symbol));
      });
      
      $def(self, '$unquoted_map', function $$unquoted_map(token) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, self.$loc(token))
      });
      
      $def(self, '$pair_keyword_map', function $$pair_keyword_map(key_t, value_e) {
        var self = this, key_range = nil, key_l = nil, colon_l = nil;

        
        key_range = self.$loc(key_t);
        key_l = key_range.$adjust((new Map([["end_pos", -1]])));
        colon_l = key_range.$with((new Map([["begin_pos", $rb_minus(key_range.$end_pos(), 1)]])));
        return [$$$($$$($$('Source'), 'Map'), 'Collection').$new(nil, nil, key_l), $$$($$$($$('Source'), 'Map'), 'Operator').$new(colon_l, key_range.$join(value_e.$loc().$expression()))];
      });
      
      $def(self, '$pair_quoted_map', function $$pair_quoted_map(begin_t, end_t, value_e) {
        var self = this, end_l = nil, quote_l = nil, colon_l = nil;

        
        end_l = self.$loc(end_t);
        quote_l = end_l.$with((new Map([["begin_pos", $rb_minus(end_l.$end_pos(), 2)], ["end_pos", $rb_minus(end_l.$end_pos(), 1)]])));
        colon_l = end_l.$with((new Map([["begin_pos", $rb_minus(end_l.$end_pos(), 1)]])));
        return [[self.$value(end_t), quote_l], $$$($$$($$('Source'), 'Map'), 'Operator').$new(colon_l, self.$loc(begin_t).$join(value_e.$loc().$expression()))];
      });
      
      $def(self, '$expr_map', function $$expr_map(loc) {
        
        return $$$($$('Source'), 'Map').$new(loc)
      });
      
      $def(self, '$collection_map', function $$collection_map(begin_t, parts, end_t) {
        var self = this, expr_l = nil;

        
        if (($truthy(begin_t['$nil?']()) || ($truthy(end_t['$nil?']())))) {
          if ($truthy(parts['$any?']())) {
            expr_l = self.$join_exprs(parts.$first(), parts.$last())
          } else if ($not(begin_t['$nil?']())) {
            expr_l = self.$loc(begin_t)
          } else if ($not(end_t['$nil?']())) {
            expr_l = self.$loc(end_t)
          }
        } else {
          expr_l = self.$loc(begin_t).$join(self.$loc(end_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), expr_l);
      });
      
      $def(self, '$string_map', function $$string_map(begin_t, parts, end_t) {
        var self = this, expr_l = nil;

        if (($truthy(begin_t) && ($truthy(self.$value(begin_t)['$start_with?']("<<"))))) {
          
          if ($truthy(parts['$any?']())) {
            expr_l = self.$join_exprs(parts.$first(), parts.$last())
          } else {
            expr_l = self.$loc(end_t).$begin()
          };
          return $$$($$$($$('Source'), 'Map'), 'Heredoc').$new(self.$loc(begin_t), expr_l, self.$loc(end_t));
        } else {
          return self.$collection_map(begin_t, parts, end_t)
        }
      });
      
      $def(self, '$regexp_map', function $$regexp_map(begin_t, end_t, options_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), self.$loc(begin_t).$join(options_e.$loc().$expression()))
      });
      
      $def(self, '$constant_map', function $$constant_map(scope, colon2_t, name_t) {
        var self = this, expr_l = nil;

        
        if ($truthy(scope['$nil?']())) {
          expr_l = self.$loc(name_t)
        } else {
          expr_l = scope.$loc().$expression().$join(self.$loc(name_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Constant').$new(self.$loc(colon2_t), self.$loc(name_t), expr_l);
      });
      
      $def(self, '$variable_map', function $$variable_map(name_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(self.$loc(name_t))
      });
      
      $def(self, '$binary_op_map', function $$binary_op_map(left_e, op_t, right_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), self.$join_exprs(left_e, right_e))
      });
      
      $def(self, '$unary_op_map', function $$unary_op_map(op_t, arg_e) {
        var self = this, expr_l = nil;

        
        if (arg_e == null) arg_e = nil;
        if ($truthy(arg_e['$nil?']())) {
          expr_l = self.$loc(op_t)
        } else {
          expr_l = self.$loc(op_t).$join(arg_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), expr_l);
      }, -2);
      
      $def(self, '$range_map', function $$range_map(start_e, op_t, end_e) {
        var self = this, expr_l = nil;

        
        if (($truthy(start_e) && ($truthy(end_e)))) {
          expr_l = self.$join_exprs(start_e, end_e)
        } else if ($truthy(start_e)) {
          expr_l = start_e.$loc().$expression().$join(self.$loc(op_t))
        } else if ($truthy(end_e)) {
          expr_l = self.$loc(op_t).$join(end_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Operator').$new(self.$loc(op_t), expr_l);
      });
      
      $def(self, '$arg_prefix_map', function $$arg_prefix_map(op_t, name_t) {
        var self = this, expr_l = nil;

        
        if (name_t == null) name_t = nil;
        if ($truthy(name_t['$nil?']())) {
          expr_l = self.$loc(op_t)
        } else {
          expr_l = self.$loc(op_t).$join(self.$loc(name_t))
        };
        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(self.$loc(name_t), expr_l);
      }, -2);
      
      $def(self, '$kwarg_map', function $$kwarg_map(name_t, value_e) {
        var self = this, label_range = nil, name_range = nil, expr_l = nil;

        
        if (value_e == null) value_e = nil;
        label_range = self.$loc(name_t);
        name_range = label_range.$adjust((new Map([["end_pos", -1]])));
        if ($truthy(value_e)) {
          expr_l = self.$loc(name_t).$join(value_e.$loc().$expression())
        } else {
          expr_l = self.$loc(name_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Variable').$new(name_range, expr_l);
      }, -2);
      
      $def(self, '$module_definition_map', function $$module_definition_map(keyword_t, name_e, operator_t, end_t) {
        var self = this, name_l = nil;

        
        if ($truthy(name_e)) {
          name_l = name_e.$loc().$expression()
        };
        return $$$($$$($$('Source'), 'Map'), 'Definition').$new(self.$loc(keyword_t), self.$loc(operator_t), name_l, self.$loc(end_t));
      });
      
      $def(self, '$definition_map', function $$definition_map(keyword_t, operator_t, name_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'MethodDefinition').$new(self.$loc(keyword_t), self.$loc(operator_t), self.$loc(name_t), self.$loc(end_t), nil, nil)
      });
      
      $def(self, '$endless_definition_map', function $$endless_definition_map(keyword_t, operator_t, name_t, assignment_t, body_e) {
        var self = this, body_l = nil;

        
        body_l = body_e.$loc().$expression();
        return $$$($$$($$('Source'), 'Map'), 'MethodDefinition').$new(self.$loc(keyword_t), self.$loc(operator_t), self.$loc(name_t), nil, self.$loc(assignment_t), body_l);
      });
      
      $def(self, '$send_map', function $$send_map(receiver_e, dot_t, selector_t, begin_t, args, end_t) {
        var self = this, begin_l = nil, end_l = nil;

        
        if (begin_t == null) begin_t = nil;
        if (args == null) args = [];
        if (end_t == null) end_t = nil;
        if ($truthy(receiver_e)) {
          begin_l = receiver_e.$loc().$expression()
        } else if ($truthy(selector_t)) {
          begin_l = self.$loc(selector_t)
        };
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if ($truthy(args['$any?']())) {
          end_l = args.$last().$loc().$expression()
        } else if ($truthy(selector_t)) {
          end_l = self.$loc(selector_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(self.$loc(dot_t), self.$loc(selector_t), self.$loc(begin_t), self.$loc(end_t), begin_l.$join(end_l));
      }, -4);
      
      $def(self, '$var_send_map', function $$var_send_map(variable_e) {
        
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, variable_e.$loc().$expression(), nil, nil, variable_e.$loc().$expression())
      });
      
      $def(self, '$send_binary_op_map', function $$send_binary_op_map(lhs_e, selector_t, rhs_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, self.$join_exprs(lhs_e, rhs_e))
      });
      
      $def(self, '$send_unary_op_map', function $$send_unary_op_map(selector_t, arg_e) {
        var self = this, expr_l = nil;

        
        if ($truthy(arg_e['$nil?']())) {
          expr_l = self.$loc(selector_t)
        } else {
          expr_l = self.$loc(selector_t).$join(arg_e.$loc().$expression())
        };
        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(selector_t), nil, nil, expr_l);
      });
      
      $def(self, '$index_map', function $$index_map(receiver_e, lbrack_t, rbrack_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Index').$new(self.$loc(lbrack_t), self.$loc(rbrack_t), receiver_e.$loc().$expression().$join(self.$loc(rbrack_t)))
      });
      
      $def(self, '$send_index_map', function $$send_index_map(receiver_e, lbrack_t, rbrack_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Send').$new(nil, self.$loc(lbrack_t).$join(self.$loc(rbrack_t)), nil, nil, receiver_e.$loc().$expression().$join(self.$loc(rbrack_t)))
      });
      
      $def(self, '$block_map', function $$block_map(receiver_l, begin_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Collection').$new(self.$loc(begin_t), self.$loc(end_t), receiver_l.$join(self.$loc(end_t)))
      });
      
      $def(self, '$keyword_map', function $$keyword_map(keyword_t, begin_t, args, end_t) {
        var self = this, $ret_or_1 = nil, end_l = nil;

        
        args = ($truthy(($ret_or_1 = args)) ? ($ret_or_1) : ([]));
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if (($truthy(args['$any?']()) && ($not(args.$last()['$nil?']())))) {
          end_l = args.$last().$loc().$expression()
        } else if (($truthy(args['$any?']()) && ($truthy($rb_gt(args.$count(), 1))))) {
          end_l = args['$[]'](-2).$loc().$expression()
        } else {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));
      });
      
      $def(self, '$keyword_mod_map', function $$keyword_mod_map(pre_e, keyword_t, post_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(self.$loc(keyword_t), nil, nil, self.$join_exprs(pre_e, post_e))
      });
      
      $def(self, '$condition_map', function $$condition_map(keyword_t, cond_e, begin_t, body_e, else_t, else_e, end_t) {
        var self = this, end_l = nil;

        
        if ($truthy(end_t)) {
          end_l = self.$loc(end_t)
        } else if (($truthy(else_e) && ($truthy(else_e.$loc().$expression())))) {
          end_l = else_e.$loc().$expression()
        } else if ($truthy(self.$loc(else_t))) {
          end_l = self.$loc(else_t)
        } else if (($truthy(body_e) && ($truthy(body_e.$loc().$expression())))) {
          end_l = body_e.$loc().$expression()
        } else if ($truthy(self.$loc(begin_t))) {
          end_l = self.$loc(begin_t)
        } else {
          end_l = cond_e.$loc().$expression()
        };
        return $$$($$$($$('Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), self.$loc(begin_t), self.$loc(else_t), self.$loc(end_t), self.$loc(keyword_t).$join(end_l));
      });
      
      $def(self, '$ternary_map', function $$ternary_map(begin_e, question_t, mid_e, colon_t, end_e) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'Ternary').$new(self.$loc(question_t), self.$loc(colon_t), self.$join_exprs(begin_e, end_e))
      });
      
      $def(self, '$for_map', function $$for_map(keyword_t, in_t, begin_t, end_t) {
        var self = this;

        return $$$($$$($$('Source'), 'Map'), 'For').$new(self.$loc(keyword_t), self.$loc(in_t), self.$loc(begin_t), self.$loc(end_t), self.$loc(keyword_t).$join(self.$loc(end_t)))
      });
      
      $def(self, '$rescue_body_map', function $$rescue_body_map(keyword_t, exc_list_e, assoc_t, exc_var_e, then_t, compstmt_e) {
        var self = this, end_l = nil;

        
        if ($truthy(compstmt_e)) {
          end_l = compstmt_e.$loc().$expression()
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(then_t)))) {
          end_l = self.$loc(then_t)
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(exc_var_e)))) {
          end_l = exc_var_e.$loc().$expression()
        };
        if (($truthy(end_l['$nil?']()) && ($truthy(exc_list_e)))) {
          end_l = exc_list_e.$loc().$expression()
        };
        if ($truthy(end_l['$nil?']())) {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'RescueBody').$new(self.$loc(keyword_t), self.$loc(assoc_t), self.$loc(then_t), self.$loc(keyword_t).$join(end_l));
      });
      
      $def(self, '$eh_keyword_map', function $$eh_keyword_map(compstmt_e, keyword_t, body_es, else_t, else_e) {
        var self = this, begin_l = nil, end_l = nil;

        
        if ($truthy(compstmt_e['$nil?']())) {
          if ($truthy(keyword_t['$nil?']())) {
            begin_l = body_es.$first().$loc().$expression()
          } else {
            begin_l = self.$loc(keyword_t)
          }
        } else {
          begin_l = compstmt_e.$loc().$expression()
        };
        if ($truthy(else_t)) {
          if ($truthy(else_e['$nil?']())) {
            end_l = self.$loc(else_t)
          } else {
            end_l = else_e.$loc().$expression()
          }
        } else if ($not(body_es.$last()['$nil?']())) {
          end_l = body_es.$last().$loc().$expression()
        } else {
          end_l = self.$loc(keyword_t)
        };
        return $$$($$$($$('Source'), 'Map'), 'Condition').$new(self.$loc(keyword_t), nil, self.$loc(else_t), nil, begin_l.$join(end_l));
      });
      
      $def(self, '$guard_map', function $$guard_map(keyword_t, guard_body_e) {
        var self = this, keyword_l = nil, guard_body_l = nil;

        
        keyword_l = self.$loc(keyword_t);
        guard_body_l = guard_body_e.$loc().$expression();
        return $$$($$$($$('Source'), 'Map'), 'Keyword').$new(keyword_l, nil, nil, keyword_l.$join(guard_body_l));
      });
      
      $def(self, '$static_string', function $$static_string(nodes) {try { var $t_return = $thrower('return'); 
        var self = this;

        return $send(nodes, 'map', [], function $$17(node){var self = $$17.$$s == null ? this : $$17.$$s, string = nil;

          
          if (node == null) node = nil;
          
          switch (node.$type().valueOf()) {
            case "str":
              return node.$children()['$[]'](0)
            case "begin":
              if ($truthy((string = self.$static_string(node.$children())))) {
                return string
              } else {
                $t_return.$throw(nil, $$17.$$is_lambda)
              }
              break;
            default:
              $t_return.$throw(nil, $$17.$$is_lambda)
          };}, {$$s: self, $$ret: $t_return}).$join()} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        } finally {$t_return.is_orphan = true;}
      });
      
      $def(self, '$static_regexp', function $$static_regexp(parts, options) {
        var self = this, source = nil;

        
        source = self.$static_string(parts);
        if ($truthy(source['$nil?']())) {
          return nil
        };
        source = ($truthy(options.$children()['$include?']("u")) ? (source.$encode($$$($$('Encoding'), 'UTF_8'))) : ($truthy(options.$children()['$include?']("e")) ? (source.$encode($$$($$('Encoding'), 'EUC_JP'))) : ($truthy(options.$children()['$include?']("s")) ? (source.$encode($$$($$('Encoding'), 'WINDOWS_31J'))) : ($truthy(options.$children()['$include?']("n")) ? (source.$encode($$$($$('Encoding'), 'BINARY'))) : (source)))));
        return $$('Regexp').$new(source, ($truthy(options.$children()['$include?']("x")) ? ($$$($$('Regexp'), 'EXTENDED')) : nil));
      });
      
      $def(self, '$static_regexp_node', function $$static_regexp_node(node) {
        var $a, self = this, parts = nil, options = nil;

        if ($eqeq(node.$type(), "regexp")) {
          
          $a = [node.$children()['$[]']($range(0, -2, false)), node.$children()['$[]'](-1)], (parts = $a[0]), (options = $a[1]), $a;
          return self.$static_regexp(parts, options);
        } else {
          return nil
        }
      });
      
      $def(self, '$collapse_string_parts?', function $Default_collapse_string_parts$ques$18(parts) {
        var $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = parts['$one?']()))) {
          return ["str", "dstr"]['$include?'](parts.$first().$type())
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$value', function $$value(token) {
        
        return token['$[]'](0)
      });
      
      $def(self, '$string_value', function $$string_value(token) {
        var self = this;

        
        if (!$truthy(token['$[]'](0)['$valid_encoding?']())) {
          self.$diagnostic("error", "invalid_encoding", nil, token['$[]'](1))
        };
        return token['$[]'](0);
      });
      
      $def(self, '$loc', function $$loc(token) {
        
        if (($truthy(token) && ($truthy(token['$[]'](0))))) {
          return token['$[]'](1)
        } else {
          return nil
        }
      });
      
      $def(self, '$diagnostic', function $$diagnostic(type, reason, arguments$, location, highlights) {
        var self = this;

        
        if (highlights == null) highlights = [];
        self.parser.$diagnostics().$process($$('Diagnostic').$new(type, reason, arguments$, location, highlights));
        if ($eqeq(type, "error")) {
          return self.parser.$send("yyerror")
        } else {
          return nil
        };
      }, -5);
      
      $def(self, '$validate_definee', function $$validate_definee(definee) {
        var self = this;

        
        switch (definee.$type().valueOf()) {
          case "int":
          case "str":
          case "dstr":
          case "sym":
          case "dsym":
          case "regexp":
          case "array":
          case "hash":
            
            self.$diagnostic("error", "singleton_literal", nil, definee.$loc().$expression());
            return false;
          default:
            return true
        }
      });
      
      $def(self, '$rewrite_hash_args_to_kwargs', function $$rewrite_hash_args_to_kwargs(args) {
        var $a, self = this;

        if (($truthy(args['$any?']()) && ($truthy(self['$kwargs?'](args.$last()))))) {
          return ($a = [$rb_minus(args.$length(), 1), args['$[]']($rb_minus(args.$length(), 1)).$updated("kwargs")], $send(args, '[]=', $a), $a[$a.length - 1])
        } else if ((($truthy($rb_gt(args.$length(), 1)) && ($eqeq(args.$last().$type(), "block_pass"))) && ($truthy(self['$kwargs?'](args['$[]']($rb_minus(args.$length(), 2))))))) {
          return ($a = [$rb_minus(args.$length(), 2), args['$[]']($rb_minus(args.$length(), 2)).$updated("kwargs")], $send(args, '[]=', $a), $a[$a.length - 1])
        } else {
          return nil
        }
      });
      return $def(self, '$kwargs?', function $Default_kwargs$ques$19(node) {
        var $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = node.$type()['$==']("hash"))) ? (node.$loc().$begin()['$nil?']()) : ($ret_or_2))))) {
          return node.$loc().$end()['$nil?']()
        } else {
          return $ret_or_1
        }
      });
    })($$('Builders'), null, $nesting)
  })($nesting[0], $nesting)
});
