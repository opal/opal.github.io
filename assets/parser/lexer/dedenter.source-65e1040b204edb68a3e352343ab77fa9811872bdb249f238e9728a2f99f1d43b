Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $eqeq = Opal.eqeq, $send = Opal.send, $truthy = Opal.truthy, $to_ary = Opal.to_ary, $slice = Opal.slice, $rb_le = Opal.rb_le, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $thrower = Opal.thrower, $assign_ivar_val = Opal.assign_ivar_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('encoding,split,force_encoding,==,length,map!,each,each_char,<=,===,+,-,>,*,/,slice!,replace,join,end_with?');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Dedenter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.at_line_begin = nil;
      
      $const_set($nesting[0], 'TAB_WIDTH', 8);
      
      $def(self, '$initialize', function $$initialize(dedent_level) {
        var self = this;

        
        self.dedent_level = dedent_level;
        self.at_line_begin = true;
        return (self.indent_level = 0);
      });
      
      $def(self, '$dedent', function $$dedent(string) {
        var $a, $b, self = this, original_encoding = nil, lines = nil, lines_to_dedent = nil, _first = nil;

        
        original_encoding = string.$encoding();
        lines = string.$force_encoding($$$($$('Encoding'), 'BINARY')).$split("\\\n");
        if ($eqeq(lines.$length(), 1)) {
          lines = [string.$force_encoding(original_encoding)]
        } else {
          $send(lines, 'map!', [], function $$1(s){
            
            if (s == null) s = nil;
            return s.$force_encoding(original_encoding);})
        };
        if ($truthy(self.at_line_begin)) {
          lines_to_dedent = lines
        } else {
          $b = lines, $a = $to_ary($b), (_first = ($a[0] == null ? nil : $a[0])), (lines_to_dedent = $slice($a, 1)), $b
        };
        $send(lines_to_dedent, 'each', [], function $$2(line){var self = $$2.$$s == null ? this : $$2.$$s, left_to_remove = nil, remove = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          if (line == null) line = nil;
          left_to_remove = self.dedent_level;
          remove = 0;
          (function(){try { var $t_break = $thrower('break'); return $send(line, 'each_char', [], function $$3(char$){var self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil;
            if (self.dedent_level == null) self.dedent_level = nil;

            
            if (char$ == null) char$ = nil;
            if ($truthy($rb_le(left_to_remove, 0))) {
              $t_break.$throw(nil, $$3.$$is_lambda)
            };
            if ($eqeqeq(" ", ($ret_or_1 = char$))) {
              
              remove = $rb_plus(remove, 1);
              return (left_to_remove = $rb_minus(left_to_remove, 1));
            } else if ($eqeqeq("\t", $ret_or_1)) {
              
              if ($truthy($rb_gt($rb_times($$('TAB_WIDTH'), $rb_plus($rb_divide(remove, $$('TAB_WIDTH')), 1)), self.dedent_level))) {
                $t_break.$throw(nil, $$3.$$is_lambda)
              };
              remove = $rb_plus(remove, 1);
              return (left_to_remove = $rb_minus(left_to_remove, $$('TAB_WIDTH')));
            } else {
              $t_break.$throw(nil, $$3.$$is_lambda)
            };}, {$$s: self})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          } finally {$t_break.is_orphan = true;}})();
          return line['$slice!'](0, remove);}, {$$s: self});
        string.$replace(lines.$join());
        return (self.at_line_begin = string['$end_with?']("\n"));
      });
      return $def(self, '$interrupt', $assign_ivar_val("at_line_begin", false));
    })($$('Lexer'), null, $nesting)
  })($nesting[0], $nesting)
});
