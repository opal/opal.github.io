Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $enc = Opal.enc, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $to_ary = Opal.to_ary, $def = Opal.def, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $neqeq = Opal.neqeq, $not = Opal.not, $send = Opal.send, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $thrower = Opal.thrower, $assign_ivar_val = Opal.assign_ivar_val, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,attr_accessor,coerce_encoding,include?,send,+,[],fetch,==,!,heredoc?,start_with?,freeze,clear_buffer,emit_start_tok,type,=~,words?,delimiter?,-,extend_space,!=,flush_string,emit,each_char,===,%,>,nil?,<<,empty?,extend_content,protected,lstrip,b,dup,force_encoding,encoding,source,source_buffer,length');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Literal');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.lexer = $proto.start_tok = $proto.str_type = $proto.monolithic = $proto.heredoc_e = $proto.dedent_body = $proto.end_delim = $proto.start_delim = $proto.nesting = $proto.label_allowed = $proto.buffer = $proto.str_s = $proto.interp_braces = $proto.buffer_s = $proto.buffer_e = $proto.space_emitted = $proto.interpolate = $proto.indent = nil;
      
      $const_set($nesting[0], 'DELIMITERS', (new Map([["(", $enc(")", "ASCII-8BIT")], ["[", $enc("]", "ASCII-8BIT")], ["{", $enc("}", "ASCII-8BIT")], ["<", $enc(">", "ASCII-8BIT")]])));
      $const_set($nesting[0], 'TYPES', (new Map([["'", ["tSTRING_BEG", false]], ["<<'", ["tSTRING_BEG", false]], ["%q", ["tSTRING_BEG", false]], ["\"", ["tSTRING_BEG", true]], ["<<\"", ["tSTRING_BEG", true]], ["%", ["tSTRING_BEG", true]], ["%Q", ["tSTRING_BEG", true]], ["%w", ["tQWORDS_BEG", false]], ["%W", ["tWORDS_BEG", true]], ["%i", ["tQSYMBOLS_BEG", false]], ["%I", ["tSYMBOLS_BEG", true]], [":'", ["tSYMBEG", false]], ["%s", ["tSYMBEG", false]], [":\"", ["tSYMBEG", true]], ["/", ["tREGEXP_BEG", true]], ["%r", ["tREGEXP_BEG", true]], ["%x", ["tXSTRING_BEG", true]], ["`", ["tXSTRING_BEG", true]], ["<<`", ["tXSTRING_BEG", true]]])));
      self.$attr_reader("heredoc_e", "str_s", "dedent_level");
      self.$attr_accessor("saved_herebody_s");
      
      $def(self, '$initialize', function $$initialize(lexer, str_type, delimiter, str_s, heredoc_e, indent, dedent_body, label_allowed) {
        var $a, $b, self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        
        if (heredoc_e == null) heredoc_e = nil;
        if (indent == null) indent = false;
        if (dedent_body == null) dedent_body = false;
        if (label_allowed == null) label_allowed = false;
        self.lexer = lexer;
        self.nesting = 1;
        str_type = self.$coerce_encoding(str_type);
        delimiter = self.$coerce_encoding(delimiter);
        if (!$truthy($$('TYPES')['$include?'](str_type))) {
          lexer.$send("diagnostic", "error", "unexpected_percent_str", (new Map([["type", str_type]])), self.lexer.$send("range", str_s, $rb_plus(str_s, 2)))
        };
        self.str_type = str_type;
        self.str_s = str_s;
        $b = $$('TYPES')['$[]'](str_type), $a = $to_ary($b), (self.start_tok = ($a[0] == null ? nil : $a[0])), (self.interpolate = ($a[1] == null ? nil : $a[1])), $b;
        self.start_delim = ($truthy($$('DELIMITERS')['$include?'](delimiter)) ? (delimiter) : (nil));
        self.end_delim = $$('DELIMITERS').$fetch(delimiter, delimiter);
        self.heredoc_e = heredoc_e;
        self.indent = indent;
        self.label_allowed = label_allowed;
        self.dedent_body = dedent_body;
        self.dedent_level = nil;
        self.interp_braces = 0;
        self.space_emitted = true;
        self.monolithic = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.start_tok['$==']("tSTRING_BEG"))) ? ([$enc("'", "ASCII-8BIT"), $enc("\"", "ASCII-8BIT")]['$include?'](str_type)) : ($ret_or_2)))) ? (self['$heredoc?']()['$!']()) : ($ret_or_1));
        if ($truthy(self.str_type['$start_with?']($enc("%", "ASCII-8BIT").$freeze()))) {
          self.str_type = $rb_plus(self.str_type, delimiter)
        };
        self.$clear_buffer();
        if ($truthy(self.monolithic)) {
          return nil
        } else {
          return self.$emit_start_tok()
        };
      }, -5);
      
      $def(self, '$interpolate?', $return_ivar("interpolate"));
      
      $def(self, '$words?', function $Literal_words$ques$1() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.$type()['$==']("tWORDS_BEG"))) ? ($ret_or_3) : (self.$type()['$==']("tQWORDS_BEG"))))) ? ($ret_or_2) : (self.$type()['$==']("tSYMBOLS_BEG")))))) {
          return $ret_or_1
        } else {
          return self.$type()['$==']("tQSYMBOLS_BEG")
        }
      });
      
      $def(self, '$regexp?', function $Literal_regexp$ques$2() {
        var self = this;

        return self.$type()['$==']("tREGEXP_BEG")
      });
      
      $def(self, '$heredoc?', function $Literal_heredoc$ques$3() {
        var self = this;

        return self.heredoc_e['$!']()['$!']()
      });
      
      $def(self, '$plain_heredoc?', function $Literal_plain_heredoc$ques$4() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$heredoc?']()))) {
          return self.dedent_body['$!']()
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$squiggly_heredoc?', function $Literal_squiggly_heredoc$ques$5() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$heredoc?']()))) {
          return self.dedent_body
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$backslash_delimited?', function $Literal_backslash_delimited$ques$6() {
        var self = this;

        return self.end_delim['$==']($enc("\\", "ASCII-8BIT").$freeze())
      });
      
      $def(self, '$type', $return_ivar("start_tok"));
      
      $def(self, '$munge_escape?', function $Literal_munge_escape$ques$7(character) {
        var self = this;

        
        character = self.$coerce_encoding(character);
        if (($truthy(self['$words?']()) && ($truthy(character['$=~'](/[ \t\v\r\f\n]/))))) {
          return true
        } else {
          return [$enc("\\", "ASCII-8BIT").$freeze(), self.start_delim, self.end_delim]['$include?'](character)
        };
      });
      
      $def(self, '$nest_and_try_closing', function $$nest_and_try_closing(delimiter, ts, te, lookahead) {
        var self = this;

        
        if (lookahead == null) lookahead = nil;
        delimiter = self.$coerce_encoding(delimiter);
        if (($truthy(self.start_delim) && ($eqeq(self.start_delim, delimiter)))) {
          self.nesting = $rb_plus(self.nesting, 1)
        } else if ($truthy(self['$delimiter?'](delimiter))) {
          self.nesting = $rb_minus(self.nesting, 1)
        };
        if ($eqeq(self.nesting, 0)) {
          
          if ($truthy(self['$words?']())) {
            self.$extend_space(ts, ts)
          };
          if ((((($truthy(lookahead) && ($truthy(self.label_allowed))) && ($eqeq(lookahead['$[]'](0), $enc(":", "ASCII-8BIT")))) && ($neqeq(lookahead['$[]'](1), $enc(":", "ASCII-8BIT")))) && ($eqeq(self.start_tok, "tSTRING_BEG")))) {
            
            self.$flush_string();
            return self.$emit("tLABEL_END", self.end_delim, ts, $rb_plus(te, 1));
          } else if ($truthy(self.monolithic)) {
            return self.$emit("tSTRING", self.buffer, self.str_s, te)
          } else {
            
            if (!$truthy(self['$heredoc?']())) {
              self.$flush_string()
            };
            return self.$emit("tSTRING_END", self.end_delim, ts, te);
          };
        } else {
          return nil
        };
      }, -4);
      
      $def(self, '$infer_indent_level', function $$infer_indent_level(line) {
        var self = this, indent_level = nil;

        
        if ($not(self.dedent_body)) {
          return nil
        };
        indent_level = 0;
        return (function(){try { var $t_break = $thrower('break'); return $send(line, 'each_char', [], function $$8(char$){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

          
          if (char$ == null) char$ = nil;
          if ($eqeqeq(" ", ($ret_or_1 = char$))) {
            return (indent_level = $rb_plus(indent_level, 1))
          } else if ($eqeqeq("\t", $ret_or_1)) {
            return (indent_level = $rb_plus(indent_level, $rb_minus(8, indent_level['$%'](8))))
          } else {
            
            if (($truthy(self.dedent_level['$nil?']()) || ($truthy($rb_gt(self.dedent_level, indent_level))))) {
              self.dedent_level = indent_level
            };
            $t_break.$throw(nil, $$8.$$is_lambda);
          };}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        } finally {$t_break.is_orphan = true;}})();
      });
      
      $def(self, '$start_interp_brace', function $$start_interp_brace() {
        var self = this;

        return (self.interp_braces = $rb_plus(self.interp_braces, 1))
      });
      
      $def(self, '$end_interp_brace_and_try_closing', function $$end_interp_brace_and_try_closing() {
        var self = this;

        
        self.interp_braces = $rb_minus(self.interp_braces, 1);
        
        return self.interp_braces['$=='](0);;
      });
      
      $def(self, '$extend_string', function $$extend_string(string, ts, te) {
        var self = this, $ret_or_1 = nil;

        
        self.buffer_s = ($truthy(($ret_or_1 = self.buffer_s)) ? ($ret_or_1) : (ts));
        self.buffer_e = te;
        return self.buffer['$<<'](string);
      });
      
      $def(self, '$flush_string', function $$flush_string() {
        var self = this;

        
        if ($truthy(self.monolithic)) {
          
          self.$emit_start_tok();
          self.monolithic = false;
        };
        if ($truthy(self.buffer['$empty?']())) {
          return nil
        } else {
          
          self.$emit("tSTRING_CONTENT", self.buffer, self.buffer_s, self.buffer_e);
          self.$clear_buffer();
          return self.$extend_content();
        };
      });
      
      $def(self, '$extend_content', $assign_ivar_val("space_emitted", false));
      
      $def(self, '$extend_space', function $$extend_space(ts, te) {
        var self = this;

        
        self.$flush_string();
        if ($truthy(self.space_emitted)) {
          return nil
        } else {
          
          self.$emit("tSPACE", nil, ts, te);
          return (self.space_emitted = true);
        };
      });
      
      $def(self, '$supports_line_continuation_via_slash?', function $Literal_supports_line_continuation_via_slash$ques$9() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self['$words?']()['$!']()))) {
          return self.interpolate
        } else {
          return $ret_or_1
        }
      });
      self.$protected();
      
      $def(self, '$delimiter?', function $Literal_delimiter$ques$10(delimiter) {
        var self = this;

        if ($truthy(self.indent)) {
          return self.end_delim['$=='](delimiter.$lstrip())
        } else {
          return self.end_delim['$=='](delimiter)
        }
      });
      
      $def(self, '$coerce_encoding', function $$coerce_encoding(string) {
        
        return string.$b()
      });
      
      $def(self, '$clear_buffer', function $$clear_buffer() {
        var self = this;

        
        self.buffer = $enc("", "ASCII-8BIT").$dup();
        self.buffer.$force_encoding(self.lexer.$source_buffer().$source().$encoding());
        self.buffer_s = nil;
        return (self.buffer_e = nil);
      });
      
      $def(self, '$emit_start_tok', function $$emit_start_tok() {
        var self = this, str_e = nil, $ret_or_1 = nil;

        
        str_e = ($truthy(($ret_or_1 = self.heredoc_e)) ? ($ret_or_1) : ($rb_plus(self.str_s, self.str_type.$length())));
        return self.$emit(self.start_tok, self.str_type, self.str_s, str_e);
      });
      return $def(self, '$emit', function $$emit(token, type, s, e) {
        var self = this;

        return self.lexer.$send("emit", token, type, s, e)
      });
    })($$('Lexer'), null, $nesting)
  })($nesting[0], $nesting)
});
