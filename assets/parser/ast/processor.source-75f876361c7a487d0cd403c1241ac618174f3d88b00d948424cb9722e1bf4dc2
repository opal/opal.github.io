Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $alias = Opal.alias, $to_a = Opal.to_a, $not = Opal.not, $truthy = Opal.truthy, $slice = Opal.slice, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('updated,process_all,process_regular_node,on_var,process_variable_node,!,nil?,process,on_vasgn,process_var_asgn_node,on_argument,process_argument_node,is_a?,[],children,on_send,warn');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'AST');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Processor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$process_regular_node', function $$process_regular_node(node) {
          var self = this;

          return node.$updated(nil, self.$process_all(node))
        });
        $alias(self, "on_dstr", "process_regular_node");
        $alias(self, "on_dsym", "process_regular_node");
        $alias(self, "on_regexp", "process_regular_node");
        $alias(self, "on_xstr", "process_regular_node");
        $alias(self, "on_splat", "process_regular_node");
        $alias(self, "on_kwsplat", "process_regular_node");
        $alias(self, "on_array", "process_regular_node");
        $alias(self, "on_pair", "process_regular_node");
        $alias(self, "on_hash", "process_regular_node");
        $alias(self, "on_kwargs", "process_regular_node");
        $alias(self, "on_irange", "process_regular_node");
        $alias(self, "on_erange", "process_regular_node");
        
        $def(self, '$on_var', function $$on_var(node) {
          
          return node
        });
        
        $def(self, '$process_variable_node', function $$process_variable_node(node) {
          var self = this;

          return self.$on_var(node)
        });
        $alias(self, "on_lvar", "process_variable_node");
        $alias(self, "on_ivar", "process_variable_node");
        $alias(self, "on_gvar", "process_variable_node");
        $alias(self, "on_cvar", "process_variable_node");
        $alias(self, "on_back_ref", "process_variable_node");
        $alias(self, "on_nth_ref", "process_variable_node");
        
        $def(self, '$on_vasgn', function $$on_vasgn(node) {
          var $a, self = this, name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [name, self.$process(value_node)])
          } else {
            return node
          };
        });
        
        $def(self, '$process_var_asgn_node', function $$process_var_asgn_node(node) {
          var self = this;

          return self.$on_vasgn(node)
        });
        $alias(self, "on_lvasgn", "process_var_asgn_node");
        $alias(self, "on_ivasgn", "process_var_asgn_node");
        $alias(self, "on_gvasgn", "process_var_asgn_node");
        $alias(self, "on_cvasgn", "process_var_asgn_node");
        $alias(self, "on_and_asgn", "process_regular_node");
        $alias(self, "on_or_asgn", "process_regular_node");
        
        $def(self, '$on_op_asgn', function $$on_op_asgn(node) {
          var $a, self = this, var_node = nil, method_name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (var_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [self.$process(var_node), method_name, self.$process(value_node)]);
        });
        $alias(self, "on_mlhs", "process_regular_node");
        $alias(self, "on_masgn", "process_regular_node");
        
        $def(self, '$on_const', function $$on_const(node) {
          var $a, self = this, scope_node = nil, name = nil;

          
          $a = [].concat($to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), $a;
          return node.$updated(nil, [self.$process(scope_node), name]);
        });
        
        $def(self, '$on_casgn', function $$on_casgn(node) {
          var $a, self = this, scope_node = nil, name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (scope_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (value_node = ($a[2] == null ? nil : $a[2])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [self.$process(scope_node), name, self.$process(value_node)])
          } else {
            return node.$updated(nil, [self.$process(scope_node), name])
          };
        });
        $alias(self, "on_args", "process_regular_node");
        
        $def(self, '$on_argument', function $$on_argument(node) {
          var $a, self = this, arg_name = nil, value_node = nil;

          
          $a = [].concat($to_a(node)), (arg_name = ($a[0] == null ? nil : $a[0])), (value_node = ($a[1] == null ? nil : $a[1])), $a;
          if ($not(value_node['$nil?']())) {
            return node.$updated(nil, [arg_name, self.$process(value_node)])
          } else {
            return node
          };
        });
        
        $def(self, '$process_argument_node', function $$process_argument_node(node) {
          var self = this;

          return self.$on_argument(node)
        });
        $alias(self, "on_arg", "process_argument_node");
        $alias(self, "on_optarg", "process_argument_node");
        $alias(self, "on_restarg", "process_argument_node");
        $alias(self, "on_blockarg", "process_argument_node");
        $alias(self, "on_shadowarg", "process_argument_node");
        $alias(self, "on_kwarg", "process_argument_node");
        $alias(self, "on_kwoptarg", "process_argument_node");
        $alias(self, "on_kwrestarg", "process_argument_node");
        $alias(self, "on_forward_arg", "process_argument_node");
        
        $def(self, '$on_procarg0', function $$on_procarg0(node) {
          var self = this;

          if ($truthy(node.$children()['$[]'](0)['$is_a?']($$('Symbol')))) {
            return self.$on_argument(node)
          } else {
            return self.$process_regular_node(node)
          }
        });
        $alias(self, "on_arg_expr", "process_regular_node");
        $alias(self, "on_restarg_expr", "process_regular_node");
        $alias(self, "on_blockarg_expr", "process_regular_node");
        $alias(self, "on_block_pass", "process_regular_node");
        $alias(self, "on_forwarded_restarg", "process_regular_node");
        $alias(self, "on_forwarded_kwrestarg", "process_regular_node");
        $alias(self, "on_module", "process_regular_node");
        $alias(self, "on_class", "process_regular_node");
        $alias(self, "on_sclass", "process_regular_node");
        
        $def(self, '$on_def', function $$on_def(node) {
          var $a, self = this, name = nil, args_node = nil, body_node = nil;

          
          $a = [].concat($to_a(node)), (name = ($a[0] == null ? nil : $a[0])), (args_node = ($a[1] == null ? nil : $a[1])), (body_node = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [name, self.$process(args_node), self.$process(body_node)]);
        });
        
        $def(self, '$on_defs', function $$on_defs(node) {
          var $a, self = this, definee_node = nil, name = nil, args_node = nil, body_node = nil;

          
          $a = [].concat($to_a(node)), (definee_node = ($a[0] == null ? nil : $a[0])), (name = ($a[1] == null ? nil : $a[1])), (args_node = ($a[2] == null ? nil : $a[2])), (body_node = ($a[3] == null ? nil : $a[3])), $a;
          return node.$updated(nil, [self.$process(definee_node), name, self.$process(args_node), self.$process(body_node)]);
        });
        $alias(self, "on_undef", "process_regular_node");
        $alias(self, "on_alias", "process_regular_node");
        
        $def(self, '$on_send', function $$on_send(node) {
          var $a, self = this, receiver_node = nil, method_name = nil, arg_nodes = nil;

          
          $a = [].concat($to_a(node)), (receiver_node = ($a[0] == null ? nil : $a[0])), (method_name = ($a[1] == null ? nil : $a[1])), (arg_nodes = $slice($a, 2)), $a;
          if ($truthy(receiver_node)) {
            receiver_node = self.$process(receiver_node)
          };
          return node.$updated(nil, [receiver_node, method_name].concat($to_a(self.$process_all(arg_nodes))));
        });
        $alias(self, "on_csend", "on_send");
        $alias(self, "on_index", "process_regular_node");
        $alias(self, "on_indexasgn", "process_regular_node");
        $alias(self, "on_block", "process_regular_node");
        $alias(self, "on_lambda", "process_regular_node");
        
        $def(self, '$on_numblock', function $$on_numblock(node) {
          var $a, self = this, method_call = nil, max_numparam = nil, body = nil;

          
          $a = [].concat($to_a(node)), (method_call = ($a[0] == null ? nil : $a[0])), (max_numparam = ($a[1] == null ? nil : $a[1])), (body = ($a[2] == null ? nil : $a[2])), $a;
          return node.$updated(nil, [self.$process(method_call), max_numparam, self.$process(body)]);
        });
        $alias(self, "on_while", "process_regular_node");
        $alias(self, "on_while_post", "process_regular_node");
        $alias(self, "on_until", "process_regular_node");
        $alias(self, "on_until_post", "process_regular_node");
        $alias(self, "on_for", "process_regular_node");
        $alias(self, "on_return", "process_regular_node");
        $alias(self, "on_break", "process_regular_node");
        $alias(self, "on_next", "process_regular_node");
        $alias(self, "on_redo", "process_regular_node");
        $alias(self, "on_retry", "process_regular_node");
        $alias(self, "on_super", "process_regular_node");
        $alias(self, "on_yield", "process_regular_node");
        $alias(self, "on_defined?", "process_regular_node");
        $alias(self, "on_not", "process_regular_node");
        $alias(self, "on_and", "process_regular_node");
        $alias(self, "on_or", "process_regular_node");
        $alias(self, "on_if", "process_regular_node");
        $alias(self, "on_when", "process_regular_node");
        $alias(self, "on_case", "process_regular_node");
        $alias(self, "on_iflipflop", "process_regular_node");
        $alias(self, "on_eflipflop", "process_regular_node");
        $alias(self, "on_match_current_line", "process_regular_node");
        $alias(self, "on_match_with_lvasgn", "process_regular_node");
        $alias(self, "on_resbody", "process_regular_node");
        $alias(self, "on_rescue", "process_regular_node");
        $alias(self, "on_ensure", "process_regular_node");
        $alias(self, "on_begin", "process_regular_node");
        $alias(self, "on_kwbegin", "process_regular_node");
        $alias(self, "on_preexe", "process_regular_node");
        $alias(self, "on_postexe", "process_regular_node");
        $alias(self, "on_case_match", "process_regular_node");
        $alias(self, "on_in_match", "process_regular_node");
        $alias(self, "on_match_pattern", "process_regular_node");
        $alias(self, "on_match_pattern_p", "process_regular_node");
        $alias(self, "on_in_pattern", "process_regular_node");
        $alias(self, "on_if_guard", "process_regular_node");
        $alias(self, "on_unless_guard", "process_regular_node");
        $alias(self, "on_match_var", "process_variable_node");
        $alias(self, "on_match_rest", "process_regular_node");
        $alias(self, "on_pin", "process_regular_node");
        $alias(self, "on_match_alt", "process_regular_node");
        $alias(self, "on_match_as", "process_regular_node");
        $alias(self, "on_array_pattern", "process_regular_node");
        $alias(self, "on_array_pattern_with_tail", "process_regular_node");
        $alias(self, "on_hash_pattern", "process_regular_node");
        $alias(self, "on_const_pattern", "process_regular_node");
        $alias(self, "on_find_pattern", "process_regular_node");
        
        $def(self, '$process_variable_node', function $$process_variable_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_variable_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_var instead.");
          return self.$on_var(node);
        });
        
        $def(self, '$process_var_asgn_node', function $$process_var_asgn_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_var_asgn_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_vasgn instead.");
          return self.$on_vasgn(node);
        });
        
        $def(self, '$process_argument_node', function $$process_argument_node(node) {
          var self = this;

          
          self.$warn("Parser::AST::Processor#process_argument_node is deprecated as a" + " public API and will be removed. Please use " + "Parser::AST::Processor#on_argument instead.");
          return self.$on_argument(node);
        });
        return $def(self, '$on_empty_else', function $$on_empty_else(node) {
          
          return node
        });
      })($nesting[0], $$$($$$('AST'), 'Processor'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
