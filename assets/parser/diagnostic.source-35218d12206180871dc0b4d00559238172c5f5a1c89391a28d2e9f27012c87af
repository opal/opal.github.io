Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $truthy = Opal.truthy, $def = Opal.def, $eqeq = Opal.eqeq, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $to_ary = Opal.to_ary, $rb_gt = Opal.rb_gt, $rb_times = Opal.rb_times, $send = Opal.send, $rb_ge = Opal.rb_ge, $not = Opal.not, $neqeq = Opal.neqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('freeze,attr_reader,include?,raise,join,inspect,dup,compile,is?,==,line,last_line,+,message,render_line,first_line_only,last_line_only,-,source_buffer,decompose_position,end_pos,>,private,source_line,*,length,each,line_range,intersect,[]=,column_range,size,>=,!,map,name,!=,resize,=~,source,adjust');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Diagnostic');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.reason = $proto["arguments"] = $proto.location = $proto.level = $proto.highlights = nil;
      
      $const_set($nesting[0], 'LEVELS', ["note", "warning", "error", "fatal"].$freeze());
      self.$attr_reader("level", "reason", "arguments");
      self.$attr_reader("location", "highlights");
      
      $def(self, '$initialize', function $$initialize(level, reason, arguments$, location, highlights) {
        var self = this, $ret_or_1 = nil;

        
        if (highlights == null) highlights = [];
        if (!$truthy($$('LEVELS')['$include?'](level))) {
          self.$raise($$('ArgumentError'), "" + ("Diagnostic#level must be one of " + ($$('LEVELS').$join(", ")) + "; ") + ("" + (level.$inspect()) + " provided."))
        };
        if (!$truthy(location)) {
          self.$raise("Expected a location")
        };
        self.level = level;
        self.reason = reason;
        self["arguments"] = ($truthy(($ret_or_1 = arguments$)) ? ($ret_or_1) : ((new Map()))).$dup().$freeze();
        self.location = location;
        self.highlights = highlights.$dup().$freeze();
        return self.$freeze();
      }, -5);
      
      $def(self, '$message', function $$message() {
        var self = this;

        return $$('Messages').$compile(self.reason, self["arguments"])
      });
      
      $def(self, '$render', function $$render() {
        var $a, $b, self = this, first_line = nil, last_line = nil, num_lines = nil, buffer = nil, last_lineno = nil, last_column = nil;

        if (($eqeq(self.location.$line(), self.location.$last_line()) || ($truthy(self.location['$is?']("\n"))))) {
          return $rb_plus(["" + (self.location) + ": " + (self.level) + ": " + (self.$message())], self.$render_line(self.location))
        } else {
          
          first_line = self.$first_line_only(self.location);
          last_line = self.$last_line_only(self.location);
          num_lines = $rb_plus($rb_minus(self.location.$last_line(), self.location.$line()), 1);
          buffer = self.location.$source_buffer();
          $b = buffer.$decompose_position(self.location.$end_pos()), $a = $to_ary($b), (last_lineno = ($a[0] == null ? nil : $a[0])), (last_column = ($a[1] == null ? nil : $a[1])), $b;
          return $rb_plus($rb_plus(["" + (self.location) + "-" + (last_lineno) + ":" + (last_column) + ": " + (self.level) + ": " + (self.$message())], self.$render_line(first_line, $rb_gt(num_lines, 2), false)), self.$render_line(last_line, false, true));
        }
      });
      self.$private();
      
      $def(self, '$render_line', function $$render_line(range, ellipsis, range_end) {
        var self = this, source_line = nil, highlight_line = nil;

        
        if (ellipsis == null) ellipsis = false;
        if (range_end == null) range_end = false;
        source_line = range.$source_line();
        highlight_line = $rb_times(" ", source_line.$length());
        $send(self.highlights, 'each', [], function $$1(highlight){var $a, line_range = nil;

          
          if (highlight == null) highlight = nil;
          line_range = range.$source_buffer().$line_range(range.$line());
          if ($truthy((highlight = highlight.$intersect(line_range)))) {
            return ($a = [highlight.$column_range(), $rb_times("~", highlight.$size())], $send(highlight_line, '[]=', $a), $a[$a.length - 1])
          } else {
            return nil
          };});
        if ($truthy(range['$is?']("\n"))) {
          highlight_line = $rb_plus(highlight_line, "^")
        } else if (($not(range_end) && ($truthy($rb_ge(range.$size(), 1))))) {
          highlight_line['$[]='](range.$column_range(), $rb_plus("^", $rb_times("~", $rb_minus(range.$size(), 1))))
        } else {
          highlight_line['$[]='](range.$column_range(), $rb_times("~", range.$size()))
        };
        if ($truthy(ellipsis)) {
          highlight_line = $rb_plus(highlight_line, "...")
        };
        return $send([source_line, highlight_line], 'map', [], function $$2(line){
          
          if (line == null) line = nil;
          return "" + (range.$source_buffer().$name()) + ":" + (range.$line()) + ": " + (line);});
      }, -2);
      
      $def(self, '$first_line_only', function $$first_line_only(range) {
        
        if ($neqeq(range.$line(), range.$last_line())) {
          return range.$resize(range.$source()['$=~'](/\n/))
        } else {
          return range
        }
      });
      return $def(self, '$last_line_only', function $$last_line_only(range) {
        
        if ($neqeq(range.$line(), range.$last_line())) {
          return range.$adjust((new Map([["begin_pos", range.$source()['$=~'](/[^\n]*$/)]])))
        } else {
          return range
        }
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
});
