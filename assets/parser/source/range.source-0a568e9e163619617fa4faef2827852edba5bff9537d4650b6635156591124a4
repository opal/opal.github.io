Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $def = Opal.def, $rb_minus = Opal.rb_minus, $alias = Opal.alias, $neqeq = Opal.neqeq, $slice = Opal.slice, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $rb_ge = Opal.rb_ge, $rb_times = Opal.rb_times, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,<,raise,nil?,freeze,with,-,size,line_for_position,alias_method,column_for_position,!=,line,last_line,inspect,column,last_column,source_line,slice,include?,source,to_a,begin_pos,end_pos,decompose_position,join,name,+,new,min,max,disjoint?,empty?,>=,!,<=>,contains?,overlaps?,==,*,source_buffer,is_a?,nonzero?,hash');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Range');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.begin_pos = $proto.end_pos = $proto.source_buffer = nil;
        
        self.$include($$('Comparable'));
        self.$attr_reader("source_buffer");
        self.$attr_reader("begin_pos", "end_pos");
        
        $def(self, '$initialize', function $$initialize(source_buffer, begin_pos, end_pos) {
          var $a, self = this;

          
          if ($truthy($rb_lt(end_pos, begin_pos))) {
            self.$raise($$('ArgumentError'), "Parser::Source::Range: end_pos must not be less than begin_pos")
          };
          if ($truthy(source_buffer['$nil?']())) {
            self.$raise($$('ArgumentError'), "Parser::Source::Range: source_buffer must not be nil")
          };
          self.source_buffer = source_buffer;
          $a = [begin_pos, end_pos], (self.begin_pos = $a[0]), (self.end_pos = $a[1]), $a;
          return self.$freeze();
        });
        
        $def(self, '$begin', function $$begin() {
          var self = this;

          return self.$with((new Map([["end_pos", self.begin_pos]])))
        });
        
        $def(self, '$end', function $$end() {
          var self = this;

          return self.$with((new Map([["begin_pos", self.end_pos]])))
        });
        
        $def(self, '$size', function $$size() {
          var self = this;

          return $rb_minus(self.end_pos, self.begin_pos)
        });
        $alias(self, "length", "size");
        
        $def(self, '$line', function $$line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.begin_pos)
        });
        self.$alias_method("first_line", "line");
        
        $def(self, '$column', function $$column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.begin_pos)
        });
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.end_pos)
        });
        
        $def(self, '$last_column', function $$last_column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.end_pos)
        });
        
        $def(self, '$column_range', function $$column_range() {
          var self = this;

          
          if ($neqeq(self.$line(), self.$last_line())) {
            self.$raise($$('RangeError'), "" + (self.$inspect()) + " spans more than one line")
          };
          return Opal.Range.$new(self.$column(),self.$last_column(), true);
        });
        
        $def(self, '$source_line', function $$source_line() {
          var self = this;

          return self.source_buffer.$source_line(self.$line())
        });
        
        $def(self, '$source', function $$source() {
          var self = this;

          return self.source_buffer.$slice(self.begin_pos, $rb_minus(self.end_pos, self.begin_pos))
        });
        
        $def(self, '$is?', function $Range_is$ques$1($a) {
          var $post_args, what, self = this;

          
          $post_args = $slice(arguments);
          what = $post_args;
          return what['$include?'](self.$source());
        }, -1);
        
        $def(self, '$to_a', function $$to_a() {
          var self = this;

          return Opal.Range.$new(self.begin_pos,self.end_pos, true).$to_a()
        });
        
        $def(self, '$to_range', function $$to_range() {
          var self = this;

          return Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true)
        });
        
        $def(self, '$to_s', function $$to_s() {
          var $a, $b, self = this, line = nil, column = nil;

          
          $b = self.source_buffer.$decompose_position(self.begin_pos), $a = $to_ary($b), (line = ($a[0] == null ? nil : $a[0])), (column = ($a[1] == null ? nil : $a[1])), $b;
          return [self.source_buffer.$name(), line, $rb_plus(column, 1)].$join(":");
        });
        
        $def(self, '$with', function $Range_with$2($kwargs) {
          var begin_pos, end_pos, self = this;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          begin_pos = $hash_get($kwargs, "begin_pos");if (begin_pos == null) begin_pos = self.begin_pos;
          
          end_pos = $hash_get($kwargs, "end_pos");if (end_pos == null) end_pos = self.end_pos;
          return $$('Range').$new(self.source_buffer, begin_pos, end_pos);
        }, -1);
        
        $def(self, '$adjust', function $$adjust($kwargs) {
          var begin_pos, end_pos, self = this;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          begin_pos = $hash_get($kwargs, "begin_pos");if (begin_pos == null) begin_pos = 0;
          
          end_pos = $hash_get($kwargs, "end_pos");if (end_pos == null) end_pos = 0;
          return $$('Range').$new(self.source_buffer, $rb_plus(self.begin_pos, begin_pos), $rb_plus(self.end_pos, end_pos));
        }, -1);
        
        $def(self, '$resize', function $$resize(new_size) {
          var self = this;

          return self.$with((new Map([["end_pos", $rb_plus(self.begin_pos, new_size)]])))
        });
        
        $def(self, '$join', function $$join(other) {
          var self = this;

          return $$('Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$min(), [self.end_pos, other.$end_pos()].$max())
        });
        
        $def(self, '$intersect', function $$intersect(other) {
          var self = this;

          if ($truthy(self['$disjoint?'](other))) {
            return nil
          } else {
            return $$('Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$max(), [self.end_pos, other.$end_pos()].$min())
          }
        });
        
        $def(self, '$disjoint?', function $Range_disjoint$ques$3(other) {
          var self = this, $ret_or_1 = nil;

          if (($truthy(self['$empty?']()) && ($truthy(other['$empty?']())))) {
            return self.begin_pos['$!='](other.$begin_pos())
          } else if ($truthy(($ret_or_1 = $rb_ge(self.begin_pos, other.$end_pos())))) {
            return $ret_or_1
          } else {
            return $rb_ge(other.$begin_pos(), self.end_pos)
          }
        });
        
        $def(self, '$overlaps?', function $Range_overlaps$ques$4(other) {
          var self = this;

          return self['$disjoint?'](other)['$!']()
        });
        
        $def(self, '$contains?', function $Range_contains$ques$5(other) {
          var self = this;

          return $rb_ge($rb_plus(other.$begin_pos()['$<=>'](self.begin_pos), self.end_pos['$<=>'](other.$end_pos())), ($truthy(other['$empty?']()) ? (2) : (1)))
        });
        
        $def(self, '$contained?', function $Range_contained$ques$6(other) {
          var self = this;

          return other['$contains?'](self)
        });
        
        $def(self, '$crossing?', function $Range_crossing$ques$7(other) {
          var self = this;

          
          if (!$truthy(self['$overlaps?'](other))) {
            return false
          };
          return $rb_times(self.begin_pos['$<=>'](other.$begin_pos()), self.end_pos['$<=>'](other.$end_pos()))['$=='](1);
        });
        
        $def(self, '$empty?', function $Range_empty$ques$8() {
          var self = this;

          return self.begin_pos['$=='](self.end_pos)
        });
        
        $def(self, '$<=>', function $Range_$lt_eq_gt$9(other) {
          var self = this, $ret_or_1 = nil;

          
          if (!($truthy(other['$is_a?']($$$($$$($$$('Parser'), 'Source'), 'Range'))) && ($eqeq(self.source_buffer, other.$source_buffer())))) {
            return nil
          };
          if ($truthy(($ret_or_1 = self.begin_pos['$<=>'](other.$begin_pos())['$nonzero?']()))) {
            return $ret_or_1
          } else {
            
            return self.end_pos['$<=>'](other.$end_pos());
          };
        });
        self.$alias_method("eql?", "==");
        
        $def(self, '$hash', function $$hash() {
          var self = this;

          return [self.source_buffer, self.begin_pos, self.end_pos].$hash()
        });
        return $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<Parser::Source::Range " + (self.source_buffer.$name()) + " " + (self.begin_pos) + "..." + (self.end_pos) + ">"
        });
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
