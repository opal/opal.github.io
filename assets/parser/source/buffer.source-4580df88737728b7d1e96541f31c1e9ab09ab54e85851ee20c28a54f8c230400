Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $regexp = Opal.regexp, $enc = Opal.enc, $truthy = Opal.truthy, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $neqeq = Opal.neqeq, $defs = Opal.defs, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $send = Opal.send, $def = Opal.def, $not = Opal.not, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, $send2 = Opal.send2, $find_super = Opal.find_super, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,empty?,=~,start_with?,freeze,==,[],!=,nil?,match,find,encoding,recognize_encoding,force_encoding,encode,to_s,source=,open,read,raise,frozen?,dup,reencode_string,class,valid_encoding?,name,raw_source=,gsub,!,ascii_only?,is_a?,size,begin,line_index_for_position,line_begins,+,-,to_a,lines,end_with?,<<,each,chomp!,fetch,source_lines,>=,<,new,source,source_range,private,index,bsearch,[]=,method_defined?,bsearch_index');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Buffer');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.name = $proto.source = $proto.slice_source = $proto.first_line = $proto.lines = $proto.source_range = $proto.line_begins = $proto.line_index_for_position = $proto.line_range = nil;
        
        self.$attr_reader("name", "first_line");
        $const_set($nesting[0], 'ENCODING_RE', $regexp([$enc("[\\s#](en)?coding\\s*[:=]\\s*", "ASCII-8BIT"), $enc("(", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("(utf8-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+?)(-unix|-dos|-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+)", "ASCII-8BIT"), $enc(")", "ASCII-8BIT"), $enc("", "ASCII-8BIT")]));
        $defs(self, '$recognize_encoding', function $$recognize_encoding(string) {
          var $a, $b, first_line = nil, second_line = nil, encoding_line = nil, result = nil, $ret_or_1 = nil, $ret_or_2 = nil;

          
          if ($truthy(string['$empty?']())) {
            return nil
          };
          string['$=~'](/^(.*)\n?(.*\n)?/);
          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (first_line = $a[0]), (second_line = $a[1]), $a;
          if ($truthy(first_line['$start_with?']($enc("\xEF\xBB\xBF", "ASCII-8BIT").$freeze()))) {
            return $$$($$('Encoding'), 'UTF_8')
          } else if ($eqeq(first_line['$[]'](0, 2), $enc("#!", "ASCII-8BIT").$freeze())) {
            encoding_line = second_line
          } else {
            encoding_line = first_line
          };
          if (($truthy(encoding_line['$nil?']()) || ($neqeq(encoding_line['$[]'](0), $enc("#", "ASCII-8BIT"))))) {
            return nil
          };
          if ($truthy((result = $$('ENCODING_RE').$match(encoding_line)))) {
            return $$('Encoding').$find(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = result['$[]'](3))) ? ($ret_or_2) : (result['$[]'](4))))) ? ($ret_or_1) : (result['$[]'](6))))
          } else {
            return nil
          };
        });
        $defs(self, '$reencode_string', function $$reencode_string(input) {
          var self = this, original_encoding = nil, detected_encoding = nil;

          
          original_encoding = input.$encoding();
          detected_encoding = self.$recognize_encoding(input.$force_encoding($$$($$('Encoding'), 'BINARY')));
          if ($truthy(detected_encoding['$nil?']())) {
            return input.$force_encoding(original_encoding)
          } else if ($eqeq(detected_encoding, $$$($$('Encoding'), 'BINARY'))) {
            return input
          } else {
            return input.$force_encoding(detected_encoding).$encode($$$($$('Encoding'), 'UTF_8'))
          };
        });
        
        $def(self, '$initialize', function $$initialize(name, $a, $b) {
          var $post_args, $kwargs, first_line, source, $c, self = this;

          
          $post_args = $slice(arguments, 1);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          
          if ($post_args.length > 0) first_line = $post_args.shift();if (first_line == null) first_line = 1;
          
          source = $hash_get($kwargs, "source");if (source == null) source = nil;
          self.name = name.$to_s();
          self.source = nil;
          self.first_line = first_line;
          self.lines = nil;
          self.line_begins = nil;
          self.slice_source = nil;
          self.line_index_for_position = (new Map());
          if ($truthy(source)) {
            return ($c = [source], $send(self, 'source=', $c), $c[$c.length - 1])
          } else {
            return nil
          };
        }, -2);
        
        $def(self, '$read', function $$read() {
          var self = this;

          
          $send($$('File'), 'open', [self.name, $enc("rb", "ASCII-8BIT")], function $$1(io){var $a, self = $$1.$$s == null ? this : $$1.$$s;

            
            if (io == null) io = nil;
            return ($a = [io.$read()], $send(self, 'source=', $a), $a[$a.length - 1]);}, {$$s: self});
          return self;
        });
        
        $def(self, '$source', function $$source() {
          var self = this;

          
          if ($truthy(self.source['$nil?']())) {
            self.$raise($$('RuntimeError'), $enc("Cannot extract source from uninitialized Source::Buffer", "ASCII-8BIT"))
          };
          return self.source;
        });
        
        $def(self, '$source=', function $Buffer_source$eq$2(input) {
          var $a, self = this;

          
          if ($truthy(input['$frozen?']())) {
            input = input.$dup()
          };
          input = self.$class().$reencode_string(input);
          if (!$truthy(input['$valid_encoding?']())) {
            self.$raise($$('EncodingError'), $enc("invalid byte sequence in ", "ASCII-8BIT") + (input.$encoding().$name()))
          };
          return ($a = [input], $send(self, 'raw_source=', $a), $a[$a.length - 1]);
        });
        
        $def(self, '$raw_source=', function $Buffer_raw_source$eq$3(input) {
          var self = this;

          
          if ($truthy(self.source)) {
            self.$raise($$('ArgumentError'), $enc("Source::Buffer is immutable", "ASCII-8BIT"))
          };
          self.source = input.$gsub($enc("\r\n", "ASCII-8BIT").$freeze(), $enc("\n", "ASCII-8BIT").$freeze()).$freeze();
          if ((($not(self.source['$ascii_only?']()) && ($neqeq(self.source.$encoding(), $$$($$('Encoding'), 'UTF_32LE')))) && ($neqeq(self.source.$encoding(), $$$($$('Encoding'), 'BINARY'))))) {
            return (self.slice_source = self.source.$encode($$$($$('Encoding'), 'UTF_32LE')))
          } else {
            return nil
          };
        });
        
        $def(self, '$slice', function $$slice(start, length) {
          var self = this;

          
          if (length == null) length = nil;
          if ($truthy(length['$nil?']())) {
            if ($truthy(start['$is_a?']($$$('Range')))) {
              
              length = start.$size();
              start = start.$begin();
            } else {
              length = 1
            }
          };
          if ($truthy(self.slice_source['$nil?']())) {
            return self.source['$[]'](start, length)
          } else {
            return self.slice_source['$[]'](start, length).$encode(self.source.$encoding())
          };
        }, -2);
        
        $def(self, '$decompose_position', function $$decompose_position(position) {
          var self = this, line_index = nil, line_begin = nil;

          
          line_index = self.$line_index_for_position(position);
          line_begin = self.$line_begins()['$[]'](line_index);
          return [$rb_plus(self.first_line, line_index), $rb_minus(position, line_begin)];
        });
        
        $def(self, '$line_for_position', function $$line_for_position(position) {
          var self = this;

          return $rb_plus(self.$line_index_for_position(position), self.first_line)
        });
        
        $def(self, '$column_for_position', function $$column_for_position(position) {
          var self = this, line_index = nil;

          
          line_index = self.$line_index_for_position(position);
          return $rb_minus(position, self.$line_begins()['$[]'](line_index));
        });
        
        $def(self, '$source_lines', function $$source_lines() {
          var self = this, $ret_or_1 = nil, lines = nil;

          return (self.lines = ($truthy(($ret_or_1 = self.lines)) ? ($ret_or_1) : (((lines = self.source.$lines().$to_a()), ($truthy(self.source['$end_with?']($enc("\n", "ASCII-8BIT").$freeze())) ? (lines['$<<']($enc("", "ASCII-8BIT").$dup())) : nil), $send(lines, 'each', [], function $$4(line){
            
            if (line == null) line = nil;
            line['$chomp!']($enc("\n", "ASCII-8BIT").$freeze());
            return line.$freeze();}), lines.$freeze()))))
        });
        
        $def(self, '$source_line', function $$source_line(lineno) {
          var self = this;

          return self.$source_lines().$fetch($rb_minus(lineno, self.first_line)).$dup()
        });
        
        $def(self, '$line_range', function $$line_range(lineno) {
          var self = this, index = nil;

          
          index = $rb_minus(lineno, self.first_line);
          if (($truthy($rb_lt(index, 0)) || ($truthy($rb_ge($rb_plus(index, 1), self.$line_begins().$size()))))) {
            return self.$raise($$('IndexError'), $enc("Parser::Source::Buffer: range for line ", "ASCII-8BIT") + ("" + (lineno) + $enc(" requested, valid line numbers are ", "ASCII-8BIT") + (self.first_line) + $enc("..", "ASCII-8BIT")) + ("" + ($rb_minus($rb_plus(self.first_line, self.$line_begins().$size()), 2))))
          } else {
            return $$('Range').$new(self, self.$line_begins()['$[]'](index), $rb_minus(self.$line_begins()['$[]']($rb_plus(index, 1)), 1))
          };
        });
        
        $def(self, '$source_range', function $$source_range() {
          var self = this, $ret_or_1 = nil;

          return (self.source_range = ($truthy(($ret_or_1 = self.source_range)) ? ($ret_or_1) : ($$('Range').$new(self, 0, self.$source().$size()))))
        });
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return $rb_minus($rb_plus(self.$line_begins().$size(), self.first_line), 2)
        });
        
        $def(self, '$freeze', function $$freeze() {
          var $yield = $$freeze.$$p || nil, self = this;

          $$freeze.$$p = null;
          
          self.$source_lines();
          self.$line_begins();
          self.$source_range();
          return $send2(self, $find_super(self, 'freeze', $$freeze, false, true), 'freeze', [], $yield);
        });
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return $enc("#<", "ASCII-8BIT") + (self.$class()) + $enc(" ", "ASCII-8BIT") + (self.$name()) + $enc(">", "ASCII-8BIT")
        });
        self.$private();
        
        $def(self, '$line_begins', function $$line_begins() {
          var self = this, $ret_or_1 = nil, begins = nil, index = nil;

          return (self.line_begins = ($truthy(($ret_or_1 = self.line_begins)) ? ($ret_or_1) : ((function() {
          (begins = [0]);
          (index = 0);
          (function() {while ($truthy((index = self.source.$index($enc("\n", "ASCII-8BIT").$freeze(), index)))) {
          
            index = $rb_plus(index, 1);
            begins['$<<'](index);
          }; return nil; })();
          begins['$<<']($rb_plus(self.source.$size(), 1));
          return begins;})())))
        });
        
        $def(self, '$line_index_for_position', function $$line_index_for_position(position) {
          var self = this, $ret_or_1 = nil, index = nil;

          if ($truthy(($ret_or_1 = self.line_index_for_position['$[]'](position)))) {
            return $ret_or_1
          } else {
            
            index = $rb_minus(self.$bsearch(self.$line_begins(), position), 1);
            if (!$truthy(self.line_index_for_position['$frozen?']())) {
              self.line_index_for_position['$[]='](position, index)
            };
            return index;
          }
        });
        if ($truthy($$('Array')['$method_defined?']("bsearch_index"))) {
          return $def(self, '$bsearch', function $$bsearch(line_begins, position) {
            var $ret_or_1 = nil;

            if ($truthy(($ret_or_1 = $send(line_begins, 'bsearch_index', [], function $$5(line_begin){
              
              if (line_begin == null) line_begin = nil;
              return $rb_lt(position, line_begin);})))) {
              return $ret_or_1
            } else {
              return $rb_minus(line_begins.$size(), 1)
            }
          })
        } else {
          return $def(self, '$bsearch', function $$bsearch(line_begins, position) {
            var self = this, $ret_or_1 = nil;

            
            self.line_range = ($truthy(($ret_or_1 = self.line_range)) ? ($ret_or_1) : (Opal.Range.$new(0,line_begins.$size(), true)));
            if ($truthy(($ret_or_1 = $send(self.line_range, 'bsearch', [], function $$6(i){
              
              if (i == null) i = nil;
              return $rb_lt(position, line_begins['$[]'](i));})))) {
              return $ret_or_1
            } else {
              return $rb_minus(line_begins.$size(), 1)
            };
          })
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
