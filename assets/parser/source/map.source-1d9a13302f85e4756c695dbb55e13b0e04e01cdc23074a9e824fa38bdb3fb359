Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $assign_ivar = Opal.assign_ivar, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $send = Opal.send, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $range = Opal.range, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,freeze,line,alias_method,column,last_line,last_column,with,update_expression,==,class,reduce,map,instance_variables,instance_variable_get,send,inject,to_sym,[]=,[],protected,tap,dup,to_proc');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Map');

        var $proto = self.$$prototype;

        $proto.node = $proto.expression = nil;
        
        self.$attr_reader("node");
        self.$attr_reader("expression");
        
        $def(self, '$initialize', $assign_ivar("expression"));
        
        $def(self, '$initialize_copy', function $$initialize_copy(other) {
          var $yield = $$initialize_copy.$$p || nil, self = this;

          $$initialize_copy.$$p = null;
          
          $send2(self, $find_super(self, 'initialize_copy', $$initialize_copy, false, true), 'initialize_copy', [other], $yield);
          return (self.node = nil);
        });
        
        $def(self, '$node=', function $Map_node$eq$1(node) {
          var self = this;

          
          self.node = node;
          self.$freeze();
          return self.node;
        });
        
        $def(self, '$line', function $$line() {
          var self = this;

          return self.expression.$line()
        });
        self.$alias_method("first_line", "line");
        
        $def(self, '$column', function $$column() {
          var self = this;

          return self.expression.$column()
        });
        
        $def(self, '$last_line', function $$last_line() {
          var self = this;

          return self.expression.$last_line()
        });
        
        $def(self, '$last_column', function $$last_column() {
          var self = this;

          return self.expression.$last_column()
        });
        
        $def(self, '$with_expression', function $$with_expression(expression_l) {
          var self = this;

          return $send(self, 'with', [], function $$2(map){
            
            if (map == null) map = nil;
            return map.$update_expression(expression_l);})
        });
        
        $def(self, '$==', function $Map_$eq_eq$3(other) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = other.$class()['$=='](self.$class())))) {
            return $send(self.$instance_variables(), 'map', [], function $$4(ivar){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (ivar == null) ivar = nil;
              return self.$instance_variable_get(ivar)['$=='](other.$send("instance_variable_get", ivar));}, {$$s: self}).$reduce("&")
          } else {
            return $ret_or_1
          }
        });
        
        $def(self, '$to_hash', function $$to_hash() {
          var self = this;

          return $send(self.$instance_variables(), 'inject', [(new Map())], function $$5(hash, ivar){var self = $$5.$$s == null ? this : $$5.$$s;

            
            if (hash == null) hash = nil;
            if (ivar == null) ivar = nil;
            if ($eqeq(ivar.$to_sym(), "@node")) {
              return hash
            };
            hash['$[]='](ivar['$[]']($range(1, -1, false)).$to_sym(), self.$instance_variable_get(ivar));
            return hash;}, {$$s: self})
        });
        self.$protected();
        
        $def(self, '$with', function $Map_with$6() {
          var block = $Map_with$6.$$p || nil, self = this;

          $Map_with$6.$$p = null;
          
          ;
          return $send(self.$dup(), 'tap', [], block.$to_proc());
        });
        return $def(self, '$update_expression', $assign_ivar("expression"));
      })($nesting[0], null)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
