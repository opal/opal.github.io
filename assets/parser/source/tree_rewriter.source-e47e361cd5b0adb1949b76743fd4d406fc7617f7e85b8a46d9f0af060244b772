Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $lambda = Opal.lambda, $gvars = Opal.gvars, $def = Opal.def, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $return_ivar = Opal.return_ivar, $const_set = Opal.const_set, $eqeqeq = Opal.eqeqeq, $range = Opal.range, $to_ary = Opal.to_ary, $rb_minus = Opal.rb_minus, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $kwrestargs = Opal.kwrestargs, $slice = Opal.slice, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,new,consumer=,puts,render,freeze,check_policy_validity,method,adjust,source_range,empty?,==,source_buffer,raise,combine,action_root,merge!,dup,contract,+,begin_pos,range,end_pos,check_range_validity,moved,to_s,replace,wrap,source,each,ordered_replacements,<<,[],length,join,nested_actions,class,name,action_summary,warn_of_deprecation,insert_before,insert_after,extend,protected,private,as_replacements,===,size,first,map,to_range,inspect,-,values,>,<,trigger_policy,process');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TreeRewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.diagnostics = $proto.source_buffer = $proto.enforcer = $proto.action_root = $proto.in_transaction = $proto.policy = nil;
        
        self.$attr_reader("source_buffer");
        self.$attr_reader("diagnostics");
        
        $def(self, '$initialize', function $$initialize(source_buffer, $kwargs) {
          var crossing_deletions, different_replacements, swallowed_insertions, self = this, all_encompassing_range = nil;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          crossing_deletions = $hash_get($kwargs, "crossing_deletions");if (crossing_deletions == null) crossing_deletions = "accept";
          
          different_replacements = $hash_get($kwargs, "different_replacements");if (different_replacements == null) different_replacements = "accept";
          
          swallowed_insertions = $hash_get($kwargs, "swallowed_insertions");if (swallowed_insertions == null) swallowed_insertions = "accept";
          self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
          self.diagnostics['$consumer=']($lambda(function $$1(diag){            if ($gvars.stderr == null) $gvars.stderr = nil;

            
            if (diag == null) diag = nil;
            return $gvars.stderr.$puts(diag.$render());}));
          self.source_buffer = source_buffer;
          self.in_transaction = false;
          self.policy = (new Map([["crossing_deletions", crossing_deletions], ["different_replacements", different_replacements], ["swallowed_insertions", swallowed_insertions]])).$freeze();
          self.$check_policy_validity();
          self.enforcer = self.$method("enforce_policy");
          all_encompassing_range = self.source_buffer.$source_range().$adjust((new Map([["begin_pos", -1], ["end_pos", 1]])));
          return (self.action_root = $$$($$('TreeRewriter'), 'Action').$new(all_encompassing_range, self.enforcer));
        }, -2);
        
        $def(self, '$empty?', function $TreeRewriter_empty$ques$2() {
          var self = this;

          return self.action_root['$empty?']()
        });
        
        $def(self, '$merge!', function $TreeRewriter_merge$excl$3(with$) {
          var self = this;

          
          if (!$eqeq(self.$source_buffer(), with$.$source_buffer())) {
            self.$raise("TreeRewriter are not for the same source_buffer")
          };
          self.action_root = self.action_root.$combine(with$.$action_root());
          return self;
        });
        
        $def(self, '$merge', function $$merge(with$) {
          var self = this;

          return self.$dup()['$merge!'](with$)
        });
        
        $def(self, '$import!', function $TreeRewriter_import$excl$4(foreign_rewriter, $kwargs) {
          var offset, self = this, contracted = nil, merge_effective_range = nil, merge_with = nil;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          offset = $hash_get($kwargs, "offset");if (offset == null) offset = 0;
          if ($truthy(foreign_rewriter['$empty?']())) {
            return self
          };
          contracted = foreign_rewriter.$action_root().$contract();
          merge_effective_range = $$$($$$($$$('Parser'), 'Source'), 'Range').$new(self.source_buffer, $rb_plus(contracted.$range().$begin_pos(), offset), $rb_plus(contracted.$range().$end_pos(), offset));
          self.$check_range_validity(merge_effective_range);
          merge_with = contracted.$moved(self.source_buffer, offset);
          self.action_root = self.action_root.$combine(merge_with);
          return self;
        }, -2);
        
        $def(self, '$replace', function $$replace(range, content) {
          var self = this;

          return self.$combine(range, (new Map([["replacement", content]])))
        });
        
        $def(self, '$wrap', function $$wrap(range, insert_before, insert_after) {
          var self = this;

          return self.$combine(range, (new Map([["insert_before", insert_before.$to_s()], ["insert_after", insert_after.$to_s()]])))
        });
        
        $def(self, '$remove', function $$remove(range) {
          var self = this;

          return self.$replace(range, "".$freeze())
        });
        
        $def(self, '$insert_before', function $$insert_before(range, content) {
          var self = this;

          return self.$wrap(range, content, nil)
        });
        
        $def(self, '$insert_after', function $$insert_after(range, content) {
          var self = this;

          return self.$wrap(range, nil, content)
        });
        
        $def(self, '$process', function $$process() {
          var self = this, source = nil, chunks = nil, last_end = nil;

          
          source = self.source_buffer.$source();
          chunks = [];
          last_end = 0;
          $send(self.action_root.$ordered_replacements(), 'each', [], function $$5(range, replacement){
            
            if (range == null) range = nil;
            if (replacement == null) replacement = nil;
            chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,range.$begin_pos(), true)))['$<<'](replacement);
            return (last_end = range.$end_pos());});
          chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,source.$length(), true)));
          return chunks.$join();
        });
        
        $def(self, '$as_replacements', function $$as_replacements() {
          var self = this;

          return self.action_root.$ordered_replacements()
        });
        
        $def(self, '$as_nested_actions', function $$as_nested_actions() {
          var self = this;

          return self.action_root.$nested_actions()
        });
        
        $def(self, '$transaction', function $$transaction() {
          var $yield = $$transaction.$$p || nil, self = this, previous = nil, restore_root = nil;

          $$transaction.$$p = null;
          return (function() { try {
          
          if (!($yield !== nil)) {
            self.$raise("" + (self.$class()) + "#" + ("transaction") + " requires block")
          };
          previous = self.in_transaction;
          self.in_transaction = true;
          restore_root = self.action_root;
          Opal.yieldX($yield, []);
          restore_root = nil;
          return self;
          } finally {
            (($truthy(restore_root) ? ((self.action_root = restore_root)) : nil), (self.in_transaction = previous))
          }; })()
        });
        
        $def(self, '$in_transaction?', $return_ivar("in_transaction"));
        
        $def(self, '$inspect', function $$inspect() {
          var self = this;

          return "#<" + (self.$class()) + " " + (self.$source_buffer().$name()) + ": " + (self.$action_summary()) + ">"
        });
        
        $def(self, '$insert_before_multi', function $$insert_before_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_before(range, text);
        });
        
        $def(self, '$insert_after_multi', function $$insert_after_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_after(range, text);
        });
        $const_set($nesting[0], 'DEPRECATION_WARNING', ["TreeRewriter#insert_before_multi and insert_before_multi exist only for legacy compatibility.", "Please update your code to use `wrap`, `insert_before` or `insert_after` instead."].$join("\n").$freeze());
        self.$extend($$('Deprecation'));
        self.$protected();
        self.$attr_reader("action_root");
        self.$private();
        
        $def(self, '$action_summary', function $$action_summary() {
          var self = this, replacements = nil, $ret_or_1 = nil, suffix = nil, parts = nil;

          
          replacements = self.$as_replacements();
          if ($eqeqeq(0, ($ret_or_1 = replacements.$size()))) {
            return "empty"
          } else if (!$eqeqeq($range(1, 3, false), $ret_or_1)) {
            
            replacements = replacements.$first(3);
            suffix = "â€¦";
          };
          parts = $send(replacements, 'map', [], function $$6($mlhs_tmp1){var $a, $b, range = nil, str = nil;

            
            if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;
            $b = $mlhs_tmp1, $a = $to_ary($b), (range = ($a[0] == null ? nil : $a[0])), (str = ($a[1] == null ? nil : $a[1])), $b;
            if ($truthy(str['$empty?']())) {
              return "-" + (range.$to_range())
            } else if ($eqeq(range.$size(), 0)) {
              return "+" + (str.$inspect()) + "@" + (range.$begin_pos())
            } else {
              return "^" + (str.$inspect()) + "@" + (range.$to_range())
            };}, {$$has_top_level_mlhs_arg: true});
          if ($truthy(suffix)) {
            parts['$<<'](suffix)
          };
          return parts.$join(", ");
        });
        $const_set($nesting[0], 'ACTIONS', ["accept", "warn", "raise"].$freeze());
        
        $def(self, '$check_policy_validity', function $$check_policy_validity() {
          var self = this, invalid = nil;

          
          invalid = $rb_minus(self.policy.$values(), $$('ACTIONS'));
          if ($truthy(invalid['$empty?']())) {
            return nil
          } else {
            return self.$raise($$('ArgumentError'), "Invalid policy: " + (invalid.$join(", ")))
          };
        });
        
        $def(self, '$combine', function $$combine(range, attributes) {
          var self = this, action = nil;

          
          range = self.$check_range_validity(range);
          action = $$$($$('TreeRewriter'), 'Action').$new(range, self.enforcer, Opal.to_hash(attributes));
          self.action_root = self.action_root.$combine(action);
          return self;
        });
        
        $def(self, '$check_range_validity', function $$check_range_validity(range) {
          var self = this;

          
          if (($truthy($rb_lt(range.$begin_pos(), 0)) || ($truthy($rb_gt(range.$end_pos(), self.source_buffer.$source().$size()))))) {
            self.$raise($$('IndexError'), "The range " + (range.$to_range()) + " is outside the bounds of the source")
          };
          return range;
        });
        
        $def(self, '$enforce_policy', function $$enforce_policy(event) {
          var $yield = $$enforce_policy.$$p || nil, self = this, values = nil;

          $$enforce_policy.$$p = null;
          
          if ($eqeq(self.policy['$[]'](event), "accept")) {
            return nil
          };
          if (!$truthy((values = Opal.yieldX($yield, [])))) {
            return nil
          };
          return self.$trigger_policy(event, Opal.to_hash(values));
        });
        $const_set($nesting[0], 'POLICY_TO_LEVEL', (new Map([["warn", "warning"], ["raise", "error"]])).$freeze());
        return $def(self, '$trigger_policy', function $$trigger_policy(event, $kwargs) {
          var range, conflict, arguments$, $a, $b, self = this, action = nil, $ret_or_1 = nil, diag = nil, highlights = nil;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          range = $hash_get($kwargs, "range");if (range == null) range = self.$raise();
          
          conflict = $hash_get($kwargs, "conflict");if (conflict == null) conflict = nil;
          arguments$ = $kwrestargs($kwargs, {'range': true,'conflict': true});
          action = ($truthy(($ret_or_1 = self.policy['$[]'](event))) ? ($ret_or_1) : ("raise"));
          diag = $$$($$('Parser'), 'Diagnostic').$new($$('POLICY_TO_LEVEL')['$[]'](action), event, arguments$, range);
          self.diagnostics.$process(diag);
          if ($truthy(conflict)) {
            
            $b = conflict, $a = $to_ary($b), (range = ($a[0] == null ? nil : $a[0])), (highlights = $slice($a, 1)), $b;
            diag = $$$($$('Parser'), 'Diagnostic').$new($$('POLICY_TO_LEVEL')['$[]'](action), "" + (event) + "_conflict", arguments$, range, highlights);
            self.diagnostics.$process(diag);
          };
          if ($eqeq(action, "raise")) {
            return self.$raise($$$($$('Parser'), 'ClobberingError'), "Parser::Source::TreeRewriter detected clobbering")
          } else {
            return nil
          };
        }, -2);
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
