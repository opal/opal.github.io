Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $def = Opal.def, $rb_minus = Opal.rb_minus, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $not = Opal.not, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $rb_ge = Opal.rb_ge, $rb_lt = Opal.rb_lt, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,warn_of_deprecation,class,new,consumer=,lambda,puts,render,append,freeze,begin,end,-,+,in_transaction?,raise,dup,source,each,sort,begin_pos,range,length,[]=,replacement,private,empty?,clobbered_insertion?,!,allow_multiple_insertions?,raise_clobber_error,record_insertion,adjacent_updates?,find,overlaps?,replace_compatible_with_insertion?,merge_actions!,<<,active_queue,adjacent_insertions?,merge_actions,delete,can_merge?,record_replace,active_insertions=,|,active_insertions,active_clobber=,active_clobber,clobbered_position_mask,size,!=,&,<=,end_pos,adjacent_insertion_mask,select,adjacent?,adjacent_position_mask,>=,==,[],all?,intersect,nil?,max,sort_by,push,join,first,max_by,merge_replacements,replace_actions,disjoint?,<,process,extend');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rewriter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.diagnostics = $proto.insert_before_multi_order = $proto.insert_after_multi_order = $proto.source_buffer = $proto.queue = $proto.clobber = $proto.insertions = $proto.pending_queue = $proto.pending_clobber = $proto.pending_insertions = nil;
        
        self.$attr_reader("source_buffer");
        self.$attr_reader("diagnostics");
        
        $def(self, '$initialize', function $$initialize(source_buffer) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
          self.diagnostics['$consumer=']($send(self, 'lambda', [], function $$1(diag){            if ($gvars.stderr == null) $gvars.stderr = nil;

            
            if (diag == null) diag = nil;
            return $gvars.stderr.$puts(diag.$render());}));
          self.source_buffer = source_buffer;
          self.queue = [];
          self.clobber = 0;
          self.insertions = 0;
          self.insert_before_multi_order = 0;
          self.insert_after_multi_order = 0;
          self.pending_queue = nil;
          self.pending_clobber = nil;
          return (self.pending_insertions = nil);
        });
        
        $def(self, '$remove', function $$remove(range) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range, "".$freeze()))
        });
        
        $def(self, '$insert_before', function $$insert_before(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), content))
        });
        
        $def(self, '$wrap', function $$wrap(range, before, after) {
          var self = this;

          
          self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), before));
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), after));
        });
        
        $def(self, '$insert_before_multi', function $$insert_before_multi(range, content) {
          var self = this;

          
          self.insert_before_multi_order = $rb_minus(self.insert_before_multi_order, 1);
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$begin(), content, true, self.insert_before_multi_order));
        });
        
        $def(self, '$insert_after', function $$insert_after(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), content))
        });
        
        $def(self, '$insert_after_multi', function $$insert_after_multi(range, content) {
          var self = this;

          
          self.insert_after_multi_order = $rb_plus(self.insert_after_multi_order, 1);
          return self.$append($$$($$('Rewriter'), 'Action').$new(range.$end(), content, true, self.insert_after_multi_order));
        });
        
        $def(self, '$replace', function $$replace(range, content) {
          var self = this;

          return self.$append($$$($$('Rewriter'), 'Action').$new(range, content))
        });
        
        $def(self, '$process', function $$process() {
          var self = this, adjustment = nil, source = nil;

          
          if ($truthy(self['$in_transaction?']())) {
            self.$raise("Do not call " + (self.$class()) + "#" + ("process") + " inside a transaction")
          };
          adjustment = 0;
          source = self.source_buffer.$source().$dup();
          $send(self.queue.$sort(), 'each', [], function $$2(action){var begin_pos = nil, end_pos = nil;

            
            if (action == null) action = nil;
            begin_pos = $rb_plus(action.$range().$begin_pos(), adjustment);
            end_pos = $rb_plus(begin_pos, action.$range().$length());
            source['$[]='](Opal.Range.$new(begin_pos,end_pos, true), action.$replacement());
            return (adjustment = $rb_plus(adjustment, $rb_minus(action.$replacement().$length(), action.$range().$length())));});
          return source;
        });
        
        $def(self, '$transaction', function $$transaction() {
          var $yield = $$transaction.$$p || nil, self = this;

          $$transaction.$$p = null;
          return (function() { try {
          
          if (!($yield !== nil)) {
            self.$raise("" + (self.$class()) + "#" + ("transaction") + " requires block")
          };
          if ($truthy(self['$in_transaction?']())) {
            self.$raise("Nested transaction is not supported")
          };
          self.pending_queue = self.queue.$dup();
          self.pending_clobber = self.clobber;
          self.pending_insertions = self.insertions;
          Opal.yieldX($yield, []);
          self.queue = self.pending_queue;
          self.clobber = self.pending_clobber;
          self.insertions = self.pending_insertions;
          return self;
          } finally {
            ((self.pending_queue = nil), (self.pending_clobber = nil), (self.pending_insertions = nil))
          }; })()
        });
        self.$private();
        
        $def(self, '$append', function $$append(action) {
          var self = this, range = nil, conflicting = nil, adjacent = nil, insertions = nil;

          
          range = action.$range();
          if ($truthy(range['$empty?']())) {
            
            if ($truthy(action.$replacement()['$empty?']())) {
              return self
            };
            if (($not(action['$allow_multiple_insertions?']()) && ($truthy((conflicting = self['$clobbered_insertion?'](range)))))) {
              self.$raise_clobber_error(action, [conflicting])
            };
            self.$record_insertion(range);
            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {
              
              conflicting = $send(adjacent, 'find', [], function $$3(a){var self = $$3.$$s == null ? this : $$3.$$s, $ret_or_1 = nil;

                
                if (a == null) a = nil;
                if ($truthy(($ret_or_1 = a.$range()['$overlaps?'](range)))) {
                  return self['$replace_compatible_with_insertion?'](a, action)['$!']()
                } else {
                  return $ret_or_1
                };}, {$$s: self});
              if ($truthy(conflicting)) {
                self.$raise_clobber_error(action, [conflicting])
              };
              self['$merge_actions!'](action, adjacent);
            } else {
              self.$active_queue()['$<<'](action)
            };
          } else {
            
            if ($truthy((insertions = self['$adjacent_insertions?'](range)))) {
              $send(insertions, 'each', [], function $$4(insertion){var self = $$4.$$s == null ? this : $$4.$$s;

                
                if (insertion == null) insertion = nil;
                if (($truthy(range['$overlaps?'](insertion.$range())) && ($not(self['$replace_compatible_with_insertion?'](action, insertion))))) {
                  return self.$raise_clobber_error(action, [insertion])
                } else {
                  
                  action = self.$merge_actions(action, [insertion]);
                  return self.$active_queue().$delete(insertion);
                };}, {$$s: self})
            };
            if ($truthy((adjacent = self['$adjacent_updates?'](range)))) {
              if ($truthy(self['$can_merge?'](action, adjacent))) {
                
                self.$record_replace(range);
                self['$merge_actions!'](action, adjacent);
              } else {
                self.$raise_clobber_error(action, adjacent)
              }
            } else {
              
              self.$record_replace(range);
              self.$active_queue()['$<<'](action);
            };
          };
          return self;
        });
        
        $def(self, '$record_insertion', function $$record_insertion(range) {
          var $a, self = this;

          return ($a = [self.$active_insertions()['$|']((1)['$<<'](range.$begin_pos()))], $send(self, 'active_insertions=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$record_replace', function $$record_replace(range) {
          var $a, self = this;

          return ($a = [self.$active_clobber()['$|'](self.$clobbered_position_mask(range))], $send(self, 'active_clobber=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$clobbered_position_mask', function $$clobbered_position_mask(range) {
          
          return $rb_minus((1)['$<<'](range.$size()), 1)['$<<'](range.$begin_pos())
        });
        
        $def(self, '$adjacent_position_mask', function $$adjacent_position_mask(range) {
          
          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 2)), 1)['$<<']($rb_minus(range.$begin_pos(), 1))
        });
        
        $def(self, '$adjacent_insertion_mask', function $$adjacent_insertion_mask(range) {
          
          return $rb_minus((1)['$<<']($rb_plus(range.$size(), 1)), 1)['$<<'](range.$begin_pos())
        });
        
        $def(self, '$clobbered_insertion?', function $Rewriter_clobbered_insertion$ques$5(insertion) {
          var self = this, insertion_pos = nil;

          
          insertion_pos = insertion.$begin_pos();
          if ($neqeq(self.$active_insertions()['$&']((1)['$<<'](insertion_pos)), 0)) {
            return $send(self.$active_queue(), 'find', [], function $$6(a){var $ret_or_1 = nil;

              
              if (a == null) a = nil;
              if ($truthy(($ret_or_1 = $rb_le(a.$range().$begin_pos(), insertion_pos)))) {
                return $rb_le(insertion_pos, a.$range().$end_pos())
              } else {
                return $ret_or_1
              };})
          } else {
            return nil
          };
        });
        
        $def(self, '$adjacent_insertions?', function $Rewriter_adjacent_insertions$ques$7(range) {
          var self = this, result = nil;

          if ($neqeq(self.$active_insertions()['$&'](self.$adjacent_insertion_mask(range)), 0)) {
            
            result = $send(self.$active_queue(), 'select', [], function $$8(a){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;

              
              if (a == null) a = nil;
              if ($truthy(($ret_or_1 = a.$range()['$empty?']()))) {
                return self['$adjacent?'](range, a.$range())
              } else {
                return $ret_or_1
              };}, {$$s: self});
            if ($truthy(result['$empty?']())) {
              return nil
            } else {
              return result
            };
          } else {
            return nil
          }
        });
        
        $def(self, '$adjacent_updates?', function $Rewriter_adjacent_updates$ques$9(range) {
          var self = this;

          if ($neqeq(self.$active_clobber()['$&'](self.$adjacent_position_mask(range)), 0)) {
            return $send(self.$active_queue(), 'select', [], function $$10(a){var self = $$10.$$s == null ? this : $$10.$$s;

              
              if (a == null) a = nil;
              return self['$adjacent?'](range, a.$range());}, {$$s: self})
          } else {
            return nil
          }
        });
        
        $def(self, '$replace_compatible_with_insertion?', function $Rewriter_replace_compatible_with_insertion$ques$11(replace, insertion) {
          var $ret_or_1 = nil, $ret_or_2 = nil, offset = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $rb_ge($rb_minus(replace.$replacement().$length(), replace.$range().$size()), insertion.$range().$size()))) ? ((offset = $rb_minus(insertion.$range().$begin_pos(), replace.$range().$begin_pos()))) : ($ret_or_2))))) {
            return replace.$replacement()['$[]'](offset, insertion.$replacement().$length())['$=='](insertion.$replacement())
          } else {
            return $ret_or_1
          }
        });
        
        $def(self, '$can_merge?', function $Rewriter_can_merge$ques$12(action, existing) {
          var range = nil;

          
          range = action.$range();
          return $send(existing, 'all?', [], function $$13(other){var overlap = nil, repl1_offset = nil, repl2_offset = nil, repl1_length = nil, repl2_length = nil, replacement1 = nil, $ret_or_1 = nil, replacement2 = nil;

            
            if (other == null) other = nil;
            overlap = range.$intersect(other.$range());
            if ($truthy(overlap['$nil?']())) {
              return true
            };
            repl1_offset = $rb_minus(overlap.$begin_pos(), range.$begin_pos());
            repl2_offset = $rb_minus(overlap.$begin_pos(), other.$range().$begin_pos());
            repl1_length = [$rb_minus(other.$range().$length(), repl2_offset), $rb_minus(other.$replacement().$length(), repl2_offset)].$max();
            repl2_length = [$rb_minus(range.$length(), repl1_offset), $rb_minus(action.$replacement().$length(), repl1_offset)].$max();
            replacement1 = ($truthy(($ret_or_1 = action.$replacement()['$[]'](repl1_offset, repl1_length))) ? ($ret_or_1) : ("".$freeze()));
            replacement2 = ($truthy(($ret_or_1 = other.$replacement()['$[]'](repl2_offset, repl2_length))) ? ($ret_or_1) : ("".$freeze()));
            return replacement1['$=='](replacement2);});
        });
        
        $def(self, '$merge_actions', function $$merge_actions(action, existing) {
          var self = this, actions = nil, range = nil;

          
          actions = $send(existing.$push(action), 'sort_by', [], function $$14(a){
            
            if (a == null) a = nil;
            return [a.$range().$begin_pos(), a.$range().$end_pos()];});
          range = actions.$first().$range().$join($send(actions, 'max_by', [], function $$15(a){
            
            if (a == null) a = nil;
            return a.$range().$end_pos();}).$range());
          return $$$($$('Rewriter'), 'Action').$new(range, self.$merge_replacements(actions));
        });
        
        $def(self, '$merge_actions!', function $Rewriter_merge_actions$excl$16(action, existing) {
          var self = this, new_action = nil;

          
          new_action = self.$merge_actions(action, existing);
          self.$active_queue().$delete(action);
          return self.$replace_actions(existing, new_action);
        });
        
        $def(self, '$merge_replacements', function $$merge_replacements(actions) {
          var result = nil, prev_act = nil;

          
          result = "".$dup();
          prev_act = nil;
          $send(actions, 'each', [], function $$17(act){var prev_end = nil, offset = nil;

            
            if (act == null) act = nil;
            if (($not(prev_act) || ($truthy(act.$range()['$disjoint?'](prev_act.$range()))))) {
              result['$<<'](act.$replacement())
            } else {
              
              prev_end = [$rb_plus(prev_act.$range().$begin_pos(), prev_act.$replacement().$length()), prev_act.$range().$end_pos()].$max();
              offset = $rb_minus(prev_end, act.$range().$begin_pos());
              if ($truthy($rb_lt(offset, act.$replacement().$size()))) {
                result['$<<'](act.$replacement()['$[]'](Opal.Range.$new(offset, -1, false)))
              };
            };
            return (prev_act = act);});
          return result;
        });
        
        $def(self, '$replace_actions', function $$replace_actions(old, updated) {
          var self = this;

          
          $send(old, 'each', [], function $$18(act){var self = $$18.$$s == null ? this : $$18.$$s;

            
            if (act == null) act = nil;
            return self.$active_queue().$delete(act);}, {$$s: self});
          return self.$active_queue()['$<<'](updated);
        });
        
        $def(self, '$raise_clobber_error', function $$raise_clobber_error(action, existing) {
          var self = this, diagnostic = nil;

          
          diagnostic = $$('Diagnostic').$new("error", "invalid_action", (new Map([["action", action]])), action.$range());
          self.diagnostics.$process(diagnostic);
          diagnostic = $$('Diagnostic').$new("note", "clobbered", (new Map([["action", existing['$[]'](0)]])), existing['$[]'](0).$range());
          self.diagnostics.$process(diagnostic);
          return self.$raise($$('ClobberingError'), "Parser::Source::Rewriter detected clobbering");
        });
        
        $def(self, '$in_transaction?', function $Rewriter_in_transaction$ques$19() {
          var self = this;

          return self.pending_queue['$nil?']()['$!']()
        });
        
        $def(self, '$active_queue', function $$active_queue() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_queue))) {
            return $ret_or_1
          } else {
            return self.queue
          }
        });
        
        $def(self, '$active_clobber', function $$active_clobber() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_clobber))) {
            return $ret_or_1
          } else {
            return self.clobber
          }
        });
        
        $def(self, '$active_insertions', function $$active_insertions() {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.pending_insertions))) {
            return $ret_or_1
          } else {
            return self.insertions
          }
        });
        
        $def(self, '$active_clobber=', function $Rewriter_active_clobber$eq$20(value) {
          var self = this;

          if ($truthy(self.pending_clobber)) {
            return (self.pending_clobber = value)
          } else {
            return (self.clobber = value)
          }
        });
        
        $def(self, '$active_insertions=', function $Rewriter_active_insertions$eq$21(value) {
          var self = this;

          if ($truthy(self.pending_insertions)) {
            return (self.pending_insertions = value)
          } else {
            return (self.insertions = value)
          }
        });
        
        $def(self, '$adjacent?', function $Rewriter_adjacent$ques$22(range1, range2) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = $rb_le(range1.$begin_pos(), range2.$end_pos())))) {
            return $rb_le(range2.$begin_pos(), range1.$end_pos())
          } else {
            return $ret_or_1
          }
        });
        $const_set($nesting[0], 'DEPRECATION_WARNING', ["Parser::Source::Rewriter is deprecated.", "Please update your code to use Parser::Source::TreeRewriter instead"].$join("\n").$freeze());
        return self.$extend($$('Deprecation'));
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
