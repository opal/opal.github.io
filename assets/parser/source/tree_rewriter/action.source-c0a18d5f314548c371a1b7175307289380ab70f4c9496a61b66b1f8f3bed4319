Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $ensure_kwargs = Opal.ensure_kwargs, $hash_get = Opal.hash_get, $def = Opal.def, $truthy = Opal.truthy, $send = Opal.send, $not = Opal.not, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $to_a = Opal.to_a, $rb_gt = Opal.rb_gt, $rb_minus = Opal.rb_minus, $rb_ge = Opal.rb_ge, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $slice = Opal.slice, $neqeq = Opal.neqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,freeze,empty?,do_combine,==,<<,begin,concat,flat_map,to_proc,end,!,insert_before,insert_after,replacement,raise,insertion?,with,begin_pos,range,first,children,end_pos,last,new,+,map,moved,protected,swallow,class,merge,place_in_hierarchy,analyse_hierarchy,[],fuse_deletions,combine_children,inject,size,bsearch,bsearch_child_index,>,-,>=,<=>,<=,check_fusible,<,shift,pop,compact!,each,call,call_enforcer_for_merge,!=,select');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super) {
        var self = $klass($base, $super, 'Action');

        var $proto = self.$$prototype;

        $proto.insert_before = $proto.insert_after = $proto.children = $proto.replacement = $proto.range = $proto.enforcer = nil;
        
        self.$attr_reader("range", "replacement", "insert_before", "insert_after");
        
        $def(self, '$initialize', function $$initialize(range, enforcer, $kwargs) {
          var insert_before, replacement, insert_after, children, $a, self = this;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          insert_before = $hash_get($kwargs, "insert_before");if (insert_before == null) insert_before = "";
          
          replacement = $hash_get($kwargs, "replacement");if (replacement == null) replacement = nil;
          
          insert_after = $hash_get($kwargs, "insert_after");if (insert_after == null) insert_after = "";
          
          children = $hash_get($kwargs, "children");if (children == null) children = [];
          $a = [range, enforcer, children.$freeze(), insert_before.$freeze(), replacement, insert_after.$freeze()], (self.range = $a[0]), (self.enforcer = $a[1]), (self.children = $a[2]), (self.insert_before = $a[3]), (self.replacement = $a[4]), (self.insert_after = $a[5]), $a;
          return self.$freeze();
        }, -3);
        
        $def(self, '$combine', function $$combine(action) {
          var self = this;

          
          if ($truthy(action['$empty?']())) {
            return self
          };
          return self.$do_combine(action);
        });
        
        $def(self, '$empty?', function $Action_empty$ques$1() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.insert_before['$empty?']())) ? (self.insert_after['$empty?']()) : ($ret_or_3)))) ? (self.children['$empty?']()) : ($ret_or_2))))) {
            
            if ($truthy(($ret_or_2 = self.replacement['$=='](nil)))) {
              return $ret_or_2
            } else {
              
              if ($truthy(($ret_or_3 = self.replacement['$empty?']()))) {
                return self.range['$empty?']()
              } else {
                return $ret_or_3
              };
            };
          } else {
            return $ret_or_1
          }
        });
        
        $def(self, '$ordered_replacements', function $$ordered_replacements() {
          var self = this, reps = nil;

          
          reps = [];
          if (!$truthy(self.insert_before['$empty?']())) {
            reps['$<<']([self.range.$begin(), self.insert_before])
          };
          if ($truthy(self.replacement)) {
            reps['$<<']([self.range, self.replacement])
          };
          reps.$concat($send(self.children, 'flat_map', [], "ordered_replacements".$to_proc()));
          if (!$truthy(self.insert_after['$empty?']())) {
            reps['$<<']([self.range.$end(), self.insert_after])
          };
          return reps;
        });
        
        $def(self, '$nested_actions', function $$nested_actions() {
          var self = this, actions = nil;

          
          actions = [];
          if (($not(self.insert_before['$empty?']()) || ($not(self.insert_after['$empty?']())))) {
            actions['$<<'](["wrap", self.range, self.insert_before, self.insert_after])
          };
          if ($truthy(self.replacement)) {
            actions['$<<'](["replace", self.range, self.replacement])
          };
          return actions.$concat($send(self.children, 'flat_map', [], "nested_actions".$to_proc()));
        });
        
        $def(self, '$insertion?', function $Action_insertion$ques$2() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.$insert_before()['$empty?']()['$!']())) ? ($ret_or_2) : (self.$insert_after()['$empty?']()['$!']()))))) {
            return $ret_or_1
          } else {
            
            if ($truthy(($ret_or_2 = self.$replacement()))) {
              return self.$replacement()['$empty?']()['$!']()
            } else {
              return $ret_or_2
            };
          }
        });
        
        $def(self, '$contract', function $$contract() {
          var self = this, range = nil;

          
          if ($truthy(self['$empty?']())) {
            self.$raise("Empty actions can not be contracted")
          };
          if ($truthy(self['$insertion?']())) {
            return self
          };
          range = self.range.$with((new Map([["begin_pos", self.$children().$first().$range().$begin_pos()], ["end_pos", self.$children().$last().$range().$end_pos()]])));
          return self.$with((new Map([["range", range]])));
        });
        
        $def(self, '$moved', function $$moved(source_buffer, offset) {
          var self = this, moved_range = nil;

          
          moved_range = $$$($$$($$$('Parser'), 'Source'), 'Range').$new(source_buffer, $rb_plus(self.range.$begin_pos(), offset), $rb_plus(self.range.$end_pos(), offset));
          return self.$with((new Map([["range", moved_range], ["children", $send(self.$children(), 'map', [], function $$3(child){
            
            if (child == null) child = nil;
            return child.$moved(source_buffer, offset);})]])));
        });
        self.$protected();
        self.$attr_reader("children");
        
        $def(self, '$with', function $Action_with$4($kwargs) {
          var range, enforcer, children, insert_before, replacement, insert_after, self = this;

          
          $kwargs = $ensure_kwargs($kwargs);
          
          range = $hash_get($kwargs, "range");if (range == null) range = self.range;
          
          enforcer = $hash_get($kwargs, "enforcer");if (enforcer == null) enforcer = self.enforcer;
          
          children = $hash_get($kwargs, "children");if (children == null) children = self.children;
          
          insert_before = $hash_get($kwargs, "insert_before");if (insert_before == null) insert_before = self.insert_before;
          
          replacement = $hash_get($kwargs, "replacement");if (replacement == null) replacement = self.replacement;
          
          insert_after = $hash_get($kwargs, "insert_after");if (insert_after == null) insert_after = self.insert_after;
          if ($truthy(replacement)) {
            children = self.$swallow(children)
          };
          return self.$class().$new(range, enforcer, (new Map([["children", children], ["insert_before", insert_before], ["replacement", replacement], ["insert_after", insert_after]])));
        }, -1);
        
        $def(self, '$do_combine', function $$do_combine(action) {
          var self = this;

          if ($eqeq(action.$range(), self.range)) {
            return self.$merge(action)
          } else {
            return self.$place_in_hierarchy(action)
          }
        });
        
        $def(self, '$place_in_hierarchy', function $$place_in_hierarchy(action) {
          var self = this, family = nil, extra_sibbling = nil;

          
          family = self.$analyse_hierarchy(action);
          if ($truthy(family['$[]']("fusible"))) {
            return self.$fuse_deletions(action, family['$[]']("fusible"), [].concat($to_a(family['$[]']("sibbling_left"))).concat($to_a(family['$[]']("child"))).concat($to_a(family['$[]']("sibbling_right"))))
          } else {
            
            extra_sibbling = ($truthy(family['$[]']("parent")) ? (family['$[]']("parent").$do_combine(action)) : ($truthy(family['$[]']("child")) ? (action.$with((new Map([["children", family['$[]']("child")], ["enforcer", self.enforcer]]))).$combine_children(action.$children())) : (action)));
            return self.$with((new Map([["children", [].concat($to_a(family['$[]']("sibbling_left"))).concat([extra_sibbling]).concat($to_a(family['$[]']("sibbling_right")))]])));
          };
        });
        
        $def(self, '$combine_children', function $$combine_children(more_children) {
          var self = this;

          return $send(more_children, 'inject', [self], function $$5(parent, new_child){
            
            if (parent == null) parent = nil;
            if (new_child == null) new_child = nil;
            return parent.$place_in_hierarchy(new_child);})
        });
        
        $def(self, '$fuse_deletions', function $$fuse_deletions(action, fusible, other_sibblings) {
          var self = this, without_fusible = nil, fused_range = nil, fused_deletion = nil;

          
          without_fusible = self.$with((new Map([["children", other_sibblings]])));
          fused_range = $send([action].concat($to_a(fusible)), 'map', [], "range".$to_proc()).$inject("join");
          fused_deletion = action.$with((new Map([["range", fused_range]])));
          return without_fusible.$do_combine(fused_deletion);
        });
        
        $def(self, '$bsearch_child_index', function $$bsearch_child_index(from) {
          var $yield = $$bsearch_child_index.$$p || nil, self = this, size = nil, $ret_or_1 = nil;

          $$bsearch_child_index.$$p = null;
          
          if (from == null) from = 0;
          size = self.children.$size();
          if ($truthy(($ret_or_1 = $send(Opal.Range.$new(from,size, true), 'bsearch', [], function $$6(i){var self = $$6.$$s == null ? this : $$6.$$s;
            if (self.children == null) self.children = nil;

            
            if (i == null) i = nil;
            return Opal.yield1($yield, self.children['$[]'](i));;}, {$$s: self})))) {
            return $ret_or_1
          } else {
            return size
          };
        }, -1);
        
        $def(self, '$analyse_hierarchy', function $$analyse_hierarchy(action) {
          var self = this, r = nil, left_index = nil, start = nil, right_index = nil, center = nil, parent = nil, overlap_left = nil, overlap_right = nil, contained = nil, fusible = nil;

          
          r = action.$range();
          left_index = $send(self, 'bsearch_child_index', [], function $$7(child){
            
            if (child == null) child = nil;
            return $rb_gt(child.$range().$end_pos(), r.$begin_pos());});
          start = ($eqeq(left_index, 0) ? (0) : ($rb_minus(left_index, 1)));
          right_index = $send(self, 'bsearch_child_index', [start], function $$8(child){
            
            if (child == null) child = nil;
            return $rb_ge(child.$range().$begin_pos(), r.$end_pos());});
          center = $rb_minus(right_index, left_index);
          
          switch (center.valueOf()) {
            case 0:
              
              break;
            case -1:
              
              left_index = $rb_minus(left_index, 1);
              right_index = $rb_plus(right_index, 1);
              parent = self.children['$[]'](left_index);
              break;
            default:
              
              overlap_left = self.children['$[]'](left_index).$range().$begin_pos()['$<=>'](r.$begin_pos());
              overlap_right = self.children['$[]']($rb_minus(right_index, 1)).$range().$end_pos()['$<=>'](r.$end_pos());
              if ((($eqeq(center, 1) && ($truthy($rb_le(overlap_left, 0)))) && ($truthy($rb_ge(overlap_right, 0))))) {
                parent = self.children['$[]'](left_index)
              } else {
                
                contained = self.children['$[]'](Opal.Range.$new(left_index,right_index, true));
                fusible = self.$check_fusible(action, ($truthy($rb_lt(overlap_left, 0)) ? (contained.$shift()) : nil), ($truthy($rb_gt(overlap_right, 0)) ? (contained.$pop()) : nil));
              };
          };
          return (new Map([["parent", parent], ["sibbling_left", self.children['$[]'](Opal.Range.$new(0,left_index, true))], ["sibbling_right", self.children['$[]'](Opal.Range.$new(right_index,self.children.$size(), true))], ["fusible", fusible], ["child", contained]]));
        });
        
        $def(self, '$check_fusible', function $$check_fusible(action, $a) {
          var $post_args, fusible, self = this;

          
          $post_args = $slice(arguments, 1);
          fusible = $post_args;
          fusible['$compact!']();
          if ($truthy(fusible['$empty?']())) {
            return nil
          };
          $send(fusible, 'each', [], function $$9(child){var self = $$9.$$s == null ? this : $$9.$$s, kind = nil;
            if (self.enforcer == null) self.enforcer = nil;

            
            if (child == null) child = nil;
            kind = (($truthy(action['$insertion?']()) || ($truthy(child['$insertion?']()))) ? ("crossing_insertions") : ("crossing_deletions"));
            return $send(self.enforcer, 'call', [kind], function $$10(){
              return (new Map([["range", action.$range()], ["conflict", child.$range()]]))});}, {$$s: self});
          return fusible;
        }, -2);
        
        $def(self, '$merge', function $$merge(action) {
          var self = this, $ret_or_1 = nil;

          
          self.$call_enforcer_for_merge(action);
          return self.$with((new Map([["insert_before", "" + (action.$insert_before()) + (self.$insert_before())], ["replacement", ($truthy(($ret_or_1 = action.$replacement())) ? ($ret_or_1) : (self.replacement))], ["insert_after", "" + (self.$insert_after()) + (action.$insert_after())]]))).$combine_children(action.$children());
        });
        
        $def(self, '$call_enforcer_for_merge', function $$call_enforcer_for_merge(action) {
          var self = this;

          return $send(self.enforcer, 'call', ["different_replacements"], function $$11(){var self = $$11.$$s == null ? this : $$11.$$s;
            if (self.replacement == null) self.replacement = nil;
            if (self.range == null) self.range = nil;

            if ((($truthy(self.replacement) && ($truthy(action.$replacement()))) && ($neqeq(self.replacement, action.$replacement())))) {
              return (new Map([["range", self.range], ["replacement", action.$replacement()], ["other_replacement", self.replacement]]))
            } else {
              return nil
            }}, {$$s: self})
        });
        return $def(self, '$swallow', function $$swallow(children) {
          var self = this;

          
          $send(self.enforcer, 'call', ["swallowed_insertions"], function $$12(){var self = $$12.$$s == null ? this : $$12.$$s, insertions = nil;
            if (self.range == null) self.range = nil;

            
            insertions = $send(children, 'select', [], "insertion?".$to_proc());
            if ($truthy(insertions['$empty?']())) {
              return nil
            } else {
              return (new Map([["range", self.range], ["conflict", $send(insertions, 'map', [], "range".$to_proc())]]))
            };}, {$$s: self});
          return [];
        });
      })($$('TreeRewriter'), null)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
