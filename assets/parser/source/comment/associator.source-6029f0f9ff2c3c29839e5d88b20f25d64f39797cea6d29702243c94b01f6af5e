Opal.queue(function(Opal) {/* Generated by Opal 1.8.1 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $const_set = Opal.const_set, $truthy = Opal.truthy, $send = Opal.send, $eqeq = Opal.eqeq, $rb_le = Opal.rb_le, $rb_plus = Opal.rb_plus, $not = Opal.not, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_accessor,do_associate,private,freeze,[],include?,type,sort_by,compact,children,begin_pos,expression,loc,select,is_a?,new,[]=,==,compare_by_identity,advance_comment,advance_through_directives,visit,process_leading_comments,location,<=,line,last_line,each,children_in_source_order,process_trailing_comments,current_comment_before?,associate_and_advance_comment,current_comment_before_end?,current_comment_decorates?,+,!,end_pos,<<,start_with?,text,=~');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Associator');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.map_using = $proto.mapping = $proto.skip_directives = $proto.ast = $proto.current_comment = $proto.comment_num = $proto.comments = nil;
        
        self.$attr_accessor("skip_directives");
        
        $def(self, '$initialize', function $$initialize(ast, comments) {
          var self = this;

          
          self.ast = ast;
          self.comments = comments;
          return (self.skip_directives = true);
        });
        
        $def(self, '$associate', function $$associate() {
          var self = this;

          
          self.map_using = "eql";
          return self.$do_associate();
        });
        
        $def(self, '$associate_locations', function $$associate_locations() {
          var self = this;

          
          self.map_using = "location";
          return self.$do_associate();
        });
        
        $def(self, '$associate_by_identity', function $$associate_by_identity() {
          var self = this;

          
          self.map_using = "identity";
          return self.$do_associate();
        });
        self.$private();
        $const_set($nesting[0], 'POSTFIX_TYPES', $$('Set')['$[]']("if", "while", "while_post", "until", "until_post", "masgn").$freeze());
        
        $def(self, '$children_in_source_order', function $$children_in_source_order(node) {
          
          if ($truthy($$('POSTFIX_TYPES')['$include?'](node.$type()))) {
            return $send(node.$children().$compact(), 'sort_by', [], function $$1(child){
              
              if (child == null) child = nil;
              return child.$loc().$expression().$begin_pos();})
          } else {
            return $send(node.$children(), 'select', [], function $$2(child){var $ret_or_1 = nil, $ret_or_2 = nil;

              
              if (child == null) child = nil;
              if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = child['$is_a?']($$$($$('AST'), 'Node')))) ? (child.$loc()) : ($ret_or_2))))) {
                return child.$loc().$expression()
              } else {
                return $ret_or_1
              };})
          }
        });
        
        $def(self, '$do_associate', function $$do_associate() {
          var self = this;

          
          self.mapping = $send($$('Hash'), 'new', [], function $$3(h, k){var $a;

            
            if (h == null) h = nil;
            if (k == null) k = nil;
            return ($a = [k, []], $send(h, '[]=', $a), $a[$a.length - 1]);});
          if ($eqeq(self.map_using, "identity")) {
            self.mapping.$compare_by_identity()
          };
          self.comment_num = -1;
          self.$advance_comment();
          if ($truthy(self.skip_directives)) {
            self.$advance_through_directives()
          };
          if ($truthy(self.ast)) {
            self.$visit(self.ast)
          };
          return self.mapping;
        });
        
        $def(self, '$visit', function $$visit(node) {
          var self = this, node_loc = nil;

          
          self.$process_leading_comments(node);
          if (!$truthy(self.current_comment)) {
            return nil
          };
          node_loc = node.$location();
          if (($truthy($rb_le(self.current_comment.$location().$line(), node_loc.$last_line())) || ($truthy(node_loc['$is_a?']($$$($$('Map'), 'Heredoc')))))) {
            
            $send(self.$children_in_source_order(node), 'each', [], function $$4(child){var self = $$4.$$s == null ? this : $$4.$$s;

              
              if (child == null) child = nil;
              return self.$visit(child);}, {$$s: self});
            return self.$process_trailing_comments(node);
          } else {
            return nil
          };
        });
        
        $def(self, '$process_leading_comments', function $$process_leading_comments(node) {
          var self = this;

          
          if ($eqeq(node.$type(), "begin")) {
            return nil
          };
          while ($truthy(self['$current_comment_before?'](node))) {
          self.$associate_and_advance_comment(node)
          };
        });
        
        $def(self, '$process_trailing_comments', function $$process_trailing_comments(node) {
          var self = this;

          
          while ($truthy(self['$current_comment_before_end?'](node))) {
          self.$associate_and_advance_comment(node)
          };
          while ($truthy(self['$current_comment_decorates?'](node))) {
          self.$associate_and_advance_comment(node)
          };
        });
        
        $def(self, '$advance_comment', function $$advance_comment() {
          var self = this;

          
          self.comment_num = $rb_plus(self.comment_num, 1);
          return (self.current_comment = self.comments['$[]'](self.comment_num));
        });
        
        $def(self, '$current_comment_before?', function $Associator_current_comment_before$ques$5(node) {
          var self = this, comment_loc = nil, node_loc = nil;

          
          if ($not(self.current_comment)) {
            return false
          };
          comment_loc = self.current_comment.$location().$expression();
          node_loc = node.$location().$expression();
          return $rb_le(comment_loc.$end_pos(), node_loc.$begin_pos());
        });
        
        $def(self, '$current_comment_before_end?', function $Associator_current_comment_before_end$ques$6(node) {
          var self = this, comment_loc = nil, node_loc = nil;

          
          if ($not(self.current_comment)) {
            return false
          };
          comment_loc = self.current_comment.$location().$expression();
          node_loc = node.$location().$expression();
          return $rb_le(comment_loc.$end_pos(), node_loc.$end_pos());
        });
        
        $def(self, '$current_comment_decorates?', function $Associator_current_comment_decorates$ques$7(node) {
          var self = this;

          
          if ($not(self.current_comment)) {
            return false
          };
          return self.current_comment.$location().$line()['$=='](node.$location().$last_line());
        });
        
        $def(self, '$associate_and_advance_comment', function $$associate_and_advance_comment(node) {
          var self = this, key = nil;

          
          key = ($eqeq(self.map_using, "location") ? (node.$location()) : (node));
          self.mapping['$[]'](key)['$<<'](self.current_comment);
          return self.$advance_comment();
        });
        $const_set($nesting[0], 'MAGIC_COMMENT_RE', /^#\s*(-\*-|)\s*(frozen_string_literal|warn_indent|warn_past_scope):.*\1$/);
        return $def(self, '$advance_through_directives', function $$advance_through_directives() {
          var self = this;

          
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$start_with?']("#!".$freeze()))))) {
            self.$advance_comment()
          };
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$=~']($$('MAGIC_COMMENT_RE')))))) {
            self.$advance_comment()
          };
          if (($truthy(self.current_comment) && ($truthy(self.current_comment.$text()['$=~']($$$($$('Buffer'), 'ENCODING_RE')))))) {
            return self.$advance_comment()
          } else {
            return nil
          };
        });
      })($$('Comment'), null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
});
