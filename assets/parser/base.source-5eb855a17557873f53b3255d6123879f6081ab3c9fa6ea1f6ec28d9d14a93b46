Opal.queue(function(Opal) {/* Generated by Opal 1.8.2 */
  var $module = Opal.module, $klass = Opal.klass, $defs = Opal.defs, $send = Opal.send, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $def = Opal.def, $not = Opal.not, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('default_parser,setup_source_buffer,default_encoding,parse,parse_with_comments,read,new,all_errors_are_fatal=,diagnostics,ignore_warnings=,consumer=,lambda,puts,render,force_encoding,dup,==,name,raw_source=,source=,private_class_method,attr_reader,version,diagnostics=,static_env=,context=,parser=,[],class,reset,source_buffer=,do_parse,comments=,comments,tokens=,!,raise,tokens,private,advance,===,diagnostic,map,process,yyerror,token_to_str');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Base');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.lexer = $proto.diagnostics = $proto.static_env = $proto.context = $proto.builder = $proto.current_arg_stack = $proto.pattern_variables = $proto.pattern_hash_keys = nil;
      
      $defs(self, '$parse', function $$parse(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        if (file == null) file = "(string)";
        if (line == null) line = 1;
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse(source_buffer);
      }, -2);
      $defs(self, '$parse_with_comments', function $$parse_with_comments(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        if (file == null) file = "(string)";
        if (line == null) line = 1;
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse_with_comments(source_buffer);
      }, -2);
      $defs(self, '$parse_file', function $$parse_file(filename) {
        var self = this;

        return self.$parse($$('File').$read(filename), filename)
      });
      $defs(self, '$parse_file_with_comments', function $$parse_file_with_comments(filename) {
        var self = this;

        return self.$parse_with_comments($$('File').$read(filename), filename)
      });
      $defs(self, '$default_parser', function $$default_parser() {
        var self = this, parser = nil;

        
        parser = self.$new();
        parser.$diagnostics()['$all_errors_are_fatal='](true);
        parser.$diagnostics()['$ignore_warnings='](true);
        parser.$diagnostics()['$consumer=']($send(self, 'lambda', [], function $$1(diagnostic){          if ($gvars.stderr == null) $gvars.stderr = nil;

          
          if (diagnostic == null) diagnostic = nil;
          return $gvars.stderr.$puts(diagnostic.$render());}));
        return parser;
      });
      $defs(self, '$setup_source_buffer', function $$setup_source_buffer(file, line, string, encoding) {
        var self = this, source_buffer = nil;

        
        string = string.$dup().$force_encoding(encoding);
        source_buffer = $$$($$('Source'), 'Buffer').$new(file, line);
        if ($eqeq(self.$name(), "Parser::Ruby18")) {
          source_buffer['$raw_source='](string)
        } else {
          source_buffer['$source='](string)
        };
        return source_buffer;
      });
      self.$private_class_method("setup_source_buffer");
      self.$attr_reader("lexer");
      self.$attr_reader("diagnostics");
      self.$attr_reader("builder");
      self.$attr_reader("static_env");
      self.$attr_reader("source_buffer");
      self.$attr_reader("context");
      self.$attr_reader("max_numparam_stack");
      self.$attr_reader("current_arg_stack");
      self.$attr_reader("pattern_variables");
      self.$attr_reader("pattern_hash_keys");
      
      $def(self, '$initialize', function $$initialize(builder) {
        var self = this;

        
        if (builder == null) builder = $$$($$$($$('Parser'), 'Builders'), 'Default').$new();
        self.diagnostics = $$$($$('Diagnostic'), 'Engine').$new();
        self.static_env = $$('StaticEnvironment').$new();
        self.context = $$('Context').$new();
        self.max_numparam_stack = $$('MaxNumparamStack').$new();
        self.current_arg_stack = $$('CurrentArgStack').$new();
        self.pattern_variables = $$('VariablesStack').$new();
        self.pattern_hash_keys = $$('VariablesStack').$new();
        self.lexer = $$('Lexer').$new(self.$version());
        self.lexer['$diagnostics='](self.diagnostics);
        self.lexer['$static_env='](self.static_env);
        self.lexer['$context='](self.context);
        self.builder = builder;
        self.builder['$parser='](self);
        self.last_token = nil;
        if (($truthy($$$(self.$class(), 'Racc_debug_parser')) && ($truthy($$('ENV')['$[]']("RACC_DEBUG"))))) {
          self.yydebug = true
        };
        return self.$reset();
      }, -1);
      
      $def(self, '$reset', function $$reset() {
        var self = this;

        
        self.source_buffer = nil;
        self.lexer.$reset();
        self.static_env.$reset();
        self.context.$reset();
        self.current_arg_stack.$reset();
        self.pattern_variables.$reset();
        self.pattern_hash_keys.$reset();
        return self;
      });
      
      $def(self, '$parse', function $$parse(source_buffer) {
        var $a, self = this, $ret_or_1 = nil;

        return (function() { try {
        
        self.lexer['$source_buffer='](source_buffer);
        self.source_buffer = source_buffer;
        if ($truthy(($ret_or_1 = self.$do_parse()))) {
          return $ret_or_1
        } else {
          return nil
        };
        } finally {
          ((self.source_buffer = nil), ($a = [nil], $send(self.lexer, 'source_buffer=', $a), $a[$a.length - 1]))
        }; })()
      });
      
      $def(self, '$parse_with_comments', function $$parse_with_comments(source_buffer) {
        var $a, self = this;

        return (function() { try {
        
        self.lexer['$comments=']([]);
        return [self.$parse(source_buffer), self.lexer.$comments()];
        } finally {
          ($a = [nil], $send(self.lexer, 'comments=', $a), $a[$a.length - 1])
        }; })()
      });
      
      $def(self, '$tokenize', function $$tokenize(source_buffer, recover) {
        var $a, self = this, ast = nil;

        
        if (recover == null) recover = false;
        return (function() { try {
        
        self.lexer['$tokens=']([]);
        self.lexer['$comments=']([]);
        
        try {
          ast = self.$parse(source_buffer)
        } catch ($err) {
          if (Opal.rescue($err, [$$$($$('Parser'), 'SyntaxError')])) {
            try {
              if ($not(recover)) {
                self.$raise()
              }
            } finally { Opal.pop_exception($err); }
          } else { throw $err; }
        };;
        return [ast, self.lexer.$comments(), self.lexer.$tokens()];
        } finally {
          (($a = [nil], $send(self.lexer, 'tokens=', $a), $a[$a.length - 1]), ($a = [nil], $send(self.lexer, 'comments=', $a), $a[$a.length - 1]))
        }; })();
      }, -2);
      self.$private();
      
      $def(self, '$next_token', function $$next_token() {
        var self = this, token = nil;

        
        token = self.lexer.$advance();
        self.last_token = token;
        return token;
      });
      
      $def(self, '$check_kwarg_name', function $$check_kwarg_name(name_t) {
        var self = this, $ret_or_1 = nil;

        if ($eqeqeq(/^[a-z_]/, ($ret_or_1 = name_t['$[]'](0)))) {
          return nil
        } else if ($eqeqeq(/^[A-Z]/, $ret_or_1)) {
          return self.$diagnostic("error", "argument_const", nil, name_t)
        } else {
          return nil
        }
      });
      
      $def(self, '$diagnostic', function $$diagnostic(level, reason, arguments$, location_t, highlights_ts) {
        var $a, $b, self = this, _ = nil, location = nil, highlights = nil;

        
        if (highlights_ts == null) highlights_ts = [];
        $b = location_t, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        highlights = $send(highlights_ts, 'map', [], function $$2(token){var $c, $d, range = nil;

          
          if (token == null) token = nil;
          $d = token, $c = $to_ary($d), (_ = ($c[0] == null ? nil : $c[0])), (range = ($c[1] == null ? nil : $c[1])), $d;
          return range;});
        self.diagnostics.$process($$('Diagnostic').$new(level, reason, arguments$, location, highlights));
        if ($eqeq(level, "error")) {
          return self.$yyerror()
        } else {
          return nil
        };
      }, -5);
      return $def(self, '$on_error', function $$on_error(error_token_id, error_value, value_stack) {
        var $a, $b, self = this, token_name = nil, _ = nil, location = nil;

        
        token_name = self.$token_to_str(error_token_id);
        $b = error_value, $a = $to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        return self.diagnostics.$process($$('Diagnostic').$new("error", "unexpected_token", (new Map([["token", token_name]])), location));
      });
    })($nesting[0], $$$($$('Racc'), 'Parser'), $nesting)
  })($nesting[0], $nesting)
});
